// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(c *gin.Context)
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(c *gin.Context, masterName string)
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(c *gin.Context)
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(c *gin.Context, workerName string)
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(c *gin.Context)
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(c *gin.Context)
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(c *gin.Context, params DMAPIGetSourceListParams)
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(c *gin.Context)
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(c *gin.Context, sourceName string, params DMAPIDeleteSourceParams)
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(c *gin.Context, sourceName string)
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(c *gin.Context, sourceName string)
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(c *gin.Context, sourceName string)
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(c *gin.Context, sourceName string, schemaName string)
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(c *gin.Context, sourceName string)
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(c *gin.Context, sourceName string)
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(c *gin.Context, sourceName string)
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(c *gin.Context, sourceName string)
	// get task template list
	// (GET /api/v1/task/templates)
	DMAPIGetTaskTemplateList(c *gin.Context)
	// create task template
	// (POST /api/v1/task/templates)
	DMAPICreateTaskTemplate(c *gin.Context)
	// import task template
	// (POST /api/v1/task/templates/import)
	DMAPIImportTaskTemplate(c *gin.Context)
	// delete task template template
	// (DELETE /api/v1/task/templates/{task-name})
	DMAPIDeleteTaskTemplate(c *gin.Context, taskName string)
	// get task template template
	// (GET /api/v1/task/templates/{task-name})
	DMAPIGetTaskTemplate(c *gin.Context, taskName string)
	// update task template template
	// (PUT /api/v1/task/templates/{task-name})
	DMAPUpdateTaskTemplate(c *gin.Context, taskName string)
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(c *gin.Context, params DMAPIGetTaskListParams)
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(c *gin.Context)
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(c *gin.Context, taskName string, params DMAPIDeleteTaskParams)
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPIPauseTask(c *gin.Context, taskName string)
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(c *gin.Context, taskName string)
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetSchemaListByTaskAndSource(c *gin.Context, taskName string, sourceName string)
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTableListByTaskAndSource(c *gin.Context, taskName string, sourceName string, schemaName string)
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(c *gin.Context, taskName string, params DMAPIGetTaskStatusParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// DMAPIGetClusterMasterList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterMasterList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterMasterList(c)
}

// DMAPIOfflineMasterNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineMasterNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameter("simple", false, "master-name", c.Param("master-name"), &masterName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter master-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineMasterNode(c, masterName)
}

// DMAPIGetClusterWorkerList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterWorkerList(c)
}

// DMAPIOfflineWorkerNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameter("simple", false, "worker-name", c.Param("worker-name"), &workerName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter worker-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineWorkerNode(c, workerName)
}

// GetDocJSON operation middleware
func (siw *ServerInterfaceWrapper) GetDocJSON(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocJSON(c)
}

// GetDocHTML operation middleware
func (siw *ServerInterfaceWrapper) GetDocHTML(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocHTML(c)
}

// DMAPIGetSourceList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceList(c, params)
}

// DMAPICreateSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateSource(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateSource(c)
}

// DMAPIDeleteSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := c.Query("force"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "force", c.Request.URL.Query(), &params.Force)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter force: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteSource(c, sourceName, params)
}

// DMAPIPauseRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseRelay(c, sourceName)
}

// DMAPIResumeRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeRelay(c, sourceName)
}

// DMAPIGetSourceSchemaList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceSchemaList(c, sourceName)
}

// DMAPIGetSourceTableList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceTableList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceTableList(c, sourceName, schemaName)
}

// DMAPIStartRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartRelay(c, sourceName)
}

// DMAPIGetSourceStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceStatus(c, sourceName)
}

// DMAPIStopRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStopRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStopRelay(c, sourceName)
}

// DMAPITransferSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPITransferSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPITransferSource(c, sourceName)
}

// DMAPIGetTaskTemplateList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskTemplateList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskTemplateList(c)
}

// DMAPICreateTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateTaskTemplate(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateTaskTemplate(c)
}

// DMAPIImportTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIImportTaskTemplate(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIImportTaskTemplate(c)
}

// DMAPIDeleteTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTaskTemplate(c, taskName)
}

// DMAPIGetTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskTemplate(c, taskName)
}

// DMAPUpdateTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPUpdateTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPUpdateTaskTemplate(c, taskName)
}

// DMAPIGetTaskList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskList(c, params)
}

// DMAPIStartTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartTask(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartTask(c)
}

// DMAPIDeleteTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTask(c, taskName, params)
}

// DMAPIPauseTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseTask(c, taskName)
}

// DMAPIResumeTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeTask(c, taskName)
}

// DMAPIGetSchemaListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSchemaListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSchemaListByTaskAndSource(c, taskName, sourceName)
}

// DMAPIGetTableListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableListByTaskAndSource(c, taskName, sourceName, schemaName)
}

// DMAPIDeleteTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIOperateTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOperateTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOperateTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTaskStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskStatus(c, taskName, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)

	router.GET(options.BaseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)

	router.GET(options.BaseURL+"/api/v1/dm.json", wrapper.GetDocJSON)

	router.GET(options.BaseURL+"/api/v1/docs", wrapper.GetDocHTML)

	router.GET(options.BaseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)

	router.POST(options.BaseURL+"/api/v1/sources", wrapper.DMAPICreateSource)

	router.DELETE(options.BaseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)

	router.GET(options.BaseURL+"/api/v1/task/templates", wrapper.DMAPIGetTaskTemplateList)

	router.POST(options.BaseURL+"/api/v1/task/templates", wrapper.DMAPICreateTaskTemplate)

	router.POST(options.BaseURL+"/api/v1/task/templates/import", wrapper.DMAPIImportTaskTemplate)

	router.DELETE(options.BaseURL+"/api/v1/task/templates/:task-name", wrapper.DMAPIDeleteTaskTemplate)

	router.GET(options.BaseURL+"/api/v1/task/templates/:task-name", wrapper.DMAPIGetTaskTemplate)

	router.PUT(options.BaseURL+"/api/v1/task/templates/:task-name", wrapper.DMAPUpdateTaskTemplate)

	router.GET(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)

	router.POST(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPIPauseTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetSchemaListByTaskAndSource)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTableListByTaskAndSource)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTableStructure)

	router.PUT(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
