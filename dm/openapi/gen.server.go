// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(c *gin.Context)
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(c *gin.Context, masterName string)
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(c *gin.Context)
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(c *gin.Context, workerName string)
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(c *gin.Context)
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(c *gin.Context)
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(c *gin.Context, params DMAPIGetSourceListParams)
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(c *gin.Context)
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(c *gin.Context, sourceName string, params DMAPIDeleteSourceParams)
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(c *gin.Context, sourceName string)
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(c *gin.Context, sourceName string)
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(c *gin.Context, sourceName string)
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(c *gin.Context, sourceName string, schemaName string)
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(c *gin.Context, sourceName string)
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(c *gin.Context, sourceName string)
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(c *gin.Context, sourceName string)
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(c *gin.Context, sourceName string)
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(c *gin.Context, params DMAPIGetTaskListParams)
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(c *gin.Context)
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(c *gin.Context, taskName string, params DMAPIDeleteTaskParams)
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPIPauseTask(c *gin.Context, taskName string)
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(c *gin.Context, taskName string)
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetSchemaListByTaskAndSource(c *gin.Context, taskName string, sourceName string)
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTableListByTaskAndSource(c *gin.Context, taskName string, sourceName string, schemaName string)
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(c *gin.Context, taskName string, params DMAPIGetTaskStatusParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// DMAPIGetClusterMasterList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterMasterList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterMasterList(c)
}

// DMAPIOfflineMasterNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineMasterNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameter("simple", false, "master-name", c.Param("master-name"), &masterName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter master-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineMasterNode(c, masterName)
}

// DMAPIGetClusterWorkerList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterWorkerList(c)
}

// DMAPIOfflineWorkerNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameter("simple", false, "worker-name", c.Param("worker-name"), &workerName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter worker-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineWorkerNode(c, workerName)
}

// GetDocJSON operation middleware
func (siw *ServerInterfaceWrapper) GetDocJSON(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocJSON(c)
}

// GetDocHTML operation middleware
func (siw *ServerInterfaceWrapper) GetDocHTML(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocHTML(c)
}

// DMAPIGetSourceList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceList(c, params)
}

// DMAPICreateSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateSource(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateSource(c)
}

// DMAPIDeleteSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := c.Query("force"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "force", c.Request.URL.Query(), &params.Force)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter force: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteSource(c, sourceName, params)
}

// DMAPIPauseRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseRelay(c, sourceName)
}

// DMAPIResumeRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeRelay(c, sourceName)
}

// DMAPIGetSourceSchemaList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceSchemaList(c, sourceName)
}

// DMAPIGetSourceTableList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceTableList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceTableList(c, sourceName, schemaName)
}

// DMAPIStartRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartRelay(c, sourceName)
}

// DMAPIGetSourceStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceStatus(c, sourceName)
}

// DMAPIStopRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStopRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStopRelay(c, sourceName)
}

// DMAPITransferSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPITransferSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPITransferSource(c, sourceName)
}

// DMAPIGetTaskList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskList(c, params)
}

// DMAPIStartTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartTask(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartTask(c)
}

// DMAPIDeleteTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTask(c, taskName, params)
}

// DMAPIPauseTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseTask(c, taskName)
}

// DMAPIResumeTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeTask(c, taskName)
}

// DMAPIGetSchemaListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSchemaListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSchemaListByTaskAndSource(c, taskName, sourceName)
}

// DMAPIGetTableListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableListByTaskAndSource(c, taskName, sourceName, schemaName)
}

// DMAPIDeleteTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIOperateTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOperateTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOperateTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTaskStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskStatus(c, taskName, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)

	router.GET(options.BaseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)

	router.GET(options.BaseURL+"/api/v1/dm.json", wrapper.GetDocJSON)

	router.GET(options.BaseURL+"/api/v1/docs", wrapper.GetDocHTML)

	router.GET(options.BaseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)

	router.POST(options.BaseURL+"/api/v1/sources", wrapper.DMAPICreateSource)

	router.DELETE(options.BaseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)

	router.GET(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)

	router.POST(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPIPauseTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetSchemaListByTaskAndSource)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTableListByTaskAndSource)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTableStructure)

	router.PUT(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"DgAA//8vuqXa2IAAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
