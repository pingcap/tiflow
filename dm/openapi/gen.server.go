// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(c *gin.Context)
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(c *gin.Context, masterName string)
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(c *gin.Context)
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(c *gin.Context, workerName string)
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(c *gin.Context)
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(c *gin.Context)
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(c *gin.Context, params DMAPIGetSourceListParams)
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(c *gin.Context)
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(c *gin.Context, sourceName string, params DMAPIDeleteSourceParams)
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(c *gin.Context, sourceName string)
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(c *gin.Context, sourceName string)
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(c *gin.Context, sourceName string)
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(c *gin.Context, sourceName string, schemaName string)
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(c *gin.Context, sourceName string)
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(c *gin.Context, sourceName string)
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(c *gin.Context, sourceName string)
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(c *gin.Context, sourceName string)
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(c *gin.Context, params DMAPIGetTaskListParams)
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(c *gin.Context)
	// get task template list
	// (GET /api/v1/tasks/templates)
	DMAPIGetTaskTemplateList(c *gin.Context)
	// create task template
	// (POST /api/v1/tasks/templates)
	DMAPICreateTaskTemplate(c *gin.Context)
	// import task template
	// (POST /api/v1/tasks/templates/import)
	DMAPIImportTaskTemplate(c *gin.Context)
	// delete task template template
	// (DELETE /api/v1/tasks/templates/{task-name})
	DMAPIDeleteTaskTemplate(c *gin.Context, taskName string)
	// get task template template
	// (GET /api/v1/tasks/templates/{task-name})
	DMAPIGetTaskTemplate(c *gin.Context, taskName string)
	// update task template template
	// (PUT /api/v1/tasks/templates/{task-name})
	DMAPUpdateTaskTemplate(c *gin.Context, taskName string)
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(c *gin.Context, taskName string, params DMAPIDeleteTaskParams)
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPIPauseTask(c *gin.Context, taskName string)
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(c *gin.Context, taskName string)
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetSchemaListByTaskAndSource(c *gin.Context, taskName string, sourceName string)
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTableListByTaskAndSource(c *gin.Context, taskName string, sourceName string, schemaName string)
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(c *gin.Context, taskName string, params DMAPIGetTaskStatusParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// DMAPIGetClusterMasterList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterMasterList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterMasterList(c)
}

// DMAPIOfflineMasterNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineMasterNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameter("simple", false, "master-name", c.Param("master-name"), &masterName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter master-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineMasterNode(c, masterName)
}

// DMAPIGetClusterWorkerList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterWorkerList(c)
}

// DMAPIOfflineWorkerNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameter("simple", false, "worker-name", c.Param("worker-name"), &workerName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter worker-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineWorkerNode(c, workerName)
}

// GetDocJSON operation middleware
func (siw *ServerInterfaceWrapper) GetDocJSON(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocJSON(c)
}

// GetDocHTML operation middleware
func (siw *ServerInterfaceWrapper) GetDocHTML(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocHTML(c)
}

// DMAPIGetSourceList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceList(c, params)
}

// DMAPICreateSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateSource(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateSource(c)
}

// DMAPIDeleteSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := c.Query("force"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "force", c.Request.URL.Query(), &params.Force)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter force: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteSource(c, sourceName, params)
}

// DMAPIPauseRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseRelay(c, sourceName)
}

// DMAPIResumeRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeRelay(c, sourceName)
}

// DMAPIGetSourceSchemaList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceSchemaList(c, sourceName)
}

// DMAPIGetSourceTableList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceTableList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceTableList(c, sourceName, schemaName)
}

// DMAPIStartRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartRelay(c, sourceName)
}

// DMAPIGetSourceStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceStatus(c, sourceName)
}

// DMAPIStopRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStopRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStopRelay(c, sourceName)
}

// DMAPITransferSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPITransferSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPITransferSource(c, sourceName)
}

// DMAPIGetTaskList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskList(c, params)
}

// DMAPIStartTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartTask(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartTask(c)
}

// DMAPIGetTaskTemplateList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskTemplateList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskTemplateList(c)
}

// DMAPICreateTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateTaskTemplate(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateTaskTemplate(c)
}

// DMAPIImportTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIImportTaskTemplate(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIImportTaskTemplate(c)
}

// DMAPIDeleteTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTaskTemplate(c, taskName)
}

// DMAPIGetTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskTemplate(c, taskName)
}

// DMAPUpdateTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPUpdateTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPUpdateTaskTemplate(c, taskName)
}

// DMAPIDeleteTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTask(c, taskName, params)
}

// DMAPIPauseTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseTask(c, taskName)
}

// DMAPIResumeTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeTask(c, taskName)
}

// DMAPIGetSchemaListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSchemaListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSchemaListByTaskAndSource(c, taskName, sourceName)
}

// DMAPIGetTableListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableListByTaskAndSource(c, taskName, sourceName, schemaName)
}

// DMAPIDeleteTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIOperateTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOperateTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOperateTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTaskStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskStatus(c, taskName, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)

	router.GET(options.BaseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)

	router.GET(options.BaseURL+"/api/v1/dm.json", wrapper.GetDocJSON)

	router.GET(options.BaseURL+"/api/v1/docs", wrapper.GetDocHTML)

	router.GET(options.BaseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)

	router.POST(options.BaseURL+"/api/v1/sources", wrapper.DMAPICreateSource)

	router.DELETE(options.BaseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)

	router.GET(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)

	router.POST(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)

	router.GET(options.BaseURL+"/api/v1/tasks/templates", wrapper.DMAPIGetTaskTemplateList)

	router.POST(options.BaseURL+"/api/v1/tasks/templates", wrapper.DMAPICreateTaskTemplate)

	router.POST(options.BaseURL+"/api/v1/tasks/templates/import", wrapper.DMAPIImportTaskTemplate)

	router.DELETE(options.BaseURL+"/api/v1/tasks/templates/:task-name", wrapper.DMAPIDeleteTaskTemplate)

	router.GET(options.BaseURL+"/api/v1/tasks/templates/:task-name", wrapper.DMAPIGetTaskTemplate)

	router.PUT(options.BaseURL+"/api/v1/tasks/templates/:task-name", wrapper.DMAPUpdateTaskTemplate)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPIPauseTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetSchemaListByTaskAndSource)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTableListByTaskAndSource)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTableStructure)

	router.PUT(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
