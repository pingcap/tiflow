// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(c *gin.Context)
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(c *gin.Context, masterName string)
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(c *gin.Context)
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(c *gin.Context, workerName string)
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(c *gin.Context)
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(c *gin.Context)
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(c *gin.Context, params DMAPIGetSourceListParams)
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(c *gin.Context)
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(c *gin.Context, sourceName string, params DMAPIDeleteSourceParams)
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(c *gin.Context, sourceName string)
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(c *gin.Context, sourceName string)
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(c *gin.Context, sourceName string)
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(c *gin.Context, sourceName string, schemaName string)
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(c *gin.Context, sourceName string)
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(c *gin.Context, sourceName string)
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(c *gin.Context, sourceName string)
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(c *gin.Context, sourceName string)
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(c *gin.Context, params DMAPIGetTaskListParams)
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(c *gin.Context)
	// get task template list
	// (GET /api/v1/tasks/templates)
	DMAPIGetTaskTemplateList(c *gin.Context)
	// create task template
	// (POST /api/v1/tasks/templates)
	DMAPICreateTaskTemplate(c *gin.Context)
	// import task template
	// (POST /api/v1/tasks/templates/import)
	DMAPIImportTaskTemplate(c *gin.Context)
	// delete task template template
	// (DELETE /api/v1/tasks/templates/{task-name})
	DMAPIDeleteTaskTemplate(c *gin.Context, taskName string)
	// get task template template
	// (GET /api/v1/tasks/templates/{task-name})
	DMAPIGetTaskTemplate(c *gin.Context, taskName string)
	// update task template template
	// (PUT /api/v1/tasks/templates/{task-name})
	DMAPUpdateTaskTemplate(c *gin.Context, taskName string)
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(c *gin.Context, taskName string, params DMAPIDeleteTaskParams)
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPIPauseTask(c *gin.Context, taskName string)
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(c *gin.Context, taskName string)
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetSchemaListByTaskAndSource(c *gin.Context, taskName string, sourceName string)
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTableListByTaskAndSource(c *gin.Context, taskName string, sourceName string, schemaName string)
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(c *gin.Context, taskName string, params DMAPIGetTaskStatusParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// DMAPIGetClusterMasterList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterMasterList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterMasterList(c)
}

// DMAPIOfflineMasterNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineMasterNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameter("simple", false, "master-name", c.Param("master-name"), &masterName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter master-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineMasterNode(c, masterName)
}

// DMAPIGetClusterWorkerList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterWorkerList(c)
}

// DMAPIOfflineWorkerNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameter("simple", false, "worker-name", c.Param("worker-name"), &workerName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter worker-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineWorkerNode(c, workerName)
}

// GetDocJSON operation middleware
func (siw *ServerInterfaceWrapper) GetDocJSON(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocJSON(c)
}

// GetDocHTML operation middleware
func (siw *ServerInterfaceWrapper) GetDocHTML(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocHTML(c)
}

// DMAPIGetSourceList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceList(c, params)
}

// DMAPICreateSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateSource(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateSource(c)
}

// DMAPIDeleteSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := c.Query("force"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "force", c.Request.URL.Query(), &params.Force)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter force: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteSource(c, sourceName, params)
}

// DMAPIPauseRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseRelay(c, sourceName)
}

// DMAPIResumeRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeRelay(c, sourceName)
}

// DMAPIGetSourceSchemaList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceSchemaList(c, sourceName)
}

// DMAPIGetSourceTableList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceTableList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceTableList(c, sourceName, schemaName)
}

// DMAPIStartRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartRelay(c, sourceName)
}

// DMAPIGetSourceStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceStatus(c, sourceName)
}

// DMAPIStopRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStopRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStopRelay(c, sourceName)
}

// DMAPITransferSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPITransferSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPITransferSource(c, sourceName)
}

// DMAPIGetTaskList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskList(c, params)
}

// DMAPIStartTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartTask(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartTask(c)
}

// DMAPIGetTaskTemplateList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskTemplateList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskTemplateList(c)
}

// DMAPICreateTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateTaskTemplate(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateTaskTemplate(c)
}

// DMAPIImportTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIImportTaskTemplate(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIImportTaskTemplate(c)
}

// DMAPIDeleteTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTaskTemplate(c, taskName)
}

// DMAPIGetTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskTemplate(c, taskName)
}

// DMAPUpdateTaskTemplate operation middleware
func (siw *ServerInterfaceWrapper) DMAPUpdateTaskTemplate(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPUpdateTaskTemplate(c, taskName)
}

// DMAPIDeleteTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTask(c, taskName, params)
}

// DMAPIPauseTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseTask(c, taskName)
}

// DMAPIResumeTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeTask(c, taskName)
}

// DMAPIGetSchemaListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSchemaListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSchemaListByTaskAndSource(c, taskName, sourceName)
}

// DMAPIGetTableListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableListByTaskAndSource(c, taskName, sourceName, schemaName)
}

// DMAPIDeleteTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIOperateTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOperateTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOperateTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTaskStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskStatus(c, taskName, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)

	router.GET(options.BaseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)

	router.GET(options.BaseURL+"/api/v1/dm.json", wrapper.GetDocJSON)

	router.GET(options.BaseURL+"/api/v1/docs", wrapper.GetDocHTML)

	router.GET(options.BaseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)

	router.POST(options.BaseURL+"/api/v1/sources", wrapper.DMAPICreateSource)

	router.DELETE(options.BaseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)

	router.GET(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)

	router.POST(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)

	router.GET(options.BaseURL+"/api/v1/tasks/templates", wrapper.DMAPIGetTaskTemplateList)

	router.POST(options.BaseURL+"/api/v1/tasks/templates", wrapper.DMAPICreateTaskTemplate)

	router.POST(options.BaseURL+"/api/v1/tasks/templates/import", wrapper.DMAPIImportTaskTemplate)

	router.DELETE(options.BaseURL+"/api/v1/tasks/templates/:task-name", wrapper.DMAPIDeleteTaskTemplate)

	router.GET(options.BaseURL+"/api/v1/tasks/templates/:task-name", wrapper.DMAPIGetTaskTemplate)

	router.PUT(options.BaseURL+"/api/v1/tasks/templates/:task-name", wrapper.DMAPUpdateTaskTemplate)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPIPauseTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetSchemaListByTaskAndSource)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTableListByTaskAndSource)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTableStructure)

	router.PUT(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"8m+QAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
