// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(c *gin.Context)
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(c *gin.Context, masterName string)
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(c *gin.Context)
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(c *gin.Context, workerName string)
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(c *gin.Context)
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(c *gin.Context)
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(c *gin.Context, params DMAPIGetSourceListParams)
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(c *gin.Context)
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(c *gin.Context, sourceName string, params DMAPIDeleteSourceParams)
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(c *gin.Context, sourceName string)
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(c *gin.Context, sourceName string)
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(c *gin.Context, sourceName string)
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(c *gin.Context, sourceName string, schemaName string)
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(c *gin.Context, sourceName string)
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(c *gin.Context, sourceName string)
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(c *gin.Context, sourceName string)
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(c *gin.Context, sourceName string)
	// get task config list
	// (GET /api/v1/task_configs)
	DMAPIGetTaskConfigList(c *gin.Context)
	// create task config
	// (POST /api/v1/task_configs)
	DMAPICreateTaskConfig(c *gin.Context)
	// batch import task config
	// (POST /api/v1/task_configs/batch_import)
	DMAPIBatchImportTaskConfig(c *gin.Context)
	// delete task_config
	// (DELETE /api/v1/task_configs/{task-name})
	DMAPIDeleteTaskConfig(c *gin.Context, taskName string)
	// get task_config
	// (GET /api/v1/task_configs/{task-name})
	DMAPIGetTaskConfig(c *gin.Context, taskName string)
	// update task_config
	// (PUT /api/v1/task_configs/{task-name})
	DMAPUpdateTaskConfig(c *gin.Context, taskName string)
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(c *gin.Context)
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(c *gin.Context)
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(c *gin.Context, taskName string, params DMAPIDeleteTaskParams)
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPIPauseTask(c *gin.Context, taskName string)
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(c *gin.Context, taskName string)
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetSchemaListByTaskAndSource(c *gin.Context, taskName string, sourceName string)
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTableListByTaskAndSource(c *gin.Context, taskName string, sourceName string, schemaName string)
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTableStructure(c *gin.Context, taskName string, sourceName string, schemaName string, tableName string)
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(c *gin.Context, taskName string, params DMAPIGetTaskStatusParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(c *gin.Context)

// DMAPIGetClusterMasterList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterMasterList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterMasterList(c)
}

// DMAPIOfflineMasterNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineMasterNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameter("simple", false, "master-name", c.Param("master-name"), &masterName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter master-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineMasterNode(c, masterName)
}

// DMAPIGetClusterWorkerList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetClusterWorkerList(c)
}

// DMAPIOfflineWorkerNode operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(c *gin.Context) {
	var err error

	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameter("simple", false, "worker-name", c.Param("worker-name"), &workerName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter worker-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOfflineWorkerNode(c, workerName)
}

// GetDocJSON operation middleware
func (siw *ServerInterfaceWrapper) GetDocJSON(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocJSON(c)
}

// GetDocHTML operation middleware
func (siw *ServerInterfaceWrapper) GetDocHTML(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.GetDocHTML(c)
}

// DMAPIGetSourceList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceList(c *gin.Context) {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams

	// ------------- Optional query parameter "with_status" -------------
	if paramValue := c.Query("with_status"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "with_status", c.Request.URL.Query(), &params.WithStatus)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter with_status: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceList(c, params)
}

// DMAPICreateSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateSource(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateSource(c)
}

// DMAPIDeleteSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := c.Query("force"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "force", c.Request.URL.Query(), &params.Force)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter force: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteSource(c, sourceName, params)
}

// DMAPIPauseRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseRelay(c, sourceName)
}

// DMAPIResumeRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeRelay(c, sourceName)
}

// DMAPIGetSourceSchemaList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceSchemaList(c, sourceName)
}

// DMAPIGetSourceTableList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceTableList(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceTableList(c, sourceName, schemaName)
}

// DMAPIStartRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartRelay(c, sourceName)
}

// DMAPIGetSourceStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSourceStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSourceStatus(c, sourceName)
}

// DMAPIStopRelay operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStopRelay(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStopRelay(c, sourceName)
}

// DMAPITransferSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPITransferSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPITransferSource(c, sourceName)
}

// DMAPIGetTaskConfigList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskConfigList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskConfigList(c)
}

// DMAPICreateTaskConfig operation middleware
func (siw *ServerInterfaceWrapper) DMAPICreateTaskConfig(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPICreateTaskConfig(c)
}

// DMAPIBatchImportTaskConfig operation middleware
func (siw *ServerInterfaceWrapper) DMAPIBatchImportTaskConfig(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIBatchImportTaskConfig(c)
}

// DMAPIDeleteTaskConfig operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTaskConfig(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTaskConfig(c, taskName)
}

// DMAPIGetTaskConfig operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskConfig(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskConfig(c, taskName)
}

// DMAPUpdateTaskConfig operation middleware
func (siw *ServerInterfaceWrapper) DMAPUpdateTaskConfig(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPUpdateTaskConfig(c, taskName)
}

// DMAPIGetTaskList operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskList(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskList(c)
}

// DMAPIStartTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIStartTask(c *gin.Context) {
	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIStartTask(c)
}

// DMAPIDeleteTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTask(c, taskName, params)
}

// DMAPIPauseTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIPauseTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIPauseTask(c, taskName)
}

// DMAPIResumeTask operation middleware
func (siw *ServerInterfaceWrapper) DMAPIResumeTask(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIResumeTask(c, taskName)
}

// DMAPIGetSchemaListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetSchemaListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetSchemaListByTaskAndSource(c, taskName, sourceName)
}

// DMAPIGetTableListByTaskAndSource operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableListByTaskAndSource(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableListByTaskAndSource(c, taskName, sourceName, schemaName)
}

// DMAPIDeleteTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIDeleteTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIDeleteTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIOperateTableStructure operation middleware
func (siw *ServerInterfaceWrapper) DMAPIOperateTableStructure(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameter("simple", false, "source-name", c.Param("source-name"), &sourceName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source-name: %s", err)})
		return
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameter("simple", false, "schema-name", c.Param("schema-name"), &schemaName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter schema-name: %s", err)})
		return
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameter("simple", false, "table-name", c.Param("table-name"), &tableName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter table-name: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIOperateTableStructure(c, taskName, sourceName, schemaName, tableName)
}

// DMAPIGetTaskStatus operation middleware
func (siw *ServerInterfaceWrapper) DMAPIGetTaskStatus(c *gin.Context) {
	var err error

	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameter("simple", false, "task-name", c.Param("task-name"), &taskName)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter task-name: %s", err)})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams

	// ------------- Optional query parameter "source_name_list" -------------
	if paramValue := c.Query("source_name_list"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", c.Request.URL.Query(), &params.SourceNameList)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"msg": fmt.Sprintf("Invalid format for parameter source_name_list: %s", err)})
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
	}

	siw.Handler.DMAPIGetTaskStatus(c, taskName, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router *gin.Engine, si ServerInterface) *gin.Engine {
	return RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router *gin.Engine, si ServerInterface, options GinServerOptions) *gin.Engine {
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	router.GET(options.BaseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)

	router.GET(options.BaseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)

	router.DELETE(options.BaseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)

	router.GET(options.BaseURL+"/api/v1/dm.json", wrapper.GetDocJSON)

	router.GET(options.BaseURL+"/api/v1/docs", wrapper.GetDocHTML)

	router.GET(options.BaseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)

	router.POST(options.BaseURL+"/api/v1/sources", wrapper.DMAPICreateSource)

	router.DELETE(options.BaseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)

	router.GET(options.BaseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)

	router.POST(options.BaseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)

	router.GET(options.BaseURL+"/api/v1/task_configs", wrapper.DMAPIGetTaskConfigList)

	router.POST(options.BaseURL+"/api/v1/task_configs", wrapper.DMAPICreateTaskConfig)

	router.POST(options.BaseURL+"/api/v1/task_configs/batch_import", wrapper.DMAPIBatchImportTaskConfig)

	router.DELETE(options.BaseURL+"/api/v1/task_configs/:task-name", wrapper.DMAPIDeleteTaskConfig)

	router.GET(options.BaseURL+"/api/v1/task_configs/:task-name", wrapper.DMAPIGetTaskConfig)

	router.PUT(options.BaseURL+"/api/v1/task_configs/:task-name", wrapper.DMAPUpdateTaskConfig)

	router.GET(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)

	router.POST(options.BaseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPIPauseTask)

	router.POST(options.BaseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetSchemaListByTaskAndSource)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTableListByTaskAndSource)

	router.DELETE(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTableStructure)

	router.PUT(options.BaseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTableStructure)

	router.GET(options.BaseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)

	return router
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
