// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.2 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get cluster master node list
	// (GET /api/v1/cluster/masters)
	DMAPIGetClusterMasterList(ctx echo.Context) error
	// offline master node
	// (DELETE /api/v1/cluster/masters/{master-name})
	DMAPIOfflineMasterNode(ctx echo.Context, masterName string) error
	// get cluster worker node list
	// (GET /api/v1/cluster/workers)
	DMAPIGetClusterWorkerList(ctx echo.Context) error
	// offline worker node
	// (DELETE /api/v1/cluster/workers/{worker-name})
	DMAPIOfflineWorkerNode(ctx echo.Context, workerName string) error
	// get doc json
	// (GET /api/v1/dm.json)
	GetDocJSON(ctx echo.Context) error
	// get doc html
	// (GET /api/v1/docs)
	GetDocHTML(ctx echo.Context) error
	// get data source list
	// (GET /api/v1/sources)
	DMAPIGetSourceList(ctx echo.Context, params DMAPIGetSourceListParams) error
	// create new data source
	// (POST /api/v1/sources)
	DMAPICreateSource(ctx echo.Context) error
	// delete a data source
	// (DELETE /api/v1/sources/{source-name})
	DMAPIDeleteSource(ctx echo.Context, sourceName string, params DMAPIDeleteSourceParams) error
	// pause relay log function for the data source
	// (POST /api/v1/sources/{source-name}/pause-relay)
	DMAPIPauseRelay(ctx echo.Context, sourceName string) error
	// resume relay log function for the data source
	// (POST /api/v1/sources/{source-name}/resume-relay)
	DMAPIResumeRelay(ctx echo.Context, sourceName string) error
	// get source schema list
	// (GET /api/v1/sources/{source-name}/schemas)
	DMAPIGetSourceSchemaList(ctx echo.Context, sourceName string) error
	// get source table list
	// (GET /api/v1/sources/{source-name}/schemas/{schema-name})
	DMAPIGetSourceTableList(ctx echo.Context, sourceName string, schemaName string) error
	// enable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/start-relay)
	DMAPIStartRelay(ctx echo.Context, sourceName string) error
	// get the current status of the data source
	// (GET /api/v1/sources/{source-name}/status)
	DMAPIGetSourceStatus(ctx echo.Context, sourceName string) error
	// disable relay log function for the data source
	// (POST /api/v1/sources/{source-name}/stop-relay)
	DMAPIStopRelay(ctx echo.Context, sourceName string) error
	// transfer source to a free worker
	// (POST /api/v1/sources/{source-name}/transfer)
	DMAPITransferSource(ctx echo.Context, sourceName string) error
	// get task list
	// (GET /api/v1/tasks)
	DMAPIGetTaskList(ctx echo.Context) error
	// create and start task
	// (POST /api/v1/tasks)
	DMAPIStartTask(ctx echo.Context) error
	// delete and stop task
	// (DELETE /api/v1/tasks/{task-name})
	DMAPIDeleteTask(ctx echo.Context, taskName string, params DMAPIDeleteTaskParams) error
	// pause task
	// (POST /api/v1/tasks/{task-name}/pause)
	DMAPIPauseTask(ctx echo.Context, taskName string) error
	// resume task
	// (POST /api/v1/tasks/{task-name}/resume)
	DMAPIResumeTask(ctx echo.Context, taskName string) error
	// get task source schema list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas)
	DMAPIGetTaskSourceSchemaList(ctx echo.Context, taskName string, sourceName string) error
	// get task source table list
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name})
	DMAPIGetTaskSourceTableList(ctx echo.Context, taskName string, sourceName string, schemaName string) error
	// delete task source table structure
	// (DELETE /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIDeleteTableStructure(ctx echo.Context, taskName string, sourceName string, schemaName string, tableName string) error
	// get task source table structure
	// (GET /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIGetTableStructure(ctx echo.Context, taskName string, sourceName string, schemaName string, tableName string) error
	// operate task source table structure
	// (PUT /api/v1/tasks/{task-name}/sources/{source-name}/schemas/{schema-name}/{table-name})
	DMAPIOperateTableStructure(ctx echo.Context, taskName string, sourceName string, schemaName string, tableName string) error
	// get task status
	// (GET /api/v1/tasks/{task-name}/status)
	DMAPIGetTaskStatus(ctx echo.Context, taskName string, params DMAPIGetTaskStatusParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DMAPIGetClusterMasterList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetClusterMasterList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetClusterMasterList(ctx)
	return err
}

// DMAPIOfflineMasterNode converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIOfflineMasterNode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "master-name" -------------
	var masterName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "master-name", runtime.ParamLocationPath, ctx.Param("master-name"), &masterName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter master-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIOfflineMasterNode(ctx, masterName)
	return err
}

// DMAPIGetClusterWorkerList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetClusterWorkerList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetClusterWorkerList(ctx)
	return err
}

// DMAPIOfflineWorkerNode converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIOfflineWorkerNode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker-name" -------------
	var workerName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "worker-name", runtime.ParamLocationPath, ctx.Param("worker-name"), &workerName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIOfflineWorkerNode(ctx, workerName)
	return err
}

// GetDocJSON converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocJSON(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocJSON(ctx)
	return err
}

// GetDocHTML converts echo context to params.
func (w *ServerInterfaceWrapper) GetDocHTML(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDocHTML(ctx)
	return err
}

// DMAPIGetSourceList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceList(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetSourceListParams
	// ------------- Optional query parameter "with_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "with_status", ctx.QueryParams(), &params.WithStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter with_status: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceList(ctx, params)
	return err
}

// DMAPICreateSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPICreateSource(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPICreateSource(ctx)
	return err
}

// DMAPIDeleteSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteSourceParams
	// ------------- Optional query parameter "force" -------------

	err = runtime.BindQueryParameter("form", true, false, "force", ctx.QueryParams(), &params.Force)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter force: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteSource(ctx, sourceName, params)
	return err
}

// DMAPIPauseRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIPauseRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIPauseRelay(ctx, sourceName)
	return err
}

// DMAPIResumeRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIResumeRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIResumeRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceSchemaList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceSchemaList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceSchemaList(ctx, sourceName)
	return err
}

// DMAPIGetSourceTableList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceTableList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceTableList(ctx, sourceName, schemaName)
	return err
}

// DMAPIStartRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartRelay(ctx, sourceName)
	return err
}

// DMAPIGetSourceStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetSourceStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetSourceStatus(ctx, sourceName)
	return err
}

// DMAPIStopRelay converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStopRelay(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStopRelay(ctx, sourceName)
	return err
}

// DMAPITransferSource converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPITransferSource(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPITransferSource(ctx, sourceName)
	return err
}

// DMAPIGetTaskList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskList(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskList(ctx)
	return err
}

// DMAPIStartTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIStartTask(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIStartTask(ctx)
	return err
}

// DMAPIDeleteTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIDeleteTaskParams
	// ------------- Optional query parameter "source_name_list" -------------

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", ctx.QueryParams(), &params.SourceNameList)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_name_list: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTask(ctx, taskName, params)
	return err
}

// DMAPIPauseTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIPauseTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIPauseTask(ctx, taskName)
	return err
}

// DMAPIResumeTask converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIResumeTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIResumeTask(ctx, taskName)
	return err
}

// DMAPIGetTaskSourceSchemaList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskSourceSchemaList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskSourceSchemaList(ctx, taskName, sourceName)
	return err
}

// DMAPIGetTaskSourceTableList converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskSourceTableList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskSourceTableList(ctx, taskName, sourceName, schemaName)
	return err
}

// DMAPIDeleteTableStructure converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIDeleteTableStructure(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table-name", runtime.ParamLocationPath, ctx.Param("table-name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIDeleteTableStructure(ctx, taskName, sourceName, schemaName, tableName)
	return err
}

// DMAPIGetTableStructure converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTableStructure(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table-name", runtime.ParamLocationPath, ctx.Param("table-name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTableStructure(ctx, taskName, sourceName, schemaName, tableName)
	return err
}

// DMAPIOperateTableStructure converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIOperateTableStructure(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// ------------- Path parameter "source-name" -------------
	var sourceName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "source-name", runtime.ParamLocationPath, ctx.Param("source-name"), &sourceName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source-name: %s", err))
	}

	// ------------- Path parameter "schema-name" -------------
	var schemaName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema-name", runtime.ParamLocationPath, ctx.Param("schema-name"), &schemaName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema-name: %s", err))
	}

	// ------------- Path parameter "table-name" -------------
	var tableName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "table-name", runtime.ParamLocationPath, ctx.Param("table-name"), &tableName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter table-name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIOperateTableStructure(ctx, taskName, sourceName, schemaName, tableName)
	return err
}

// DMAPIGetTaskStatus converts echo context to params.
func (w *ServerInterfaceWrapper) DMAPIGetTaskStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task-name" -------------
	var taskName string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task-name", runtime.ParamLocationPath, ctx.Param("task-name"), &taskName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task-name: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DMAPIGetTaskStatusParams
	// ------------- Optional query parameter "source_name_list" -------------

	err = runtime.BindQueryParameter("form", true, false, "source_name_list", ctx.QueryParams(), &params.SourceNameList)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_name_list: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DMAPIGetTaskStatus(ctx, taskName, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/cluster/masters", wrapper.DMAPIGetClusterMasterList)
	router.DELETE(baseURL+"/api/v1/cluster/masters/:master-name", wrapper.DMAPIOfflineMasterNode)
	router.GET(baseURL+"/api/v1/cluster/workers", wrapper.DMAPIGetClusterWorkerList)
	router.DELETE(baseURL+"/api/v1/cluster/workers/:worker-name", wrapper.DMAPIOfflineWorkerNode)
	router.GET(baseURL+"/api/v1/dm.json", wrapper.GetDocJSON)
	router.GET(baseURL+"/api/v1/docs", wrapper.GetDocHTML)
	router.GET(baseURL+"/api/v1/sources", wrapper.DMAPIGetSourceList)
	router.POST(baseURL+"/api/v1/sources", wrapper.DMAPICreateSource)
	router.DELETE(baseURL+"/api/v1/sources/:source-name", wrapper.DMAPIDeleteSource)
	router.POST(baseURL+"/api/v1/sources/:source-name/pause-relay", wrapper.DMAPIPauseRelay)
	router.POST(baseURL+"/api/v1/sources/:source-name/resume-relay", wrapper.DMAPIResumeRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/schemas", wrapper.DMAPIGetSourceSchemaList)
	router.GET(baseURL+"/api/v1/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetSourceTableList)
	router.POST(baseURL+"/api/v1/sources/:source-name/start-relay", wrapper.DMAPIStartRelay)
	router.GET(baseURL+"/api/v1/sources/:source-name/status", wrapper.DMAPIGetSourceStatus)
	router.POST(baseURL+"/api/v1/sources/:source-name/stop-relay", wrapper.DMAPIStopRelay)
	router.POST(baseURL+"/api/v1/sources/:source-name/transfer", wrapper.DMAPITransferSource)
	router.GET(baseURL+"/api/v1/tasks", wrapper.DMAPIGetTaskList)
	router.POST(baseURL+"/api/v1/tasks", wrapper.DMAPIStartTask)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name", wrapper.DMAPIDeleteTask)
	router.POST(baseURL+"/api/v1/tasks/:task-name/pause", wrapper.DMAPIPauseTask)
	router.POST(baseURL+"/api/v1/tasks/:task-name/resume", wrapper.DMAPIResumeTask)
	router.GET(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas", wrapper.DMAPIGetTaskSourceSchemaList)
	router.GET(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name", wrapper.DMAPIGetTaskSourceTableList)
	router.DELETE(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIDeleteTableStructure)
	router.GET(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIGetTableStructure)
	router.PUT(baseURL+"/api/v1/tasks/:task-name/sources/:source-name/schemas/:schema-name/:table-name", wrapper.DMAPIOperateTableStructure)
	router.GET(baseURL+"/api/v1/tasks/:task-name/status", wrapper.DMAPIGetTaskStatus)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+w923LbOJa/gtXuQ3eXZEm24yTemgfHdme8azspW129U11ZBQIhCWMQoAHQbk3K/z6F",
	"C0mQBCnKl8TuZB6mHRLAOTj3C0B96SEeJ5xhpmRv/0tPoiWOofnzkKZSYXEG9f/rB4ngCRaKYPMaRpF5",
	"GmGJBEkU4ay3b55iKQGfA7XEAKVCYKZAbBYBjEe41+/hP2GcUNzb7423X2+NtkZb4/0323vjXr+nVol+",
	"LpUgbNG76/cgJTe4DoczShgGUkGVOmhEOjA+BCVSnK8645xiyPSyFMMIB/An0l/J7MEN7bAog7FBtdif",
	"XSawsbt+T+DrlAgc9fb/sDOzzebY9S2RP+Wz+eyfGCkNyjHndy6uviFzZjxl0VTyVCA8zXZfhmmGADsE",
	"6CE5s24N7nWw8Upe08GoDaCCi2ZQ+uVaIGZsCEKdh3aJ7jzUpC9jGiJUkKkCQ4UnUF5d4OsUS1VnrMAx",
	"v8HTGCtoCTCHKVW9/TmkEvcrBLldYrXUUsyBnQf0PBBBBWdQYkAYiPgtk0pgGOePeyHR9lCfUmIx+y+B",
	"57393n8OCxMydPZjeGnGn8MYn+rRd/2egvJq3Sy99Rpd/S27ZULEO8IUK2zhXmCZcCZxnX56evddaHyK",
	"PdwFoB4LwcXvRC3PsJRBqdTQof4bYD22169gZJ5OkRbQ2lzzDiArvA42YQovsNDA7dRYLppmxg6pdaJb",
	"LNT38QmR+T1WJcegSdNMbi1T+r9E4Viuo3bZ4RTUhkLAlfk3V5AaLlZIUdmOHde30Ns3YQ3o42/CGeYn",
	"3oSV9kfE3i74ddC+NL77URG3Sz41+toqPCLNrdF7epQfl97prFjza2A/gTOKL5VIkUpFi4G3CE6RcaVT",
	"eU3Lzvzw4vhgcgwmB+9Oj8FnNf4MfvpMos+AMPXTePwzOP8wAee/nZ6Cg98mH6Yn54cXx2fH55P+x4uT",
	"s4OLf4D/Pf6HnfEzGP4y+Y8/kFV3HE0Ji/Cfn8Dh6W+Xk+OL4yPwy/BncHz+/uT8+G8njPGjd+Do+NeD",
	"304n4PDvBxeXx5O/pWr+Jp7tgsMPp6cHk+Ps39MZYaHQxG2tHqFEs2CwpDTJAsPN8/XxjDc9W8ujaohV",
	"pxxGTiJqDqmI1CmHEUgZUTVXOCeMyCWOprOVck+4iKGy4rO3G3SCOi7QFKN84YlbQQXv/XShSBQclAi+",
	"0KFx8KUR0Q1wqtCxsqvyeh7o8lYCiIdI/sFEFzikIXkEWUkCkAlGFAc2MsHA8BYIN6HGFJrKZSnWtOlP",
	"edXfBVFYmrTCiqkGYJKMJUZXCSdMAamfQAWOzgCCzMoBUQDOdfYhsFRQKMIWZpoJ84KB6DWdIs4UZoG9",
	"yWsKVjwFt5Apb4elyD9gAcBnNC5MQKal2gz0wWe03fxqJ/zqAXr/30HFXzFU3+xvSQQzmvNEkZhIRRCQ",
	"SygiTUYtP9qqgluiljYbcqzhjK5AKnEEbpeYAehCU8ARSoXUaUHTmkdHpyAuhaM5aypS7/MpJLgfUxGK",
	"lgWmcAUoXwCkl00TkHBK0AogzuZkkdpQuh5E/5kQ4dxYJqajqoyaQTYUV8Qmojm4Xr+u1yylVKtGJeH3",
	"bI/+U9xYP5fD3dkb1UBPljrbsoO1YCZYEB4RBCldWRUBxCblBQGIBHZbUR+4xcENpCneBwaE5pPEiLNI",
	"3g97gWNI2FQmEOHSDsavqvifEUbiNAZzgTGIiLwCZpbB4f27+4APJVMXeu/rHYjPtLIY2EqG5w3KS6SJ",
	"S3XtADAnVLPF4m7FqrATP9k6xIywrZH+37gPxm9fv/05pKAluLmXKQN/Pzk5yiovGSIlgPgtHM/R9vYA",
	"o9GbwXiM3w5m2xANRtu72xCNx6PRaGd/PHj9ZvdtCAdDlXYULOGyso9G6PERQFCh5TRNpnFeN2wsSpix",
	"IE2shcq543nEuv23UCISWFlTNiICI8XFSps2gesqJRXXFsrf99ZQpjOzZMj2hmtNGRGtVJaWu0gZ05PX",
	"xVdlYQ0Kkb/dEIebiJ6hHTK8l8YH5FWNup5ZH2FKdaZG0i8ygvUhZyULuMQoFUSt6mCMZ3JlQSlp2b73",
	"Dd/mBNMI3BJKwQyDJYkizKzHWmCVRwr+QqVFwFzw2AwxlneurVzdLpUNCMJCTSGl/BZHU8TqaB/yOOYM",
	"nLtC5uXlKdBzyJwgaOO5nFhriSMlnSLYHM14C1tTlY30pS0os3phvZPGpX/1ltP7+Hh8BqwZHP7fq9Fb",
	"93d1a+uhXuFVM9DDAp7mSiLIjd7aFV5llhh4wNfAq4YbZVoGaFBHMKgdLtJ5L3iaBHLkiOaFw+6MnhMh",
	"1ZRyZL1MaIoO8XC02bIKigVWwaEp23zBWvpnVu8Xe65tJEfbAxgkqq0q1U2NfV4L5phJNgsf1rHGnUps",
	"nJoJsFJtNYyplNYQhHyuW7HuZZY8aBqtlXFtlHCvJKQZCZTylouoccV8QHnJnd1Xe8H1uGjGzrz01tnZ",
	"Ge2For8kC8Dbyjw2Stfy6Rny1rpQNq7cM2jE1pUXunV/rLOtK+BDCoOpDAUpDjv9soah4Fytt0fe3p04",
	"Ob45kJ5U9EsS36xALT7ba681+2w7atDNcftka4KXBz+hjsb6toT15ZLHWC21N78VPBQ2ZUGOzJFp47ef",
	"QzxMBgVOKEGwQRZtV7BhYZ3uuc6jCxTpCtj2pCuL5Kav2mccjDeULR+RoOwoKJShSoeSkKnBAOhC5qaS",
	"UIdUIy/mhNIekMe8900+GrLLhmyogfsZijr4KDrT7WhWksLt7rjkKYvzZr2toX1hQTwklVmLgScjnfqe",
	"tntV6nz6AlhbLix3POkudjxZK3XfZBOlNkctHKQcRh3tklcb904ZVLgO5VVmjerOr7slu0cSu8il31Ve",
	"PX+XhtNZG/113P7liqFi+6b6H96+fgUMJB8HUwHth+JcgSWnNziamjCVo6tpQ4m/1WBnx0SC9Auf82i2",
	"whm93T6DclWQo6XQpXcN0jTQKXGGza4b2OxMU4KwhaZKCIRfz71dErTMq0JEgmzyRslsrfTWsUgWsJYI",
	"MzVVSdcGkKuBTmd4SVjk1Z26zM2zpECnQb9r3VFpRPOObL8H32Rn7DrgZad0p4GnBwudubbx3A6osB0K",
	"DFI2yFbxWd+q1qV0eW1K6RPC32SJ6/1ulbEye4LMqOpBiE5eDusrVZNYhZTZNN4eWlBrasrWNW3iDlLV",
	"jWeTmZgTquknUord4UCiZ0H6sTR63SGFd4Sd8sWvZrELvVaoho/ZEjKEp/aA5jRrxy8hW+C1XUQvmbcp",
	"EZBporMmMOf2MKY79xlFFCQ0XRDW5Vym6aRaTMohWBQP3LGySnGyfirOYKAjrqy11tg4KBZtPFzY7PZ9",
	"gZBX4VyNs2mUmtxEBVZb8ltNvyVkka3xzSlBCkdmJybXTGOtjPwGi1tBbHfUnEz7FHLxWsGncfB0mubH",
	"LVyZSj7n2g5AhbVL8aAkWErXRez1e0VLMQzMulRbxe0ikTZLPbTj8xMPMVkIqHAu71Vqa7lyY4AZ0+9+",
	"UMfo+pmdXNGBSl1ug21MzIQjqOA7KHF2WLKB6hnmrg2bEXqeUqo3wpDAMWb2UA2k5qBGIVTQDOoU3xQo",
	"rFHqikBW9x/kSpXXYbMaMDmhSrbCRin1whJAlXX3KL7BtGYSyYJxga0TCtQn9OMs/MyFomVMibQgimkX",
	"C+5wcIeT6kcYEqgUFiYzsqa7GZmm4QVe/38keLIeq7sGDvyaUurkXetZIIko9Vz4HGhJzPVLS1G9QoQ4",
	"k0QqzFCgM2TMCVOCU5BZGMJcuGKaPbYxzoU2anNzPjZfDUApU6FltcybVPEQCfRy4V6itvQ6KYqIqJvm",
	"rWEGf+qMam1lO2CqlgLDqHwuYbfqbQzB7ARNP8SZi8qCoR6JG1ce7wWXtjPWLt0kAScMic0kwDNCDQIg",
	"cEKnM6hQ+WTRuH5ywl9LR2pLwRn5Vw7KrAHwnxil5pHWh+sUMkUMqPCxh4R2JF91I/emYXN0mDv/1tiw",
	"KRQIxYaFU6wXLCqpSgFitDNHo+29ncH2G/R6MB7j1wO492pnsIdGsze70au3853R/njwerQ73t3e6Y9e",
	"7b7ejXaQN/zNzqvtwfZoJ5pt7+5F0U60Px6MX4+CtzjKZTnvVoZ54c5btMxMeJlCu8Hc7mlKvy3F2CYv",
	"VgpTGlAZCEyhtmjtB520QueuFDker4svqjb8zsYJG69TtQTlkK2RyNUddQ62PElel1r6eDSxoRa7NR8Q",
	"skGi4v79GD9klB1TrYo1Ni/NApnkBbRdv+6m7bK1r9pRovy8qCFt7YNbQiMERZTlY+WEZzb45YEVy1qT",
	"qqmSqWydOxzUd8BVBXFtbbA4AmWwQ9JVdOKb8sjHZEbEsQSMqzw5znYsK2wZ35OCHQGoWQfzuI54QdK3",
	"qHApU2oheJG4t1P8JXb6N2v036d1/0Rd8fY+eIjplSZOW+G+JYBqbq3WjWoBsbFx5TpUEmRKrbhr98q2",
	"rtW6tsM9WsHtzd87k4jo3BDSI44C6ePRGfiQYHbw8QQcfTjUPBG0t99bKpXI/eEw4khuJYQtEEy2EI+H",
	"/1oOFYlmA61cA+sQCWdDabXbxBVzborgRJmd1ADcYCEt7O2t8dbI1LMSzGBCevu9Ha1ZRiTU0mA7hAkZ",
	"3oyH7prN0FZhzStncPPrlSeRAXfw8SR0RdGUmO2dITN7ezRyiWh2Vg0mtoKh9/NPaY9pFea4TXFar0Qa",
	"JlTUKEVIW5W7fm/3EdGoXUUNgJ5DQnFkxEimcQzFqrevKQkcgf274Jk+KbiQWtbckN4nPbuBMcMv9g/j",
	"v++svFFsy5QBTn2Yzylh2JLt3NaaEihgjC2X/6gVvzz0sghKP9cC08vqqz0Ph56vL7Y+XFCzyz39TzXB",
	"2Q0YxmfGUW7pWrnZ34mRmR3rqGHF/dmvo2GB+7ovTMO8LxJspGGOMcMvzjlspGHOqXXQMB+9Zg3zcPi+",
	"Naz8fYlWRkbxVoZcULPeY3XE0f9cfjhvUKUyWnqt/ER4XdwijoABV2AVcVTByMUELej8fXJ22gkdPXAN",
	"Oktly+NN6Njwcr3pKW69rxNmDdkFreaKSX5g0Yj0dYrFypNpopbTfERAhsPtxYD8PqrhC9zxDwipfwuC",
	"ZsedKiyoDilYkWVdJuOQTaS3nye5zE4uuij4HY9Wj7bf7PsD9Q06aGCmwd3VSD7+Cig8Nxtkb2MDhm99",
	"3obYWley4Rev0LLejfgfV1mrdJTPzL3GlJHrtHxBp9mjlOs+nTxK40nxu36t8sbteWWe2Do+pNKdOsxO",
	"VZo0zvUqQtbBrPBAu7D7aDIT/NjNCxBZK2QAPlRghwlMpa1wGuPTYrU+6pHmIOoLENxPXVztc2Oq4YV3",
	"NHmeMnuyNzu081BmCyzTuBu3L8zQH+x+QnZbbjwlv72PEHYIBO2F1i7h4BMwt/lOzZPGhZVLvC8kBc6u",
	"DdlmRlMM2lU8hl/sH0UI00FYTA/w+clKv6Xh0wC+2HtH8MF+0JNKaflg7MsSUtsPu7+MKihUJ49V3M96",
	"KQ7rCdK+2h21u3KnQyN79xKdpTvG/JTOMr9G0sVX5jc2n4+gtR62+SrFlcqX8V6IofI/4et/B/kxRIon",
	"HW2Xu+P3PZuuyjXHv4rlioh8atOlBGRy7r5f3SxlEzfsxZSfnkjU6icT/iqylglCHnxxAO23xmx/ZY10",
	"2brdOg+Yfbb1iRuVta/DBohgapDUfRj7+TiUHKuC3PZz2+19ARO9Tez9s6eQ+/pn0b9lf8B9o/yldAeg",
	"/SS+UPknNcucrarR8Is5bb5JW8CxfiOr7N95C5jjHIeOxrjphHwgsQ58KiVQ7q99796H+6Bvq7zMfndW",
	"uDfS5LoomwmTLdl3KdY/Z3n69JR9T79UcvdyOwH3kA1bU+5U2/8hHS9VOlzj4B7i8bA2QXGVpHur4Dn6",
	"qx89i28VFLc2Lh4swBs2Mgpx7tzM+E6l+UdX5VmqUbC18shapOfNKN4wj/F/QOGHTj0zneo3X1lrInkm",
	"AZ1p3vDDKC85ZatrnvREvFbnWeN6fmjIDw35Bn26ll+AerEOsFUNk7RJDfNf/PmhihsD/14U8fFLEGt/",
	"Z+qv0ooqfhRrA31tj1q7HdDwvjP7PdXSN6p7fQUv80LPghhpzaSnKp3mIwDiJpOm8h3vFU+3Ih5DwswN",
	"754mslug8fca2i+VRxw98Cb58Dol6GpgD9HZRtZA5j9NWhKrXsjYui8YfxUkHXr524Fyv+fpqV8AyeyK",
	"YD4ue3D36e7fAQAA//8YI0WYlX0AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
