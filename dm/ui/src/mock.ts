/**
 * This file is AUTO GENERATED by msw-auto-mock, you can also commit/edit it as you prefer.
 */
/* eslint-disable */
import { setupWorker, rest } from 'msw'
import faker from '@faker-js/faker'

faker.seed(1)

const MAX_ARRAY_LENGTH = 20

export const handlers = [
  rest.get('/api/v1/cluster/info', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          cluster_id: faker.datatype.number(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/cluster/masters', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            addr: faker.lorem.slug(),
            alive: faker.datatype.boolean(),
            leader: faker.datatype.boolean(),
            name: faker.lorem.slug(),
          })),
          total: faker.datatype.number(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.delete('/api/v1/cluster/masters/:masterName', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(204), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/cluster/workers', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            addr: faker.lorem.slug(),
            bound_source_name: faker.lorem.slug(),
            bound_stage: faker.lorem.slug(),
            name: faker.lorem.slug(),
          })),
          total: faker.datatype.number(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.delete('/api/v1/cluster/workers/:workerName', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(204), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/dm.json', (req, res, ctx) => {
    const resultArray = [[ctx.status(200), ctx.json(null)]]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/docs', (req, res, ctx) => {
    const resultArray = [[ctx.status(200), ctx.json(null)]]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/sources', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            enable_gtid: faker.datatype.boolean(),
            host: faker.lorem.slug(),
            password: faker.lorem.slug(),
            port: faker.datatype.number(),
            purge: {
              expires: faker.datatype.number(),
              interval: faker.datatype.number(),
              remain_space: faker.datatype.number(),
            },
            relay_config: {
              enable_relay: faker.datatype.boolean(),
              relay_binlog_gtid: faker.lorem.slug(),
              relay_binlog_name: faker.lorem.slug(),
              relay_dir: faker.lorem.slug(),
            },
            security: {
              cert_allowed_cn: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              ssl_ca_content: faker.lorem.slug(),
              ssl_cert_content: faker.lorem.slug(),
              ssl_key_content: faker.lorem.slug(),
            },
            source_name: faker.lorem.slug(),
            status_list: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              error_msg: faker.lorem.slug(),
              relay_status: {
                master_binlog: faker.lorem.slug(),
                master_binlog_gtid: faker.lorem.slug(),
                relay_binlog_gtid: faker.lorem.slug(),
                relay_catch_up_master: faker.datatype.boolean(),
                relay_dir: faker.lorem.slug(),
                stage: faker.lorem.slug(),
              },
              source_name: faker.lorem.slug(),
              worker_name: faker.lorem.slug(),
            })),
            user: faker.lorem.slug(),
          })),
          total: faker.datatype.number(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(201),
        ctx.json({
          enable_gtid: faker.datatype.boolean(),
          host: faker.lorem.slug(),
          password: faker.lorem.slug(),
          port: faker.datatype.number(),
          purge: {
            expires: faker.datatype.number(),
            interval: faker.datatype.number(),
            remain_space: faker.datatype.number(),
          },
          relay_config: {
            enable_relay: faker.datatype.boolean(),
            relay_binlog_gtid: faker.lorem.slug(),
            relay_binlog_name: faker.lorem.slug(),
            relay_dir: faker.lorem.slug(),
          },
          security: {
            cert_allowed_cn: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            ssl_ca_content: faker.lorem.slug(),
            ssl_cert_content: faker.lorem.slug(),
            ssl_key_content: faker.lorem.slug(),
          },
          source_name: faker.lorem.slug(),
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            error_msg: faker.lorem.slug(),
            relay_status: {
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              relay_binlog_gtid: faker.lorem.slug(),
              relay_catch_up_master: faker.datatype.boolean(),
              relay_dir: faker.lorem.slug(),
              stage: faker.lorem.slug(),
            },
            source_name: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          user: faker.lorem.slug(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.delete('/api/v1/sources/:sourceName', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(204), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/sources/:sourceName', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          enable_gtid: faker.datatype.boolean(),
          host: faker.lorem.slug(),
          password: faker.lorem.slug(),
          port: faker.datatype.number(),
          purge: {
            expires: faker.datatype.number(),
            interval: faker.datatype.number(),
            remain_space: faker.datatype.number(),
          },
          relay_config: {
            enable_relay: faker.datatype.boolean(),
            relay_binlog_gtid: faker.lorem.slug(),
            relay_binlog_name: faker.lorem.slug(),
            relay_dir: faker.lorem.slug(),
          },
          security: {
            cert_allowed_cn: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            ssl_ca_content: faker.lorem.slug(),
            ssl_cert_content: faker.lorem.slug(),
            ssl_key_content: faker.lorem.slug(),
          },
          source_name: faker.lorem.slug(),
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            error_msg: faker.lorem.slug(),
            relay_status: {
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              relay_binlog_gtid: faker.lorem.slug(),
              relay_catch_up_master: faker.datatype.boolean(),
              relay_dir: faker.lorem.slug(),
              stage: faker.lorem.slug(),
            },
            source_name: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          user: faker.lorem.slug(),
        }),
      ],
      [ctx.status(404), ctx.json(null)],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.put('/api/v1/sources/:sourceName', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          enable_gtid: faker.datatype.boolean(),
          host: faker.lorem.slug(),
          password: faker.lorem.slug(),
          port: faker.datatype.number(),
          purge: {
            expires: faker.datatype.number(),
            interval: faker.datatype.number(),
            remain_space: faker.datatype.number(),
          },
          relay_config: {
            enable_relay: faker.datatype.boolean(),
            relay_binlog_gtid: faker.lorem.slug(),
            relay_binlog_name: faker.lorem.slug(),
            relay_dir: faker.lorem.slug(),
          },
          security: {
            cert_allowed_cn: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            ssl_ca_content: faker.lorem.slug(),
            ssl_cert_content: faker.lorem.slug(),
            ssl_key_content: faker.lorem.slug(),
          },
          source_name: faker.lorem.slug(),
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            error_msg: faker.lorem.slug(),
            relay_status: {
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              relay_binlog_gtid: faker.lorem.slug(),
              relay_catch_up_master: faker.datatype.boolean(),
              relay_dir: faker.lorem.slug(),
              stage: faker.lorem.slug(),
            },
            source_name: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          user: faker.lorem.slug(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources/:sourceName/disable', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources/:sourceName/enable', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources/:sourceName/relay/disable', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources/:sourceName/relay/enable', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources/:sourceName/relay/purge', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/sources/:sourceName/schemas', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json(
          [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => faker.lorem.slug())
        ),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get(
    '/api/v1/sources/:sourceName/schemas/:schemaName',
    (req, res, ctx) => {
      const resultArray = [
        [
          ctx.status(200),
          ctx.json(
            [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug())
          ),
        ],
        [
          ctx.status(400),
          ctx.json({
            error_code: faker.datatype.number(),
            error_msg: faker.lorem.slug(),
          }),
        ],
      ]
      return res(...faker.random.arrayElement(resultArray))
    }
  ),
  rest.get('/api/v1/sources/:sourceName/status', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            error_msg: faker.lorem.slug(),
            relay_status: {
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              relay_binlog_gtid: faker.lorem.slug(),
              relay_catch_up_master: faker.datatype.boolean(),
              relay_dir: faker.lorem.slug(),
              stage: faker.lorem.slug(),
            },
            source_name: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          total: faker.datatype.number(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/sources/:sourceName/transfer', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/tasks', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [...new Array(5).keys()]
              .map(_ => ({
                [faker.lorem.word()]: {
                  ignore_event: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                  ignore_sql: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                },
              }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
            enhance_online_schema_change: faker.datatype.boolean(),
            meta_schema: faker.lorem.slug(),
            name: faker.lorem.slug(),
            on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
            shard_mode: faker.random.arrayElement([
              'pessimistic',
              'optimistic',
            ]),
            source_config: {
              full_migrate_conf: {
                consistency: faker.lorem.slug(),
                data_dir: faker.lorem.slug(),
                export_threads: faker.datatype.number(),
                import_threads: faker.datatype.number(),
              },
              incr_migrate_conf: {
                repl_batch: faker.datatype.number(),
                repl_threads: faker.datatype.number(),
              },
              source_conf: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                binlog_gtid: faker.lorem.slug(),
                binlog_name: faker.lorem.slug(),
                binlog_pos: faker.datatype.number(),
                source_name: faker.lorem.slug(),
              })),
            },
            status_list: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              dump_status: {
                completed_tables: faker.datatype.number(),
                estimate_total_rows: faker.datatype.number(),
                finished_bytes: faker.datatype.number(),
                finished_rows: faker.datatype.number(),
                total_tables: faker.datatype.number(),
              },
              error_msg: faker.lorem.slug(),
              load_status: {
                finished_bytes: faker.datatype.number(),
                meta_binlog: faker.lorem.slug(),
                meta_binlog_gtid: faker.lorem.slug(),
                progress: faker.lorem.slug(),
                total_bytes: faker.datatype.number(),
              },
              name: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              stage: faker.random.arrayElement([
                'Stopped',
                'Running',
                'Finished',
              ]),
              sync_status: {
                binlog_type: faker.lorem.slug(),
                blocking_ddls: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                master_binlog: faker.lorem.slug(),
                master_binlog_gtid: faker.lorem.slug(),
                recent_tps: faker.datatype.number(),
                seconds_behind_master: faker.datatype.number(),
                synced: faker.datatype.boolean(),
                syncer_binlog: faker.lorem.slug(),
                syncer_binlog_gtid: faker.lorem.slug(),
                total_events: faker.datatype.number(),
                total_tps: faker.datatype.number(),
                unresolved_groups: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => ({
                  ddl_list: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                  first_location: faker.lorem.slug(),
                  synced: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                  target: faker.lorem.slug(),
                  unsynced: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                })),
              },
              unit: faker.lorem.slug(),
              unresolved_ddl_lock_id: faker.lorem.slug(),
              worker_name: faker.lorem.slug(),
            })),
            table_migrate_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_filter_rule: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              source: {
                schema: faker.lorem.slug(),
                source_name: faker.lorem.slug(),
                table: faker.lorem.slug(),
              },
              target: {
                schema: faker.lorem.slug(),
                table: faker.lorem.slug(),
              },
            })),
            target_config: {
              host: faker.lorem.slug(),
              password: faker.lorem.slug(),
              port: faker.datatype.number(),
              security: {
                cert_allowed_cn: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ssl_ca_content: faker.lorem.slug(),
                ssl_cert_content: faker.lorem.slug(),
                ssl_key_content: faker.lorem.slug(),
              },
              user: faker.lorem.slug(),
            },
            task_mode: faker.random.arrayElement([
              'full',
              'incremental',
              'all',
            ]),
          })),
          total: faker.datatype.number(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/tasks', (req, res, ctx) => {
    const resultArray = [
      // [
      //   ctx.status(201),
      //   ctx.json({
      //     binlog_filter_rule: [...new Array(5).keys()]
      //       .map(_ => ({
      //         [faker.lorem.word()]: {
      //           ignore_event: [
      //             ...new Array(
      //               faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //             ).keys(),
      //           ].map(_ => faker.lorem.slug()),
      //           ignore_sql: [
      //             ...new Array(
      //               faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //             ).keys(),
      //           ].map(_ => faker.lorem.slug()),
      //         },
      //       }))
      //       .reduce((acc, next) => Object.assign(acc, next), {}),
      //     enhance_online_schema_change: faker.datatype.boolean(),
      //     meta_schema: faker.lorem.slug(),
      //     name: faker.lorem.slug(),
      //     on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
      //     shard_mode: faker.random.arrayElement(['pessimistic', 'optimistic']),
      //     source_config: {
      //       full_migrate_conf: {
      //         consistency: faker.lorem.slug(),
      //         data_dir: faker.lorem.slug(),
      //         export_threads: faker.datatype.number(),
      //         import_threads: faker.datatype.number(),
      //       },
      //       incr_migrate_conf: {
      //         repl_batch: faker.datatype.number(),
      //         repl_threads: faker.datatype.number(),
      //       },
      //       source_conf: [
      //         ...new Array(
      //           faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //         ).keys(),
      //       ].map(_ => ({
      //         binlog_gtid: faker.lorem.slug(),
      //         binlog_name: faker.lorem.slug(),
      //         binlog_pos: faker.datatype.number(),
      //         source_name: faker.lorem.slug(),
      //       })),
      //     },
      //     status_list: [
      //       ...new Array(
      //         faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //       ).keys(),
      //     ].map(_ => ({
      //       dump_status: {
      //         completed_tables: faker.datatype.number(),
      //         estimate_total_rows: faker.datatype.number(),
      //         finished_bytes: faker.datatype.number(),
      //         finished_rows: faker.datatype.number(),
      //         total_tables: faker.datatype.number(),
      //       },
      //       error_msg: faker.lorem.slug(),
      //       load_status: {
      //         finished_bytes: faker.datatype.number(),
      //         meta_binlog: faker.lorem.slug(),
      //         meta_binlog_gtid: faker.lorem.slug(),
      //         progress: faker.lorem.slug(),
      //         total_bytes: faker.datatype.number(),
      //       },
      //       name: faker.lorem.slug(),
      //       source_name: faker.lorem.slug(),
      //       stage: faker.random.arrayElement([
      //         'Stopped',
      //         'Running',
      //         'Finished',
      //       ]),
      //       sync_status: {
      //         binlog_type: faker.lorem.slug(),
      //         blocking_ddls: [
      //           ...new Array(
      //             faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //           ).keys(),
      //         ].map(_ => faker.lorem.slug()),
      //         master_binlog: faker.lorem.slug(),
      //         master_binlog_gtid: faker.lorem.slug(),
      //         recent_tps: faker.datatype.number(),
      //         seconds_behind_master: faker.datatype.number(),
      //         synced: faker.datatype.boolean(),
      //         syncer_binlog: faker.lorem.slug(),
      //         syncer_binlog_gtid: faker.lorem.slug(),
      //         total_events: faker.datatype.number(),
      //         total_tps: faker.datatype.number(),
      //         unresolved_groups: [
      //           ...new Array(
      //             faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //           ).keys(),
      //         ].map(_ => ({
      //           ddl_list: [
      //             ...new Array(
      //               faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //             ).keys(),
      //           ].map(_ => faker.lorem.slug()),
      //           first_location: faker.lorem.slug(),
      //           synced: [
      //             ...new Array(
      //               faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //             ).keys(),
      //           ].map(_ => faker.lorem.slug()),
      //           target: faker.lorem.slug(),
      //           unsynced: [
      //             ...new Array(
      //               faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //             ).keys(),
      //           ].map(_ => faker.lorem.slug()),
      //         })),
      //       },
      //       unit: faker.lorem.slug(),
      //       unresolved_ddl_lock_id: faker.lorem.slug(),
      //       worker_name: faker.lorem.slug(),
      //     })),
      //     table_migrate_rule: [
      //       ...new Array(
      //         faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //       ).keys(),
      //     ].map(_ => ({
      //       binlog_filter_rule: [
      //         ...new Array(
      //           faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //         ).keys(),
      //       ].map(_ => faker.lorem.slug()),
      //       source: {
      //         schema: faker.lorem.slug(),
      //         source_name: faker.lorem.slug(),
      //         table: faker.lorem.slug(),
      //       },
      //       target: {
      //         schema: faker.lorem.slug(),
      //         table: faker.lorem.slug(),
      //       },
      //     })),
      //     target_config: {
      //       host: faker.lorem.slug(),
      //       password: faker.lorem.slug(),
      //       port: faker.datatype.number(),
      //       security: {
      //         cert_allowed_cn: [
      //           ...new Array(
      //             faker.datatype.number({ max: MAX_ARRAY_LENGTH })
      //           ).keys(),
      //         ].map(_ => faker.lorem.slug()),
      //         ssl_ca_content: faker.lorem.slug(),
      //         ssl_cert_content: faker.lorem.slug(),
      //         ssl_key_content: faker.lorem.slug(),
      //       },
      //       user: faker.lorem.slug(),
      //     },
      //     task_mode: faker.random.arrayElement(['full', 'incremental', 'all']),
      //   }),
      // ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/tasks/templates', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [...new Array(5).keys()]
              .map(_ => ({
                [faker.lorem.word()]: {
                  ignore_event: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                  ignore_sql: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                },
              }))
              .reduce((acc, next) => Object.assign(acc, next), {}),
            enhance_online_schema_change: faker.datatype.boolean(),
            meta_schema: faker.lorem.slug(),
            name: faker.lorem.slug(),
            on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
            shard_mode: faker.random.arrayElement([
              'pessimistic',
              'optimistic',
            ]),
            source_config: {
              full_migrate_conf: {
                consistency: faker.lorem.slug(),
                data_dir: faker.lorem.slug(),
                export_threads: faker.datatype.number(),
                import_threads: faker.datatype.number(),
              },
              incr_migrate_conf: {
                repl_batch: faker.datatype.number(),
                repl_threads: faker.datatype.number(),
              },
              source_conf: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                binlog_gtid: faker.lorem.slug(),
                binlog_name: faker.lorem.slug(),
                binlog_pos: faker.datatype.number(),
                source_name: faker.lorem.slug(),
              })),
            },
            status_list: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              dump_status: {
                completed_tables: faker.datatype.number(),
                estimate_total_rows: faker.datatype.number(),
                finished_bytes: faker.datatype.number(),
                finished_rows: faker.datatype.number(),
                total_tables: faker.datatype.number(),
              },
              error_msg: faker.lorem.slug(),
              load_status: {
                finished_bytes: faker.datatype.number(),
                meta_binlog: faker.lorem.slug(),
                meta_binlog_gtid: faker.lorem.slug(),
                progress: faker.lorem.slug(),
                total_bytes: faker.datatype.number(),
              },
              name: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              stage: faker.random.arrayElement([
                'Stopped',
                'Running',
                'Finished',
              ]),
              sync_status: {
                binlog_type: faker.lorem.slug(),
                blocking_ddls: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                master_binlog: faker.lorem.slug(),
                master_binlog_gtid: faker.lorem.slug(),
                recent_tps: faker.datatype.number(),
                seconds_behind_master: faker.datatype.number(),
                synced: faker.datatype.boolean(),
                syncer_binlog: faker.lorem.slug(),
                syncer_binlog_gtid: faker.lorem.slug(),
                total_events: faker.datatype.number(),
                total_tps: faker.datatype.number(),
                unresolved_groups: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => ({
                  ddl_list: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                  first_location: faker.lorem.slug(),
                  synced: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                  target: faker.lorem.slug(),
                  unsynced: [
                    ...new Array(
                      faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                    ).keys(),
                  ].map(_ => faker.lorem.slug()),
                })),
              },
              unit: faker.lorem.slug(),
              unresolved_ddl_lock_id: faker.lorem.slug(),
              worker_name: faker.lorem.slug(),
            })),
            table_migrate_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_filter_rule: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              source: {
                schema: faker.lorem.slug(),
                source_name: faker.lorem.slug(),
                table: faker.lorem.slug(),
              },
              target: {
                schema: faker.lorem.slug(),
                table: faker.lorem.slug(),
              },
            })),
            target_config: {
              host: faker.lorem.slug(),
              password: faker.lorem.slug(),
              port: faker.datatype.number(),
              security: {
                cert_allowed_cn: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ssl_ca_content: faker.lorem.slug(),
                ssl_cert_content: faker.lorem.slug(),
                ssl_key_content: faker.lorem.slug(),
              },
              user: faker.lorem.slug(),
            },
            task_mode: faker.random.arrayElement([
              'full',
              'incremental',
              'all',
            ]),
          })),
          total: faker.datatype.number(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/tasks/templates', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(201),
        ctx.json({
          binlog_filter_rule: [...new Array(5).keys()]
            .map(_ => ({
              [faker.lorem.word()]: {
                ignore_event: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ignore_sql: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              },
            }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          enhance_online_schema_change: faker.datatype.boolean(),
          meta_schema: faker.lorem.slug(),
          name: faker.lorem.slug(),
          on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
          shard_mode: faker.random.arrayElement(['pessimistic', 'optimistic']),
          source_config: {
            full_migrate_conf: {
              consistency: faker.lorem.slug(),
              data_dir: faker.lorem.slug(),
              export_threads: faker.datatype.number(),
              import_threads: faker.datatype.number(),
            },
            incr_migrate_conf: {
              repl_batch: faker.datatype.number(),
              repl_threads: faker.datatype.number(),
            },
            source_conf: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_gtid: faker.lorem.slug(),
              binlog_name: faker.lorem.slug(),
              binlog_pos: faker.datatype.number(),
              source_name: faker.lorem.slug(),
            })),
          },
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            dump_status: {
              completed_tables: faker.datatype.number(),
              estimate_total_rows: faker.datatype.number(),
              finished_bytes: faker.datatype.number(),
              finished_rows: faker.datatype.number(),
              total_tables: faker.datatype.number(),
            },
            error_msg: faker.lorem.slug(),
            load_status: {
              finished_bytes: faker.datatype.number(),
              meta_binlog: faker.lorem.slug(),
              meta_binlog_gtid: faker.lorem.slug(),
              progress: faker.lorem.slug(),
              total_bytes: faker.datatype.number(),
            },
            name: faker.lorem.slug(),
            source_name: faker.lorem.slug(),
            stage: faker.random.arrayElement([
              'Stopped',
              'Running',
              'Finished',
            ]),
            sync_status: {
              binlog_type: faker.lorem.slug(),
              blocking_ddls: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              recent_tps: faker.datatype.number(),
              seconds_behind_master: faker.datatype.number(),
              synced: faker.datatype.boolean(),
              syncer_binlog: faker.lorem.slug(),
              syncer_binlog_gtid: faker.lorem.slug(),
              total_events: faker.datatype.number(),
              total_tps: faker.datatype.number(),
              unresolved_groups: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                ddl_list: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                first_location: faker.lorem.slug(),
                synced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                target: faker.lorem.slug(),
                unsynced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              })),
            },
            unit: faker.lorem.slug(),
            unresolved_ddl_lock_id: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          table_migrate_rule: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            source: {
              schema: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
            target: {
              schema: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
          })),
          target_config: {
            host: faker.lorem.slug(),
            password: faker.lorem.slug(),
            port: faker.datatype.number(),
            security: {
              cert_allowed_cn: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              ssl_ca_content: faker.lorem.slug(),
              ssl_cert_content: faker.lorem.slug(),
              ssl_key_content: faker.lorem.slug(),
            },
            user: faker.lorem.slug(),
          },
          task_mode: faker.random.arrayElement(['full', 'incremental', 'all']),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/tasks/templates/import', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(202),
        ctx.json({
          failed_task_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            error_msg: faker.lorem.slug(),
            task_name: faker.lorem.slug(),
          })),
          success_task_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => faker.lorem.slug()),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.delete('/api/v1/tasks/templates/:taskName', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(204), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/tasks/templates/:taskName', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          binlog_filter_rule: [...new Array(5).keys()]
            .map(_ => ({
              [faker.lorem.word()]: {
                ignore_event: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ignore_sql: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              },
            }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          enhance_online_schema_change: faker.datatype.boolean(),
          meta_schema: faker.lorem.slug(),
          name: faker.lorem.slug(),
          on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
          shard_mode: faker.random.arrayElement(['pessimistic', 'optimistic']),
          source_config: {
            full_migrate_conf: {
              consistency: faker.lorem.slug(),
              data_dir: faker.lorem.slug(),
              export_threads: faker.datatype.number(),
              import_threads: faker.datatype.number(),
            },
            incr_migrate_conf: {
              repl_batch: faker.datatype.number(),
              repl_threads: faker.datatype.number(),
            },
            source_conf: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_gtid: faker.lorem.slug(),
              binlog_name: faker.lorem.slug(),
              binlog_pos: faker.datatype.number(),
              source_name: faker.lorem.slug(),
            })),
          },
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            dump_status: {
              completed_tables: faker.datatype.number(),
              estimate_total_rows: faker.datatype.number(),
              finished_bytes: faker.datatype.number(),
              finished_rows: faker.datatype.number(),
              total_tables: faker.datatype.number(),
            },
            error_msg: faker.lorem.slug(),
            load_status: {
              finished_bytes: faker.datatype.number(),
              meta_binlog: faker.lorem.slug(),
              meta_binlog_gtid: faker.lorem.slug(),
              progress: faker.lorem.slug(),
              total_bytes: faker.datatype.number(),
            },
            name: faker.lorem.slug(),
            source_name: faker.lorem.slug(),
            stage: faker.random.arrayElement([
              'Stopped',
              'Running',
              'Finished',
            ]),
            sync_status: {
              binlog_type: faker.lorem.slug(),
              blocking_ddls: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              recent_tps: faker.datatype.number(),
              seconds_behind_master: faker.datatype.number(),
              synced: faker.datatype.boolean(),
              syncer_binlog: faker.lorem.slug(),
              syncer_binlog_gtid: faker.lorem.slug(),
              total_events: faker.datatype.number(),
              total_tps: faker.datatype.number(),
              unresolved_groups: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                ddl_list: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                first_location: faker.lorem.slug(),
                synced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                target: faker.lorem.slug(),
                unsynced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              })),
            },
            unit: faker.lorem.slug(),
            unresolved_ddl_lock_id: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          table_migrate_rule: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            source: {
              schema: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
            target: {
              schema: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
          })),
          target_config: {
            host: faker.lorem.slug(),
            password: faker.lorem.slug(),
            port: faker.datatype.number(),
            security: {
              cert_allowed_cn: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              ssl_ca_content: faker.lorem.slug(),
              ssl_cert_content: faker.lorem.slug(),
              ssl_key_content: faker.lorem.slug(),
            },
            user: faker.lorem.slug(),
          },
          task_mode: faker.random.arrayElement(['full', 'incremental', 'all']),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.put('/api/v1/tasks/templates/:taskName', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          binlog_filter_rule: [...new Array(5).keys()]
            .map(_ => ({
              [faker.lorem.word()]: {
                ignore_event: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ignore_sql: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              },
            }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          enhance_online_schema_change: faker.datatype.boolean(),
          meta_schema: faker.lorem.slug(),
          name: faker.lorem.slug(),
          on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
          shard_mode: faker.random.arrayElement(['pessimistic', 'optimistic']),
          source_config: {
            full_migrate_conf: {
              consistency: faker.lorem.slug(),
              data_dir: faker.lorem.slug(),
              export_threads: faker.datatype.number(),
              import_threads: faker.datatype.number(),
            },
            incr_migrate_conf: {
              repl_batch: faker.datatype.number(),
              repl_threads: faker.datatype.number(),
            },
            source_conf: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_gtid: faker.lorem.slug(),
              binlog_name: faker.lorem.slug(),
              binlog_pos: faker.datatype.number(),
              source_name: faker.lorem.slug(),
            })),
          },
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            dump_status: {
              completed_tables: faker.datatype.number(),
              estimate_total_rows: faker.datatype.number(),
              finished_bytes: faker.datatype.number(),
              finished_rows: faker.datatype.number(),
              total_tables: faker.datatype.number(),
            },
            error_msg: faker.lorem.slug(),
            load_status: {
              finished_bytes: faker.datatype.number(),
              meta_binlog: faker.lorem.slug(),
              meta_binlog_gtid: faker.lorem.slug(),
              progress: faker.lorem.slug(),
              total_bytes: faker.datatype.number(),
            },
            name: faker.lorem.slug(),
            source_name: faker.lorem.slug(),
            stage: faker.random.arrayElement([
              'Stopped',
              'Running',
              'Finished',
            ]),
            sync_status: {
              binlog_type: faker.lorem.slug(),
              blocking_ddls: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              recent_tps: faker.datatype.number(),
              seconds_behind_master: faker.datatype.number(),
              synced: faker.datatype.boolean(),
              syncer_binlog: faker.lorem.slug(),
              syncer_binlog_gtid: faker.lorem.slug(),
              total_events: faker.datatype.number(),
              total_tps: faker.datatype.number(),
              unresolved_groups: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                ddl_list: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                first_location: faker.lorem.slug(),
                synced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                target: faker.lorem.slug(),
                unsynced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              })),
            },
            unit: faker.lorem.slug(),
            unresolved_ddl_lock_id: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          table_migrate_rule: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            source: {
              schema: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
            target: {
              schema: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
          })),
          target_config: {
            host: faker.lorem.slug(),
            password: faker.lorem.slug(),
            port: faker.datatype.number(),
            security: {
              cert_allowed_cn: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              ssl_ca_content: faker.lorem.slug(),
              ssl_cert_content: faker.lorem.slug(),
              ssl_key_content: faker.lorem.slug(),
            },
            user: faker.lorem.slug(),
          },
          task_mode: faker.random.arrayElement(['full', 'incremental', 'all']),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.delete('/api/v1/tasks/:taskName', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(204), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/tasks/:taskName', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          binlog_filter_rule: [...new Array(5).keys()]
            .map(_ => ({
              [faker.lorem.word()]: {
                ignore_event: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ignore_sql: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              },
            }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          enhance_online_schema_change: faker.datatype.boolean(),
          meta_schema: faker.lorem.slug(),
          name: faker.lorem.slug(),
          on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
          shard_mode: faker.random.arrayElement(['pessimistic', 'optimistic']),
          source_config: {
            full_migrate_conf: {
              consistency: faker.lorem.slug(),
              data_dir: faker.lorem.slug(),
              export_threads: faker.datatype.number(),
              import_threads: faker.datatype.number(),
            },
            incr_migrate_conf: {
              repl_batch: faker.datatype.number(),
              repl_threads: faker.datatype.number(),
            },
            source_conf: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_gtid: faker.lorem.slug(),
              binlog_name: faker.lorem.slug(),
              binlog_pos: faker.datatype.number(),
              source_name: faker.lorem.slug(),
            })),
          },
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            dump_status: {
              completed_tables: faker.datatype.number(),
              estimate_total_rows: faker.datatype.number(),
              finished_bytes: faker.datatype.number(),
              finished_rows: faker.datatype.number(),
              total_tables: faker.datatype.number(),
            },
            error_msg: faker.lorem.slug(),
            load_status: {
              finished_bytes: faker.datatype.number(),
              meta_binlog: faker.lorem.slug(),
              meta_binlog_gtid: faker.lorem.slug(),
              progress: faker.lorem.slug(),
              total_bytes: faker.datatype.number(),
            },
            name: faker.lorem.slug(),
            source_name: faker.lorem.slug(),
            stage: faker.random.arrayElement([
              'Stopped',
              'Running',
              'Finished',
            ]),
            sync_status: {
              binlog_type: faker.lorem.slug(),
              blocking_ddls: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              recent_tps: faker.datatype.number(),
              seconds_behind_master: faker.datatype.number(),
              synced: faker.datatype.boolean(),
              syncer_binlog: faker.lorem.slug(),
              syncer_binlog_gtid: faker.lorem.slug(),
              total_events: faker.datatype.number(),
              total_tps: faker.datatype.number(),
              unresolved_groups: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                ddl_list: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                first_location: faker.lorem.slug(),
                synced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                target: faker.lorem.slug(),
                unsynced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              })),
            },
            unit: faker.lorem.slug(),
            unresolved_ddl_lock_id: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          table_migrate_rule: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            source: {
              schema: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
            target: {
              schema: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
          })),
          target_config: {
            host: faker.lorem.slug(),
            password: faker.lorem.slug(),
            port: faker.datatype.number(),
            security: {
              cert_allowed_cn: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              ssl_ca_content: faker.lorem.slug(),
              ssl_cert_content: faker.lorem.slug(),
              ssl_key_content: faker.lorem.slug(),
            },
            user: faker.lorem.slug(),
          },
          task_mode: faker.random.arrayElement(['full', 'incremental', 'all']),
        }),
      ],
      [ctx.status(404), ctx.json(null)],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.put('/api/v1/tasks/:taskName', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          binlog_filter_rule: [...new Array(5).keys()]
            .map(_ => ({
              [faker.lorem.word()]: {
                ignore_event: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                ignore_sql: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              },
            }))
            .reduce((acc, next) => Object.assign(acc, next), {}),
          enhance_online_schema_change: faker.datatype.boolean(),
          meta_schema: faker.lorem.slug(),
          name: faker.lorem.slug(),
          on_duplicate: faker.random.arrayElement(['overwrite', 'error']),
          shard_mode: faker.random.arrayElement(['pessimistic', 'optimistic']),
          source_config: {
            full_migrate_conf: {
              consistency: faker.lorem.slug(),
              data_dir: faker.lorem.slug(),
              export_threads: faker.datatype.number(),
              import_threads: faker.datatype.number(),
            },
            incr_migrate_conf: {
              repl_batch: faker.datatype.number(),
              repl_threads: faker.datatype.number(),
            },
            source_conf: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => ({
              binlog_gtid: faker.lorem.slug(),
              binlog_name: faker.lorem.slug(),
              binlog_pos: faker.datatype.number(),
              source_name: faker.lorem.slug(),
            })),
          },
          status_list: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            dump_status: {
              completed_tables: faker.datatype.number(),
              estimate_total_rows: faker.datatype.number(),
              finished_bytes: faker.datatype.number(),
              finished_rows: faker.datatype.number(),
              total_tables: faker.datatype.number(),
            },
            error_msg: faker.lorem.slug(),
            load_status: {
              finished_bytes: faker.datatype.number(),
              meta_binlog: faker.lorem.slug(),
              meta_binlog_gtid: faker.lorem.slug(),
              progress: faker.lorem.slug(),
              total_bytes: faker.datatype.number(),
            },
            name: faker.lorem.slug(),
            source_name: faker.lorem.slug(),
            stage: faker.random.arrayElement([
              'Stopped',
              'Running',
              'Finished',
            ]),
            sync_status: {
              binlog_type: faker.lorem.slug(),
              blocking_ddls: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              recent_tps: faker.datatype.number(),
              seconds_behind_master: faker.datatype.number(),
              synced: faker.datatype.boolean(),
              syncer_binlog: faker.lorem.slug(),
              syncer_binlog_gtid: faker.lorem.slug(),
              total_events: faker.datatype.number(),
              total_tps: faker.datatype.number(),
              unresolved_groups: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                ddl_list: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                first_location: faker.lorem.slug(),
                synced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                target: faker.lorem.slug(),
                unsynced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              })),
            },
            unit: faker.lorem.slug(),
            unresolved_ddl_lock_id: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          table_migrate_rule: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            binlog_filter_rule: [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug()),
            source: {
              schema: faker.lorem.slug(),
              source_name: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
            target: {
              schema: faker.lorem.slug(),
              table: faker.lorem.slug(),
            },
          })),
          target_config: {
            host: faker.lorem.slug(),
            password: faker.lorem.slug(),
            port: faker.datatype.number(),
            security: {
              cert_allowed_cn: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              ssl_ca_content: faker.lorem.slug(),
              ssl_cert_content: faker.lorem.slug(),
              ssl_key_content: faker.lorem.slug(),
            },
            user: faker.lorem.slug(),
          },
          task_mode: faker.random.arrayElement(['full', 'incremental', 'all']),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get(
    '/api/v1/tasks/:taskName/sources/:sourceName/schemas',
    (req, res, ctx) => {
      const resultArray = [
        [
          ctx.status(200),
          ctx.json(
            [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug())
          ),
        ],
        [
          ctx.status(400),
          ctx.json({
            error_code: faker.datatype.number(),
            error_msg: faker.lorem.slug(),
          }),
        ],
      ]
      return res(...faker.random.arrayElement(resultArray))
    }
  ),
  rest.get(
    '/api/v1/tasks/:taskName/sources/:sourceName/schemas/:schemaName',
    (req, res, ctx) => {
      const resultArray = [
        [
          ctx.status(200),
          ctx.json(
            [
              ...new Array(
                faker.datatype.number({ max: MAX_ARRAY_LENGTH })
              ).keys(),
            ].map(_ => faker.lorem.slug())
          ),
        ],
        [
          ctx.status(400),
          ctx.json({
            error_code: faker.datatype.number(),
            error_msg: faker.lorem.slug(),
          }),
        ],
      ]
      return res(...faker.random.arrayElement(resultArray))
    }
  ),
  rest.delete(
    '/api/v1/tasks/:taskName/sources/:sourceName/schemas/:schemaName/:tableName',
    (req, res, ctx) => {
      const resultArray = [
        [ctx.status(204), ctx.json(null)],
        [
          ctx.status(400),
          ctx.json({
            error_code: faker.datatype.number(),
            error_msg: faker.lorem.slug(),
          }),
        ],
      ]
      return res(...faker.random.arrayElement(resultArray))
    }
  ),
  rest.get(
    '/api/v1/tasks/:taskName/sources/:sourceName/schemas/:schemaName/:tableName',
    (req, res, ctx) => {
      const resultArray = [
        [
          ctx.status(200),
          ctx.json({
            schema_create_sql: faker.lorem.slug(),
            schema_name: faker.lorem.slug(),
            table_name: faker.lorem.slug(),
          }),
        ],
        [
          ctx.status(400),
          ctx.json({
            error_code: faker.datatype.number(),
            error_msg: faker.lorem.slug(),
          }),
        ],
      ]
      return res(...faker.random.arrayElement(resultArray))
    }
  ),
  rest.put(
    '/api/v1/tasks/:taskName/sources/:sourceName/schemas/:schemaName/:tableName',
    (req, res, ctx) => {
      const resultArray = [
        [ctx.status(200), ctx.json(null)],
        [
          ctx.status(400),
          ctx.json({
            error_code: faker.datatype.number(),
            error_msg: faker.lorem.slug(),
          }),
        ],
      ]
      return res(...faker.random.arrayElement(resultArray))
    }
  ),
  rest.post('/api/v1/tasks/:taskName/start', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.get('/api/v1/tasks/:taskName/status', (req, res, ctx) => {
    const resultArray = [
      [
        ctx.status(200),
        ctx.json({
          data: [
            ...new Array(
              faker.datatype.number({ max: MAX_ARRAY_LENGTH })
            ).keys(),
          ].map(_ => ({
            dump_status: {
              completed_tables: faker.datatype.number(),
              estimate_total_rows: faker.datatype.number(),
              finished_bytes: faker.datatype.number(),
              finished_rows: faker.datatype.number(),
              total_tables: faker.datatype.number(),
            },
            error_msg: faker.lorem.slug(),
            load_status: {
              finished_bytes: faker.datatype.number(),
              meta_binlog: faker.lorem.slug(),
              meta_binlog_gtid: faker.lorem.slug(),
              progress: faker.lorem.slug(),
              total_bytes: faker.datatype.number(),
            },
            name: faker.lorem.slug(),
            source_name: faker.lorem.slug(),
            stage: faker.random.arrayElement([
              'Stopped',
              'Running',
              'Finished',
            ]),
            sync_status: {
              binlog_type: faker.lorem.slug(),
              blocking_ddls: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => faker.lorem.slug()),
              master_binlog: faker.lorem.slug(),
              master_binlog_gtid: faker.lorem.slug(),
              recent_tps: faker.datatype.number(),
              seconds_behind_master: faker.datatype.number(),
              synced: faker.datatype.boolean(),
              syncer_binlog: faker.lorem.slug(),
              syncer_binlog_gtid: faker.lorem.slug(),
              total_events: faker.datatype.number(),
              total_tps: faker.datatype.number(),
              unresolved_groups: [
                ...new Array(
                  faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                ).keys(),
              ].map(_ => ({
                ddl_list: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                first_location: faker.lorem.slug(),
                synced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
                target: faker.lorem.slug(),
                unsynced: [
                  ...new Array(
                    faker.datatype.number({ max: MAX_ARRAY_LENGTH })
                  ).keys(),
                ].map(_ => faker.lorem.slug()),
              })),
            },
            unit: faker.lorem.slug(),
            unresolved_ddl_lock_id: faker.lorem.slug(),
            worker_name: faker.lorem.slug(),
          })),
          total: faker.datatype.number(),
        }),
      ],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
  rest.post('/api/v1/tasks/:taskName/stop', (req, res, ctx) => {
    const resultArray = [
      [ctx.status(200), ctx.json(null)],
      [
        ctx.status(400),
        ctx.json({
          error_code: faker.datatype.number(),
          error_msg: faker.lorem.slug(),
        }),
      ],
    ]
    return res(...faker.random.arrayElement(resultArray))
  }),
]

// This configures a Service Worker with the given request handlers.
export const startWorker = () => {
  const worker = setupWorker(...handlers)
  worker.start()
}
