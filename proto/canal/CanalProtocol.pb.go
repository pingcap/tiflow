// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: CanalProtocol.proto

package com_alibaba_otter_canal_protocol

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Compression int32

const (
	Compression_COMPRESSIONCOMPATIBLEPROTO2 Compression = 0
	Compression_NONE                        Compression = 1
	Compression_ZLIB                        Compression = 2
	Compression_GZIP                        Compression = 3
	Compression_LZF                         Compression = 4
)

var Compression_name = map[int32]string{
	0: "COMPRESSIONCOMPATIBLEPROTO2",
	1: "NONE",
	2: "ZLIB",
	3: "GZIP",
	4: "LZF",
}

var Compression_value = map[string]int32{
	"COMPRESSIONCOMPATIBLEPROTO2": 0,
	"NONE":                        1,
	"ZLIB":                        2,
	"GZIP":                        3,
	"LZF":                         4,
}

func (x Compression) String() string {
	return proto.EnumName(Compression_name, int32(x))
}

func (Compression) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{0}
}

type PacketType int32

const (
	//compatible
	PacketType_PACKAGETYPECOMPATIBLEPROTO2 PacketType = 0
	PacketType_HANDSHAKE                   PacketType = 1
	PacketType_CLIENTAUTHENTICATION        PacketType = 2
	PacketType_ACK                         PacketType = 3
	PacketType_SUBSCRIPTION                PacketType = 4
	PacketType_UNSUBSCRIPTION              PacketType = 5
	PacketType_GET                         PacketType = 6
	PacketType_MESSAGES                    PacketType = 7
	PacketType_CLIENTACK                   PacketType = 8
	// management part
	PacketType_SHUTDOWN PacketType = 9
	// integration
	PacketType_DUMP           PacketType = 10
	PacketType_HEARTBEAT      PacketType = 11
	PacketType_CLIENTROLLBACK PacketType = 12
)

var PacketType_name = map[int32]string{
	0:  "PACKAGETYPECOMPATIBLEPROTO2",
	1:  "HANDSHAKE",
	2:  "CLIENTAUTHENTICATION",
	3:  "ACK",
	4:  "SUBSCRIPTION",
	5:  "UNSUBSCRIPTION",
	6:  "GET",
	7:  "MESSAGES",
	8:  "CLIENTACK",
	9:  "SHUTDOWN",
	10: "DUMP",
	11: "HEARTBEAT",
	12: "CLIENTROLLBACK",
}

var PacketType_value = map[string]int32{
	"PACKAGETYPECOMPATIBLEPROTO2": 0,
	"HANDSHAKE":                   1,
	"CLIENTAUTHENTICATION":        2,
	"ACK":                         3,
	"SUBSCRIPTION":                4,
	"UNSUBSCRIPTION":              5,
	"GET":                         6,
	"MESSAGES":                    7,
	"CLIENTACK":                   8,
	"SHUTDOWN":                    9,
	"DUMP":                        10,
	"HEARTBEAT":                   11,
	"CLIENTROLLBACK":              12,
}

func (x PacketType) String() string {
	return proto.EnumName(PacketType_name, int32(x))
}

func (PacketType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{1}
}

type Packet struct {
	//[default = 17];
	//
	// Types that are valid to be assigned to MagicNumberPresent:
	//	*Packet_MagicNumber
	MagicNumberPresent isPacket_MagicNumberPresent `protobuf_oneof:"magic_number_present"`
	//[default = 1];
	//
	// Types that are valid to be assigned to VersionPresent:
	//	*Packet_Version
	VersionPresent isPacket_VersionPresent `protobuf_oneof:"version_present"`
	Type           PacketType              `protobuf:"varint,3,opt,name=type,proto3,enum=com.alibaba.otter.canal.protocol.PacketType" json:"type,omitempty"`
	//[default = NONE];
	//
	// Types that are valid to be assigned to CompressionPresent:
	//	*Packet_Compression
	CompressionPresent   isPacket_CompressionPresent `protobuf_oneof:"compression_present"`
	Body                 []byte                      `protobuf:"bytes,5,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Packet) Reset()         { *m = Packet{} }
func (m *Packet) String() string { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()    {}
func (*Packet) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{0}
}
func (m *Packet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet.Merge(m, src)
}
func (m *Packet) XXX_Size() int {
	return m.Size()
}
func (m *Packet) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet.DiscardUnknown(m)
}

var xxx_messageInfo_Packet proto.InternalMessageInfo

type isPacket_MagicNumberPresent interface {
	isPacket_MagicNumberPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPacket_VersionPresent interface {
	isPacket_VersionPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPacket_CompressionPresent interface {
	isPacket_CompressionPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Packet_MagicNumber struct {
	MagicNumber int32 `protobuf:"varint,1,opt,name=magic_number,json=magicNumber,proto3,oneof" json:"magic_number,omitempty"`
}
type Packet_Version struct {
	Version int32 `protobuf:"varint,2,opt,name=version,proto3,oneof" json:"version,omitempty"`
}
type Packet_Compression struct {
	Compression Compression `protobuf:"varint,4,opt,name=compression,proto3,enum=com.alibaba.otter.canal.protocol.Compression,oneof" json:"compression,omitempty"`
}

func (*Packet_MagicNumber) isPacket_MagicNumberPresent() {}
func (*Packet_Version) isPacket_VersionPresent()         {}
func (*Packet_Compression) isPacket_CompressionPresent() {}

func (m *Packet) GetMagicNumberPresent() isPacket_MagicNumberPresent {
	if m != nil {
		return m.MagicNumberPresent
	}
	return nil
}
func (m *Packet) GetVersionPresent() isPacket_VersionPresent {
	if m != nil {
		return m.VersionPresent
	}
	return nil
}
func (m *Packet) GetCompressionPresent() isPacket_CompressionPresent {
	if m != nil {
		return m.CompressionPresent
	}
	return nil
}

func (m *Packet) GetMagicNumber() int32 {
	if x, ok := m.GetMagicNumberPresent().(*Packet_MagicNumber); ok {
		return x.MagicNumber
	}
	return 0
}

func (m *Packet) GetVersion() int32 {
	if x, ok := m.GetVersionPresent().(*Packet_Version); ok {
		return x.Version
	}
	return 0
}

func (m *Packet) GetType() PacketType {
	if m != nil {
		return m.Type
	}
	return PacketType_PACKAGETYPECOMPATIBLEPROTO2
}

func (m *Packet) GetCompression() Compression {
	if x, ok := m.GetCompressionPresent().(*Packet_Compression); ok {
		return x.Compression
	}
	return Compression_COMPRESSIONCOMPATIBLEPROTO2
}

func (m *Packet) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Packet) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Packet_MagicNumber)(nil),
		(*Packet_Version)(nil),
		(*Packet_Compression)(nil),
	}
}

type HeartBeat struct {
	SendTimestamp        int64    `protobuf:"varint,1,opt,name=send_timestamp,json=sendTimestamp,proto3" json:"send_timestamp,omitempty"`
	StartTimestamp       int64    `protobuf:"varint,2,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartBeat) Reset()         { *m = HeartBeat{} }
func (m *HeartBeat) String() string { return proto.CompactTextString(m) }
func (*HeartBeat) ProtoMessage()    {}
func (*HeartBeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{1}
}
func (m *HeartBeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartBeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartBeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartBeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartBeat.Merge(m, src)
}
func (m *HeartBeat) XXX_Size() int {
	return m.Size()
}
func (m *HeartBeat) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartBeat.DiscardUnknown(m)
}

var xxx_messageInfo_HeartBeat proto.InternalMessageInfo

func (m *HeartBeat) GetSendTimestamp() int64 {
	if m != nil {
		return m.SendTimestamp
	}
	return 0
}

func (m *HeartBeat) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

type Handshake struct {
	//  [default = "utf8"];
	//
	// Types that are valid to be assigned to CommunicationEncodingPresent:
	//	*Handshake_CommunicationEncoding
	CommunicationEncodingPresent isHandshake_CommunicationEncodingPresent `protobuf_oneof:"communication_encoding_present"`
	Seeds                        []byte                                   `protobuf:"bytes,2,opt,name=seeds,proto3" json:"seeds,omitempty"`
	SupportedCompressions        Compression                              `protobuf:"varint,3,opt,name=supported_compressions,json=supportedCompressions,proto3,enum=com.alibaba.otter.canal.protocol.Compression" json:"supported_compressions,omitempty"`
	XXX_NoUnkeyedLiteral         struct{}                                 `json:"-"`
	XXX_unrecognized             []byte                                   `json:"-"`
	XXX_sizecache                int32                                    `json:"-"`
}

func (m *Handshake) Reset()         { *m = Handshake{} }
func (m *Handshake) String() string { return proto.CompactTextString(m) }
func (*Handshake) ProtoMessage()    {}
func (*Handshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{2}
}
func (m *Handshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Handshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Handshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Handshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Handshake.Merge(m, src)
}
func (m *Handshake) XXX_Size() int {
	return m.Size()
}
func (m *Handshake) XXX_DiscardUnknown() {
	xxx_messageInfo_Handshake.DiscardUnknown(m)
}

var xxx_messageInfo_Handshake proto.InternalMessageInfo

type isHandshake_CommunicationEncodingPresent interface {
	isHandshake_CommunicationEncodingPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Handshake_CommunicationEncoding struct {
	CommunicationEncoding string `protobuf:"bytes,1,opt,name=communication_encoding,json=communicationEncoding,proto3,oneof" json:"communication_encoding,omitempty"`
}

func (*Handshake_CommunicationEncoding) isHandshake_CommunicationEncodingPresent() {}

func (m *Handshake) GetCommunicationEncodingPresent() isHandshake_CommunicationEncodingPresent {
	if m != nil {
		return m.CommunicationEncodingPresent
	}
	return nil
}

func (m *Handshake) GetCommunicationEncoding() string {
	if x, ok := m.GetCommunicationEncodingPresent().(*Handshake_CommunicationEncoding); ok {
		return x.CommunicationEncoding
	}
	return ""
}

func (m *Handshake) GetSeeds() []byte {
	if m != nil {
		return m.Seeds
	}
	return nil
}

func (m *Handshake) GetSupportedCompressions() Compression {
	if m != nil {
		return m.SupportedCompressions
	}
	return Compression_COMPRESSIONCOMPATIBLEPROTO2
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Handshake) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Handshake_CommunicationEncoding)(nil),
	}
}

// client authentication
type ClientAuth struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password []byte `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// [default = 0]
	//
	// Types that are valid to be assigned to NetReadTimeoutPresent:
	//	*ClientAuth_NetReadTimeout
	NetReadTimeoutPresent isClientAuth_NetReadTimeoutPresent `protobuf_oneof:"net_read_timeout_present"`
	// [default = 0];
	//
	// Types that are valid to be assigned to NetWriteTimeoutPresent:
	//	*ClientAuth_NetWriteTimeout
	NetWriteTimeoutPresent isClientAuth_NetWriteTimeoutPresent `protobuf_oneof:"net_write_timeout_present"`
	Destination            string                              `protobuf:"bytes,5,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId               string                              `protobuf:"bytes,6,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Filter                 string                              `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter,omitempty"`
	StartTimestamp         int64                               `protobuf:"varint,8,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                            `json:"-"`
	XXX_unrecognized       []byte                              `json:"-"`
	XXX_sizecache          int32                               `json:"-"`
}

func (m *ClientAuth) Reset()         { *m = ClientAuth{} }
func (m *ClientAuth) String() string { return proto.CompactTextString(m) }
func (*ClientAuth) ProtoMessage()    {}
func (*ClientAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{3}
}
func (m *ClientAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientAuth.Merge(m, src)
}
func (m *ClientAuth) XXX_Size() int {
	return m.Size()
}
func (m *ClientAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientAuth.DiscardUnknown(m)
}

var xxx_messageInfo_ClientAuth proto.InternalMessageInfo

type isClientAuth_NetReadTimeoutPresent interface {
	isClientAuth_NetReadTimeoutPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isClientAuth_NetWriteTimeoutPresent interface {
	isClientAuth_NetWriteTimeoutPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientAuth_NetReadTimeout struct {
	NetReadTimeout int32 `protobuf:"varint,3,opt,name=net_read_timeout,json=netReadTimeout,proto3,oneof" json:"net_read_timeout,omitempty"`
}
type ClientAuth_NetWriteTimeout struct {
	NetWriteTimeout int32 `protobuf:"varint,4,opt,name=net_write_timeout,json=netWriteTimeout,proto3,oneof" json:"net_write_timeout,omitempty"`
}

func (*ClientAuth_NetReadTimeout) isClientAuth_NetReadTimeoutPresent()   {}
func (*ClientAuth_NetWriteTimeout) isClientAuth_NetWriteTimeoutPresent() {}

func (m *ClientAuth) GetNetReadTimeoutPresent() isClientAuth_NetReadTimeoutPresent {
	if m != nil {
		return m.NetReadTimeoutPresent
	}
	return nil
}
func (m *ClientAuth) GetNetWriteTimeoutPresent() isClientAuth_NetWriteTimeoutPresent {
	if m != nil {
		return m.NetWriteTimeoutPresent
	}
	return nil
}

func (m *ClientAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ClientAuth) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *ClientAuth) GetNetReadTimeout() int32 {
	if x, ok := m.GetNetReadTimeoutPresent().(*ClientAuth_NetReadTimeout); ok {
		return x.NetReadTimeout
	}
	return 0
}

func (m *ClientAuth) GetNetWriteTimeout() int32 {
	if x, ok := m.GetNetWriteTimeoutPresent().(*ClientAuth_NetWriteTimeout); ok {
		return x.NetWriteTimeout
	}
	return 0
}

func (m *ClientAuth) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ClientAuth) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientAuth) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

func (m *ClientAuth) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientAuth) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientAuth_NetReadTimeout)(nil),
		(*ClientAuth_NetWriteTimeout)(nil),
	}
}

type Ack struct {
	//[default = 0]
	//
	// Types that are valid to be assigned to ErrorCodePresent:
	//	*Ack_ErrorCode
	ErrorCodePresent     isAck_ErrorCodePresent `protobuf_oneof:"error_code_present"`
	ErrorMessage         string                 `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{4}
}
func (m *Ack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return m.Size()
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

type isAck_ErrorCodePresent interface {
	isAck_ErrorCodePresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Ack_ErrorCode struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,oneof" json:"error_code,omitempty"`
}

func (*Ack_ErrorCode) isAck_ErrorCodePresent() {}

func (m *Ack) GetErrorCodePresent() isAck_ErrorCodePresent {
	if m != nil {
		return m.ErrorCodePresent
	}
	return nil
}

func (m *Ack) GetErrorCode() int32 {
	if x, ok := m.GetErrorCodePresent().(*Ack_ErrorCode); ok {
		return x.ErrorCode
	}
	return 0
}

func (m *Ack) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Ack) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Ack_ErrorCode)(nil),
	}
}

type ClientAck struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	BatchId              int64    `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientAck) Reset()         { *m = ClientAck{} }
func (m *ClientAck) String() string { return proto.CompactTextString(m) }
func (*ClientAck) ProtoMessage()    {}
func (*ClientAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{5}
}
func (m *ClientAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientAck.Merge(m, src)
}
func (m *ClientAck) XXX_Size() int {
	return m.Size()
}
func (m *ClientAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientAck.DiscardUnknown(m)
}

var xxx_messageInfo_ClientAck proto.InternalMessageInfo

func (m *ClientAck) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ClientAck) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientAck) GetBatchId() int64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

// subscription
type Sub struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Filter               string   `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Sub) Reset()         { *m = Sub{} }
func (m *Sub) String() string { return proto.CompactTextString(m) }
func (*Sub) ProtoMessage()    {}
func (*Sub) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{6}
}
func (m *Sub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub.Merge(m, src)
}
func (m *Sub) XXX_Size() int {
	return m.Size()
}
func (m *Sub) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub.DiscardUnknown(m)
}

var xxx_messageInfo_Sub proto.InternalMessageInfo

func (m *Sub) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Sub) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Sub) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Unsubscription
type Unsub struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Filter               string   `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Unsub) Reset()         { *m = Unsub{} }
func (m *Unsub) String() string { return proto.CompactTextString(m) }
func (*Unsub) ProtoMessage()    {}
func (*Unsub) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{7}
}
func (m *Unsub) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Unsub) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Unsub.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Unsub) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Unsub.Merge(m, src)
}
func (m *Unsub) XXX_Size() int {
	return m.Size()
}
func (m *Unsub) XXX_DiscardUnknown() {
	xxx_messageInfo_Unsub.DiscardUnknown(m)
}

var xxx_messageInfo_Unsub proto.InternalMessageInfo

func (m *Unsub) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Unsub) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Unsub) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

//  PullRequest
type Get struct {
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId    string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FetchSize   int32  `protobuf:"varint,3,opt,name=fetch_size,json=fetchSize,proto3" json:"fetch_size,omitempty"`
	//[default = -1]
	//
	// Types that are valid to be assigned to TimeoutPresent:
	//	*Get_Timeout
	TimeoutPresent isGet_TimeoutPresent `protobuf_oneof:"timeout_present"`
	//[default = 2]
	//
	// Types that are valid to be assigned to UnitPresent:
	//	*Get_Unit
	UnitPresent isGet_UnitPresent `protobuf_oneof:"unit_present"`
	//[default = false]
	//
	// Types that are valid to be assigned to AutoAckPresent:
	//	*Get_AutoAck
	AutoAckPresent       isGet_AutoAckPresent `protobuf_oneof:"auto_ack_present"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Get) Reset()         { *m = Get{} }
func (m *Get) String() string { return proto.CompactTextString(m) }
func (*Get) ProtoMessage()    {}
func (*Get) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{8}
}
func (m *Get) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Get) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Get.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Get) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Get.Merge(m, src)
}
func (m *Get) XXX_Size() int {
	return m.Size()
}
func (m *Get) XXX_DiscardUnknown() {
	xxx_messageInfo_Get.DiscardUnknown(m)
}

var xxx_messageInfo_Get proto.InternalMessageInfo

type isGet_TimeoutPresent interface {
	isGet_TimeoutPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGet_UnitPresent interface {
	isGet_UnitPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGet_AutoAckPresent interface {
	isGet_AutoAckPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Get_Timeout struct {
	Timeout int64 `protobuf:"varint,4,opt,name=timeout,proto3,oneof" json:"timeout,omitempty"`
}
type Get_Unit struct {
	Unit int32 `protobuf:"varint,5,opt,name=unit,proto3,oneof" json:"unit,omitempty"`
}
type Get_AutoAck struct {
	AutoAck bool `protobuf:"varint,6,opt,name=auto_ack,json=autoAck,proto3,oneof" json:"auto_ack,omitempty"`
}

func (*Get_Timeout) isGet_TimeoutPresent() {}
func (*Get_Unit) isGet_UnitPresent()       {}
func (*Get_AutoAck) isGet_AutoAckPresent() {}

func (m *Get) GetTimeoutPresent() isGet_TimeoutPresent {
	if m != nil {
		return m.TimeoutPresent
	}
	return nil
}
func (m *Get) GetUnitPresent() isGet_UnitPresent {
	if m != nil {
		return m.UnitPresent
	}
	return nil
}
func (m *Get) GetAutoAckPresent() isGet_AutoAckPresent {
	if m != nil {
		return m.AutoAckPresent
	}
	return nil
}

func (m *Get) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *Get) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Get) GetFetchSize() int32 {
	if m != nil {
		return m.FetchSize
	}
	return 0
}

func (m *Get) GetTimeout() int64 {
	if x, ok := m.GetTimeoutPresent().(*Get_Timeout); ok {
		return x.Timeout
	}
	return 0
}

func (m *Get) GetUnit() int32 {
	if x, ok := m.GetUnitPresent().(*Get_Unit); ok {
		return x.Unit
	}
	return 0
}

func (m *Get) GetAutoAck() bool {
	if x, ok := m.GetAutoAckPresent().(*Get_AutoAck); ok {
		return x.AutoAck
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Get) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Get_Timeout)(nil),
		(*Get_Unit)(nil),
		(*Get_AutoAck)(nil),
	}
}

//
type Messages struct {
	BatchId              int64    `protobuf:"varint,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	Messages             [][]byte `protobuf:"bytes,2,rep,name=messages,proto3" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Messages) Reset()         { *m = Messages{} }
func (m *Messages) String() string { return proto.CompactTextString(m) }
func (*Messages) ProtoMessage()    {}
func (*Messages) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{9}
}
func (m *Messages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Messages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Messages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Messages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Messages.Merge(m, src)
}
func (m *Messages) XXX_Size() int {
	return m.Size()
}
func (m *Messages) XXX_DiscardUnknown() {
	xxx_messageInfo_Messages.DiscardUnknown(m)
}

var xxx_messageInfo_Messages proto.InternalMessageInfo

func (m *Messages) GetBatchId() int64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func (m *Messages) GetMessages() [][]byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

// TBD when new packets are required
type Dump struct {
	Journal  string `protobuf:"bytes,1,opt,name=journal,proto3" json:"journal,omitempty"`
	Position int64  `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	// [default = 0]
	//
	// Types that are valid to be assigned to TimestampPresent:
	//	*Dump_Timestamp
	TimestampPresent     isDump_TimestampPresent `protobuf_oneof:"timestamp_present"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Dump) Reset()         { *m = Dump{} }
func (m *Dump) String() string { return proto.CompactTextString(m) }
func (*Dump) ProtoMessage()    {}
func (*Dump) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{10}
}
func (m *Dump) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dump) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dump.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dump) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dump.Merge(m, src)
}
func (m *Dump) XXX_Size() int {
	return m.Size()
}
func (m *Dump) XXX_DiscardUnknown() {
	xxx_messageInfo_Dump.DiscardUnknown(m)
}

var xxx_messageInfo_Dump proto.InternalMessageInfo

type isDump_TimestampPresent interface {
	isDump_TimestampPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Dump_Timestamp struct {
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp,proto3,oneof" json:"timestamp,omitempty"`
}

func (*Dump_Timestamp) isDump_TimestampPresent() {}

func (m *Dump) GetTimestampPresent() isDump_TimestampPresent {
	if m != nil {
		return m.TimestampPresent
	}
	return nil
}

func (m *Dump) GetJournal() string {
	if m != nil {
		return m.Journal
	}
	return ""
}

func (m *Dump) GetPosition() int64 {
	if m != nil {
		return m.Position
	}
	return 0
}

func (m *Dump) GetTimestamp() int64 {
	if x, ok := m.GetTimestampPresent().(*Dump_Timestamp); ok {
		return x.Timestamp
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Dump) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Dump_Timestamp)(nil),
	}
}

type ClientRollback struct {
	Destination          string   `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	ClientId             string   `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	BatchId              int64    `protobuf:"varint,3,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientRollback) Reset()         { *m = ClientRollback{} }
func (m *ClientRollback) String() string { return proto.CompactTextString(m) }
func (*ClientRollback) ProtoMessage()    {}
func (*ClientRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_638f57be23f1b015, []int{11}
}
func (m *ClientRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientRollback.Merge(m, src)
}
func (m *ClientRollback) XXX_Size() int {
	return m.Size()
}
func (m *ClientRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientRollback.DiscardUnknown(m)
}

var xxx_messageInfo_ClientRollback proto.InternalMessageInfo

func (m *ClientRollback) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *ClientRollback) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientRollback) GetBatchId() int64 {
	if m != nil {
		return m.BatchId
	}
	return 0
}

func init() {
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.Compression", Compression_name, Compression_value)
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.PacketType", PacketType_name, PacketType_value)
	proto.RegisterType((*Packet)(nil), "com.alibaba.otter.canal.protocol.Packet")
	proto.RegisterType((*HeartBeat)(nil), "com.alibaba.otter.canal.protocol.HeartBeat")
	proto.RegisterType((*Handshake)(nil), "com.alibaba.otter.canal.protocol.Handshake")
	proto.RegisterType((*ClientAuth)(nil), "com.alibaba.otter.canal.protocol.ClientAuth")
	proto.RegisterType((*Ack)(nil), "com.alibaba.otter.canal.protocol.Ack")
	proto.RegisterType((*ClientAck)(nil), "com.alibaba.otter.canal.protocol.ClientAck")
	proto.RegisterType((*Sub)(nil), "com.alibaba.otter.canal.protocol.Sub")
	proto.RegisterType((*Unsub)(nil), "com.alibaba.otter.canal.protocol.Unsub")
	proto.RegisterType((*Get)(nil), "com.alibaba.otter.canal.protocol.Get")
	proto.RegisterType((*Messages)(nil), "com.alibaba.otter.canal.protocol.Messages")
	proto.RegisterType((*Dump)(nil), "com.alibaba.otter.canal.protocol.Dump")
	proto.RegisterType((*ClientRollback)(nil), "com.alibaba.otter.canal.protocol.ClientRollback")
}

func init() { proto.RegisterFile("CanalProtocol.proto", fileDescriptor_638f57be23f1b015) }

var fileDescriptor_638f57be23f1b015 = []byte{
	// 1038 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x5f, 0x6f, 0xe3, 0x44,
	0x10, 0xaf, 0xe3, 0xa4, 0x89, 0x27, 0x69, 0xea, 0x6e, 0xff, 0x28, 0xd7, 0x8a, 0x5c, 0x94, 0x13,
	0xa2, 0xaa, 0x8e, 0x3c, 0x1c, 0x0f, 0xbc, 0x62, 0xa7, 0xa6, 0x8e, 0x9a, 0x26, 0x61, 0xe3, 0xe8,
	0x44, 0x41, 0x44, 0x1b, 0x7b, 0xaf, 0xf5, 0x25, 0xf6, 0x06, 0x7b, 0xcd, 0xa9, 0xf7, 0x49, 0xf8,
	0x20, 0x7c, 0x08, 0x1e, 0x79, 0xe3, 0x15, 0x15, 0x09, 0x89, 0x6f, 0x81, 0x76, 0xed, 0xb8, 0x69,
	0x29, 0xaa, 0xd0, 0xe9, 0xde, 0x76, 0x7e, 0x33, 0x3b, 0xb3, 0xf3, 0x9b, 0xdf, 0xae, 0x0d, 0xbb,
	0x5d, 0x12, 0x92, 0xc5, 0x28, 0x62, 0x9c, 0xb9, 0x6c, 0xd1, 0x59, 0x8a, 0x05, 0x6a, 0xb9, 0x2c,
	0xe8, 0x90, 0x85, 0x3f, 0x23, 0x33, 0xd2, 0x61, 0x9c, 0xd3, 0xa8, 0xe3, 0x8a, 0xb0, 0xd4, 0xed,
	0xb2, 0x45, 0xfb, 0x97, 0x02, 0x6c, 0x8e, 0x88, 0x3b, 0xa7, 0x1c, 0xbd, 0x80, 0x5a, 0x40, 0xae,
	0x7c, 0x77, 0x1a, 0x26, 0xc1, 0x8c, 0x46, 0x0d, 0xa5, 0xa5, 0x1c, 0x97, 0xec, 0x0d, 0x5c, 0x95,
	0xe8, 0x40, 0x82, 0xe8, 0x10, 0xca, 0x3f, 0xd1, 0x28, 0xf6, 0x59, 0xd8, 0x28, 0x48, 0xbf, 0x82,
	0x57, 0x00, 0xfa, 0x0a, 0x8a, 0xfc, 0x66, 0x49, 0x1b, 0x6a, 0x4b, 0x39, 0xae, 0xbf, 0x7a, 0xd9,
	0x79, 0xaa, 0x78, 0x27, 0x2d, 0xec, 0xdc, 0x2c, 0x29, 0x96, 0x3b, 0xd1, 0x37, 0x50, 0x75, 0x59,
	0xb0, 0x8c, 0x68, 0x2c, 0x2b, 0x14, 0x65, 0xa2, 0xcf, 0x9f, 0x4e, 0xd4, 0xbd, 0xdb, 0x64, 0x17,
	0xf0, 0x7a, 0x0e, 0x84, 0xa0, 0x38, 0x63, 0xde, 0x4d, 0xa3, 0xd4, 0x52, 0x8e, 0x6b, 0x58, 0xae,
	0xcd, 0x03, 0xd8, 0x5b, 0xef, 0x74, 0x2a, 0x82, 0x69, 0xc8, 0xcd, 0x1d, 0xd8, 0xce, 0x7a, 0xc9,
	0xa1, 0x7d, 0xd8, 0x5d, 0xcb, 0xb6, 0x82, 0xdb, 0xdf, 0x81, 0x66, 0x53, 0x12, 0x71, 0x93, 0x12,
	0x8e, 0x3e, 0x85, 0x7a, 0x4c, 0x43, 0x6f, 0xca, 0xfd, 0x80, 0xc6, 0x9c, 0x04, 0x4b, 0x49, 0x9d,
	0x8a, 0xb7, 0x04, 0xea, 0xac, 0x40, 0xf4, 0x19, 0x6c, 0xc7, 0x9c, 0x44, 0x7c, 0x2d, 0xae, 0x20,
	0xe3, 0xea, 0x12, 0xce, 0x03, 0xdb, 0xb7, 0x0a, 0x68, 0x36, 0x09, 0xbd, 0xf8, 0x9a, 0xcc, 0x29,
	0xfa, 0x12, 0x0e, 0x5c, 0x16, 0x04, 0x49, 0xe8, 0xbb, 0x84, 0x8b, 0x33, 0xd0, 0xd0, 0x65, 0x9e,
	0x1f, 0x5e, 0xc9, 0x2a, 0x9a, 0xbd, 0x81, 0xf7, 0xef, 0xf9, 0xad, 0xcc, 0x8d, 0xf6, 0xa0, 0x14,
	0x53, 0xea, 0xc5, 0xb2, 0x4a, 0x0d, 0xa7, 0x06, 0xf2, 0xe0, 0x20, 0x4e, 0x96, 0x4b, 0x16, 0x71,
	0xea, 0x4d, 0xd7, 0x5a, 0x8b, 0xb3, 0xb1, 0xfd, 0x3f, 0xb6, 0xf1, 0x7e, 0x9e, 0x6c, 0x0d, 0x8d,
	0xcd, 0x16, 0x34, 0x1f, 0x3f, 0x74, 0xce, 0xe0, 0xef, 0x05, 0x80, 0xee, 0xc2, 0xa7, 0x21, 0x37,
	0x12, 0x7e, 0x8d, 0x0e, 0xa1, 0x92, 0xc4, 0x34, 0x0a, 0x49, 0x40, 0xd3, 0xbe, 0x70, 0x6e, 0x0b,
	0xdf, 0x92, 0xc4, 0xf1, 0x3b, 0x16, 0x79, 0x59, 0x2f, 0xb9, 0x8d, 0x4e, 0x40, 0x0f, 0x29, 0x9f,
	0x46, 0x94, 0xa4, 0xfc, 0xb3, 0x84, 0xcb, 0x46, 0x84, 0x70, 0xeb, 0x21, 0xe5, 0x98, 0x12, 0x39,
	0x02, 0x96, 0x70, 0xf4, 0x12, 0x76, 0x44, 0xec, 0xbb, 0xc8, 0xe7, 0x34, 0x0f, 0x2e, 0x66, 0x2a,
	0xde, 0x0e, 0x29, 0x7f, 0x2d, 0x3c, 0xab, 0xe8, 0x16, 0x54, 0x3d, 0x1a, 0x73, 0x3f, 0x94, 0x0d,
	0x48, 0xfd, 0x68, 0x78, 0x1d, 0x42, 0x47, 0xa0, 0xb9, 0xb2, 0x83, 0xa9, 0xef, 0x35, 0x36, 0xd3,
	0x43, 0xa7, 0x40, 0xcf, 0x43, 0x07, 0xb0, 0xf9, 0xc6, 0x5f, 0x70, 0x1a, 0x35, 0xca, 0xd2, 0x93,
	0x59, 0x8f, 0xa9, 0xa0, 0xf2, 0x98, 0x0a, 0xcc, 0x43, 0x68, 0x3c, 0xec, 0x2c, 0x57, 0xe5, 0x11,
	0x3c, 0xfb, 0x57, 0x27, 0x39, 0xb3, 0x04, 0x54, 0xc3, 0x9d, 0xa3, 0xe7, 0x00, 0x34, 0x8a, 0x58,
	0x34, 0x75, 0x99, 0x47, 0xf3, 0xcb, 0xac, 0x49, 0xac, 0xcb, 0x3c, 0x8a, 0x5e, 0xc0, 0x56, 0x1a,
	0x10, 0xd0, 0x38, 0x26, 0x57, 0x54, 0x72, 0xab, 0xe1, 0x9a, 0x04, 0x2f, 0x52, 0xcc, 0xdc, 0x03,
	0x74, 0x97, 0x25, 0x2f, 0x41, 0x41, 0xcb, 0x66, 0xe7, 0xce, 0x1f, 0x12, 0xa5, 0x3c, 0x41, 0x54,
	0xe1, 0x01, 0x51, 0xcf, 0xa0, 0x32, 0x23, 0xdc, 0xbd, 0x16, 0x3e, 0x55, 0x32, 0x51, 0x96, 0x76,
	0xcf, 0x6b, 0x7f, 0x0f, 0xea, 0x38, 0x99, 0x7d, 0x68, 0x81, 0xff, 0x98, 0x44, 0xfb, 0x07, 0x28,
	0x4d, 0xc2, 0xf8, 0xe3, 0xe5, 0xff, 0x5b, 0x01, 0xf5, 0x8c, 0xf2, 0x0f, 0x4d, 0xff, 0x09, 0xc0,
	0x1b, 0x2a, 0xf8, 0x89, 0xfd, 0xf7, 0xe9, 0xdb, 0x5a, 0xc2, 0x9a, 0x44, 0xc6, 0xfe, 0x7b, 0x71,
	0x39, 0xca, 0xeb, 0x52, 0x56, 0xed, 0x0d, 0xbc, 0x02, 0xd0, 0x1e, 0x14, 0x93, 0xd0, 0xe7, 0x52,
	0xbb, 0x42, 0xe3, 0xd2, 0x42, 0x47, 0x50, 0x21, 0x09, 0x67, 0x53, 0xe2, 0xce, 0xa5, 0x6a, 0x2b,
	0x76, 0x01, 0x97, 0x05, 0x62, 0xb8, 0x73, 0xf1, 0x04, 0x3e, 0x14, 0x5b, 0x1d, 0x6a, 0x62, 0x5f,
	0x6e, 0x23, 0xd0, 0x57, 0xfb, 0x73, 0x41, 0x18, 0x50, 0xc9, 0x14, 0x13, 0xdf, 0x1b, 0xa8, 0x72,
	0x6f, 0xa0, 0xe2, 0x26, 0x67, 0x62, 0x13, 0xaf, 0x92, 0x2a, 0x6e, 0xf2, 0xca, 0x6e, 0xff, 0x08,
	0xc5, 0xd3, 0x24, 0x58, 0xa2, 0x06, 0x94, 0xdf, 0xb2, 0x24, 0x0a, 0xc9, 0x22, 0xa3, 0x6a, 0x65,
	0xca, 0x77, 0x80, 0xc5, 0x3e, 0x5f, 0x7d, 0x7c, 0x54, 0x9c, 0xdb, 0xa8, 0x09, 0xda, 0xdd, 0x85,
	0x52, 0x33, 0x22, 0xee, 0x20, 0x73, 0x17, 0x76, 0x72, 0x23, 0x3f, 0xf5, 0x5b, 0xa8, 0xa7, 0x32,
	0xc6, 0x6c, 0xb1, 0x98, 0x91, 0x8f, 0xa9, 0xe5, 0x93, 0x09, 0x54, 0xd7, 0x5e, 0x48, 0xf4, 0x1c,
	0x8e, 0xba, 0xc3, 0x8b, 0x11, 0xb6, 0xc6, 0xe3, 0xde, 0x70, 0x20, 0x96, 0x86, 0xd3, 0x33, 0xfb,
	0xd6, 0x08, 0x0f, 0x9d, 0xe1, 0x2b, 0x7d, 0x03, 0x55, 0xa0, 0x38, 0x18, 0x0e, 0x2c, 0x5d, 0x11,
	0xab, 0xcb, 0x7e, 0xcf, 0xd4, 0x0b, 0x62, 0x75, 0x76, 0xd9, 0x1b, 0xe9, 0x2a, 0x2a, 0x83, 0xda,
	0xbf, 0xfc, 0x5a, 0x2f, 0x9e, 0xfc, 0xa5, 0x00, 0xdc, 0x7d, 0x46, 0x45, 0xda, 0x91, 0xd1, 0x3d,
	0x37, 0xce, 0x2c, 0xe7, 0xdb, 0x91, 0xf5, 0x48, 0xda, 0x2d, 0xd0, 0x6c, 0x63, 0x70, 0x3a, 0xb6,
	0x8d, 0x73, 0x91, 0xbb, 0x01, 0x7b, 0xdd, 0x7e, 0xcf, 0x1a, 0x38, 0xc6, 0xc4, 0xb1, 0xad, 0x81,
	0xd3, 0xeb, 0x1a, 0x4e, 0x6f, 0x38, 0xd0, 0x0b, 0xa2, 0x82, 0xd1, 0x3d, 0xd7, 0x55, 0xa4, 0x43,
	0x6d, 0x3c, 0x31, 0xc7, 0x5d, 0xdc, 0x1b, 0x49, 0x57, 0x11, 0x21, 0xa8, 0x4f, 0x06, 0xf7, 0xb0,
	0x92, 0x08, 0x3f, 0xb3, 0x1c, 0x7d, 0x13, 0xd5, 0xa0, 0x72, 0x61, 0x8d, 0xc7, 0xc6, 0x99, 0x35,
	0xd6, 0xcb, 0xa2, 0x5c, 0x96, 0xbf, 0x7b, 0xae, 0x57, 0x84, 0x73, 0x6c, 0x4f, 0x9c, 0xd3, 0xe1,
	0xeb, 0x81, 0xae, 0x89, 0x76, 0x4e, 0x27, 0x17, 0x23, 0x1d, 0xe4, 0xa9, 0x2c, 0x03, 0x3b, 0xa6,
	0x65, 0x38, 0x7a, 0x55, 0x14, 0x48, 0x77, 0xe1, 0x61, 0xbf, 0x6f, 0x8a, 0xad, 0x35, 0xd3, 0xf8,
	0xf5, 0xb6, 0xa9, 0xfc, 0x76, 0xdb, 0x54, 0xfe, 0xb8, 0x6d, 0x2a, 0x3f, 0xff, 0xd9, 0xdc, 0x80,
	0x27, 0x7f, 0x6e, 0xcc, 0x6a, 0xfa, 0x4f, 0x24, 0xe9, 0xb1, 0x95, 0xd9, 0xa6, 0x74, 0x7c, 0xf1,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x97, 0x69, 0xe7, 0x75, 0x2b, 0x09, 0x00, 0x00,
}

func (m *Packet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CompressionPresent != nil {
		{
			size := m.CompressionPresent.Size()
			i -= size
			if _, err := m.CompressionPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.VersionPresent != nil {
		{
			size := m.VersionPresent.Size()
			i -= size
			if _, err := m.VersionPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MagicNumberPresent != nil {
		{
			size := m.MagicNumberPresent.Size()
			i -= size
			if _, err := m.MagicNumberPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Packet_MagicNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_MagicNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.MagicNumber))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Packet_Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Packet_Compression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Compression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Compression))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *HeartBeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartBeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.SendTimestamp != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.SendTimestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Handshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Handshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Handshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SupportedCompressions != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.SupportedCompressions))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Seeds) > 0 {
		i -= len(m.Seeds)
		copy(dAtA[i:], m.Seeds)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Seeds)))
		i--
		dAtA[i] = 0x12
	}
	if m.CommunicationEncodingPresent != nil {
		{
			size := m.CommunicationEncodingPresent.Size()
			i -= size
			if _, err := m.CommunicationEncodingPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Handshake_CommunicationEncoding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Handshake_CommunicationEncoding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CommunicationEncoding)
	copy(dAtA[i:], m.CommunicationEncoding)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.CommunicationEncoding)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *ClientAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NetWriteTimeoutPresent != nil {
		{
			size := m.NetWriteTimeoutPresent.Size()
			i -= size
			if _, err := m.NetWriteTimeoutPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetReadTimeoutPresent != nil {
		{
			size := m.NetReadTimeoutPresent.Size()
			i -= size
			if _, err := m.NetReadTimeoutPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientAuth_NetReadTimeout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientAuth_NetReadTimeout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.NetReadTimeout))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ClientAuth_NetWriteTimeout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientAuth_NetWriteTimeout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.NetWriteTimeout))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Ack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrorCodePresent != nil {
		{
			size := m.ErrorCodePresent.Size()
			i -= size
			if _, err := m.ErrorCodePresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Ack_ErrorCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ack_ErrorCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.ErrorCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *ClientAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BatchId != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sub) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Unsub) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Unsub) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Unsub) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Filter) > 0 {
		i -= len(m.Filter)
		copy(dAtA[i:], m.Filter)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Filter)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Get) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Get) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Get) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AutoAckPresent != nil {
		{
			size := m.AutoAckPresent.Size()
			i -= size
			if _, err := m.AutoAckPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UnitPresent != nil {
		{
			size := m.UnitPresent.Size()
			i -= size
			if _, err := m.UnitPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TimeoutPresent != nil {
		{
			size := m.TimeoutPresent.Size()
			i -= size
			if _, err := m.TimeoutPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FetchSize != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.FetchSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Get_Timeout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Get_Timeout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Timeout))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Get_Unit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Get_Unit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Unit))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *Get_AutoAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Get_AutoAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.AutoAck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Messages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Messages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Messages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Messages[iNdEx])
			copy(dAtA[i:], m.Messages[iNdEx])
			i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Messages[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BatchId != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dump) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dump) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dump) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TimestampPresent != nil {
		{
			size := m.TimestampPresent.Size()
			i -= size
			if _, err := m.TimestampPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Position != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Position))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Journal) > 0 {
		i -= len(m.Journal)
		copy(dAtA[i:], m.Journal)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Journal)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Dump_Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dump_Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintCanalProtocol(dAtA, i, uint64(m.Timestamp))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *ClientRollback) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientRollback) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientRollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BatchId != 0 {
		i = encodeVarintCanalProtocol(dAtA, i, uint64(m.BatchId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintCanalProtocol(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCanalProtocol(dAtA []byte, offset int, v uint64) int {
	offset -= sovCanalProtocol(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Packet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MagicNumberPresent != nil {
		n += m.MagicNumberPresent.Size()
	}
	if m.VersionPresent != nil {
		n += m.VersionPresent.Size()
	}
	if m.Type != 0 {
		n += 1 + sovCanalProtocol(uint64(m.Type))
	}
	if m.CompressionPresent != nil {
		n += m.CompressionPresent.Size()
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Packet_MagicNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.MagicNumber))
	return n
}
func (m *Packet_Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Version))
	return n
}
func (m *Packet_Compression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Compression))
	return n
}
func (m *HeartBeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendTimestamp != 0 {
		n += 1 + sovCanalProtocol(uint64(m.SendTimestamp))
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovCanalProtocol(uint64(m.StartTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Handshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommunicationEncodingPresent != nil {
		n += m.CommunicationEncodingPresent.Size()
	}
	l = len(m.Seeds)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.SupportedCompressions != 0 {
		n += 1 + sovCanalProtocol(uint64(m.SupportedCompressions))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Handshake_CommunicationEncoding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommunicationEncoding)
	n += 1 + l + sovCanalProtocol(uint64(l))
	return n
}
func (m *ClientAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.NetReadTimeoutPresent != nil {
		n += m.NetReadTimeoutPresent.Size()
	}
	if m.NetWriteTimeoutPresent != nil {
		n += m.NetWriteTimeoutPresent.Size()
	}
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.StartTimestamp != 0 {
		n += 1 + sovCanalProtocol(uint64(m.StartTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientAuth_NetReadTimeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.NetReadTimeout))
	return n
}
func (m *ClientAuth_NetWriteTimeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.NetWriteTimeout))
	return n
}
func (m *Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorCodePresent != nil {
		n += m.ErrorCodePresent.Size()
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ack_ErrorCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.ErrorCode))
	return n
}
func (m *ClientAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.BatchId != 0 {
		n += 1 + sovCanalProtocol(uint64(m.BatchId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Unsub) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Get) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.FetchSize != 0 {
		n += 1 + sovCanalProtocol(uint64(m.FetchSize))
	}
	if m.TimeoutPresent != nil {
		n += m.TimeoutPresent.Size()
	}
	if m.UnitPresent != nil {
		n += m.UnitPresent.Size()
	}
	if m.AutoAckPresent != nil {
		n += m.AutoAckPresent.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Get_Timeout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Timeout))
	return n
}
func (m *Get_Unit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Unit))
	return n
}
func (m *Get_AutoAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *Messages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchId != 0 {
		n += 1 + sovCanalProtocol(uint64(m.BatchId))
	}
	if len(m.Messages) > 0 {
		for _, b := range m.Messages {
			l = len(b)
			n += 1 + l + sovCanalProtocol(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dump) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Journal)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.Position != 0 {
		n += 1 + sovCanalProtocol(uint64(m.Position))
	}
	if m.TimestampPresent != nil {
		n += m.TimestampPresent.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dump_Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovCanalProtocol(uint64(m.Timestamp))
	return n
}
func (m *ClientRollback) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovCanalProtocol(uint64(l))
	}
	if m.BatchId != 0 {
		n += 1 + sovCanalProtocol(uint64(m.BatchId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCanalProtocol(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCanalProtocol(x uint64) (n int) {
	return sovCanalProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Packet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Packet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Packet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicNumber", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MagicNumberPresent = &Packet_MagicNumber{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VersionPresent = &Packet_Version{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PacketType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			var v Compression
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Compression(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CompressionPresent = &Packet_Compression{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartBeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartBeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTimestamp", wireType)
			}
			m.SendTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Handshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommunicationEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommunicationEncodingPresent = &Handshake_CommunicationEncoding{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seeds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seeds = append(m.Seeds[:0], dAtA[iNdEx:postIndex]...)
			if m.Seeds == nil {
				m.Seeds = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedCompressions", wireType)
			}
			m.SupportedCompressions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SupportedCompressions |= Compression(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetReadTimeout", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetReadTimeoutPresent = &ClientAuth_NetReadTimeout{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetWriteTimeout", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NetWriteTimeoutPresent = &ClientAuth_NetWriteTimeout{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ErrorCodePresent = &Ack_ErrorCode{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Unsub) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Unsub: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Unsub: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Get) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Get: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Get: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchSize", wireType)
			}
			m.FetchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimeoutPresent = &Get_Timeout{v}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UnitPresent = &Get_Unit{v}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AutoAckPresent = &Get_AutoAck{b}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Messages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Messages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Messages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, make([]byte, postIndex-iNdEx))
			copy(m.Messages[len(m.Messages)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dump) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dump: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dump: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Journal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Journal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimestampPresent = &Dump_Timestamp{v}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchId", wireType)
			}
			m.BatchId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCanalProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCanalProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCanalProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCanalProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCanalProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCanalProtocol
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCanalProtocol
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCanalProtocol
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCanalProtocol        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCanalProtocol          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCanalProtocol = fmt.Errorf("proto: unexpected end of group")
)
