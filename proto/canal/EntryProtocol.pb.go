// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: EntryProtocol.proto

package com_alibaba_otter_canal_protocol

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

//*打散后的事件类型，主要用于标识事务的开始，变更数据，结束*
type EntryType int32

const (
	EntryType_ENTRYTYPECOMPATIBLEPROTO2 EntryType = 0
	EntryType_TRANSACTIONBEGIN          EntryType = 1
	EntryType_ROWDATA                   EntryType = 2
	EntryType_TRANSACTIONEND            EntryType = 3
	//* 心跳类型，内部使用，外部暂不可见，可忽略 *
	EntryType_ENTRYHEARTBEAT EntryType = 4
	EntryType_GTIDLOG        EntryType = 5
)

var EntryType_name = map[int32]string{
	0: "ENTRYTYPECOMPATIBLEPROTO2",
	1: "TRANSACTIONBEGIN",
	2: "ROWDATA",
	3: "TRANSACTIONEND",
	4: "ENTRYHEARTBEAT",
	5: "GTIDLOG",
}

var EntryType_value = map[string]int32{
	"ENTRYTYPECOMPATIBLEPROTO2": 0,
	"TRANSACTIONBEGIN":          1,
	"ROWDATA":                   2,
	"TRANSACTIONEND":            3,
	"ENTRYHEARTBEAT":            4,
	"GTIDLOG":                   5,
}

func (x EntryType) String() string {
	return proto.EnumName(EntryType_name, int32(x))
}

func (EntryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{0}
}

//* 事件类型 *
type EventType int32

const (
	EventType_EVENTTYPECOMPATIBLEPROTO2 EventType = 0
	EventType_INSERT                    EventType = 1
	EventType_UPDATE                    EventType = 2
	EventType_DELETE                    EventType = 3
	EventType_CREATE                    EventType = 4
	EventType_ALTER                     EventType = 5
	EventType_ERASE                     EventType = 6
	EventType_QUERY                     EventType = 7
	EventType_TRUNCATE                  EventType = 8
	EventType_RENAME                    EventType = 9
	//*CREATE INDEX*
	EventType_CINDEX EventType = 10
	EventType_DINDEX EventType = 11
	EventType_GTID   EventType = 12
	//* XA *
	EventType_XACOMMIT   EventType = 13
	EventType_XAROLLBACK EventType = 14
	//* MASTER HEARTBEAT *
	EventType_MHEARTBEAT EventType = 15
)

var EventType_name = map[int32]string{
	0:  "EVENTTYPECOMPATIBLEPROTO2",
	1:  "INSERT",
	2:  "UPDATE",
	3:  "DELETE",
	4:  "CREATE",
	5:  "ALTER",
	6:  "ERASE",
	7:  "QUERY",
	8:  "TRUNCATE",
	9:  "RENAME",
	10: "CINDEX",
	11: "DINDEX",
	12: "GTID",
	13: "XACOMMIT",
	14: "XAROLLBACK",
	15: "MHEARTBEAT",
}

var EventType_value = map[string]int32{
	"EVENTTYPECOMPATIBLEPROTO2": 0,
	"INSERT":                    1,
	"UPDATE":                    2,
	"DELETE":                    3,
	"CREATE":                    4,
	"ALTER":                     5,
	"ERASE":                     6,
	"QUERY":                     7,
	"TRUNCATE":                  8,
	"RENAME":                    9,
	"CINDEX":                    10,
	"DINDEX":                    11,
	"GTID":                      12,
	"XACOMMIT":                  13,
	"XAROLLBACK":                14,
	"MHEARTBEAT":                15,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{1}
}

//*数据库类型*
type Type int32

const (
	Type_TYPECOMPATIBLEPROTO2 Type = 0
	Type_ORACLE               Type = 1
	Type_MYSQL                Type = 2
	Type_PGSQL                Type = 3
)

var Type_name = map[int32]string{
	0: "TYPECOMPATIBLEPROTO2",
	1: "ORACLE",
	2: "MYSQL",
	3: "PGSQL",
}

var Type_value = map[string]int32{
	"TYPECOMPATIBLEPROTO2": 0,
	"ORACLE":               1,
	"MYSQL":                2,
	"PGSQL":                3,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{2}
}

//***************************************************************
// message model
//如果要在Enum中新增类型，确保以前的类型的下标值不变.
//**************************************************************
type Entry struct {
	//*协议头部信息*
	Header *Header `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	///**打散后的事件类型**/ [default = ROWDATA]
	//
	// Types that are valid to be assigned to EntryTypePresent:
	//	*Entry_EntryType
	EntryTypePresent isEntry_EntryTypePresent `protobuf_oneof:"entryType_present"`
	//*传输的二进制数组*
	StoreValue []byte `protobuf:"bytes,3,opt,name=storeValue,proto3" json:"storeValue,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{0}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

type isEntry_EntryTypePresent interface {
	isEntry_EntryTypePresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Entry_EntryType struct {
	EntryType EntryType `protobuf:"varint,2,opt,name=entryType,proto3,enum=com.alibaba.otter.canal.protocol.EntryType,oneof" json:"entryType,omitempty"`
}

func (*Entry_EntryType) isEntry_EntryTypePresent() {}

func (m *Entry) GetEntryTypePresent() isEntry_EntryTypePresent {
	if m != nil {
		return m.EntryTypePresent
	}
	return nil
}

func (m *Entry) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Entry) GetEntryType() EntryType {
	if x, ok := m.GetEntryTypePresent().(*Entry_EntryType); ok {
		return x.EntryType
	}
	return EntryType_ENTRYTYPECOMPATIBLEPROTO2
}

func (m *Entry) GetStoreValue() []byte {
	if m != nil {
		return m.StoreValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Entry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Entry_EntryType)(nil),
	}
}

//*message Header*
type Header struct {
	//[default = 1]
	//
	// Types that are valid to be assigned to VersionPresent:
	//	*Header_Version
	VersionPresent isHeader_VersionPresent `protobuf_oneof:"version_present"`
	//*binlog/redolog 文件名*
	LogfileName string `protobuf:"bytes,2,opt,name=logfileName,proto3" json:"logfileName,omitempty"`
	//*binlog/redolog 文件的偏移位置*
	LogfileOffset int64 `protobuf:"varint,3,opt,name=logfileOffset,proto3" json:"logfileOffset,omitempty"`
	//*服务端serverId*
	ServerId int64 `protobuf:"varint,4,opt,name=serverId,proto3" json:"serverId,omitempty"`
	//* 变更数据的编码 *
	ServerenCode string `protobuf:"bytes,5,opt,name=serverenCode,proto3" json:"serverenCode,omitempty"`
	//*变更数据的执行时间 *
	ExecuteTime int64 `protobuf:"varint,6,opt,name=executeTime,proto3" json:"executeTime,omitempty"`
	//[default = MYSQL]
	//
	// Types that are valid to be assigned to SourceTypePresent:
	//	*Header_SourceType
	SourceTypePresent isHeader_SourceTypePresent `protobuf_oneof:"sourceType_present"`
	//* 变更数据的schemaname*
	SchemaName string `protobuf:"bytes,8,opt,name=schemaName,proto3" json:"schemaName,omitempty"`
	//*变更数据的tablename*
	TableName string `protobuf:"bytes,9,opt,name=tableName,proto3" json:"tableName,omitempty"`
	//*每个event的长度*
	EventLength int64 `protobuf:"varint,10,opt,name=eventLength,proto3" json:"eventLength,omitempty"`
	// [default = UPDATE]
	//
	// Types that are valid to be assigned to EventTypePresent:
	//	*Header_EventType
	EventTypePresent isHeader_EventTypePresent `protobuf_oneof:"eventType_present"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,12,rep,name=props,proto3" json:"props,omitempty"`
	//*当前事务的gitd*
	Gtid string `protobuf:"bytes,13,opt,name=gtid,proto3" json:"gtid,omitempty"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{1}
}
func (m *Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return m.Size()
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

type isHeader_VersionPresent interface {
	isHeader_VersionPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isHeader_SourceTypePresent interface {
	isHeader_SourceTypePresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isHeader_EventTypePresent interface {
	isHeader_EventTypePresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Header_Version struct {
	Version int32 `protobuf:"varint,1,opt,name=version,proto3,oneof" json:"version,omitempty"`
}
type Header_SourceType struct {
	SourceType Type `protobuf:"varint,7,opt,name=sourceType,proto3,enum=com.alibaba.otter.canal.protocol.Type,oneof" json:"sourceType,omitempty"`
}
type Header_EventType struct {
	EventType EventType `protobuf:"varint,11,opt,name=eventType,proto3,enum=com.alibaba.otter.canal.protocol.EventType,oneof" json:"eventType,omitempty"`
}

func (*Header_Version) isHeader_VersionPresent()       {}
func (*Header_SourceType) isHeader_SourceTypePresent() {}
func (*Header_EventType) isHeader_EventTypePresent()   {}

func (m *Header) GetVersionPresent() isHeader_VersionPresent {
	if m != nil {
		return m.VersionPresent
	}
	return nil
}
func (m *Header) GetSourceTypePresent() isHeader_SourceTypePresent {
	if m != nil {
		return m.SourceTypePresent
	}
	return nil
}
func (m *Header) GetEventTypePresent() isHeader_EventTypePresent {
	if m != nil {
		return m.EventTypePresent
	}
	return nil
}

func (m *Header) GetVersion() int32 {
	if x, ok := m.GetVersionPresent().(*Header_Version); ok {
		return x.Version
	}
	return 0
}

func (m *Header) GetLogfileName() string {
	if m != nil {
		return m.LogfileName
	}
	return ""
}

func (m *Header) GetLogfileOffset() int64 {
	if m != nil {
		return m.LogfileOffset
	}
	return 0
}

func (m *Header) GetServerId() int64 {
	if m != nil {
		return m.ServerId
	}
	return 0
}

func (m *Header) GetServerenCode() string {
	if m != nil {
		return m.ServerenCode
	}
	return ""
}

func (m *Header) GetExecuteTime() int64 {
	if m != nil {
		return m.ExecuteTime
	}
	return 0
}

func (m *Header) GetSourceType() Type {
	if x, ok := m.GetSourceTypePresent().(*Header_SourceType); ok {
		return x.SourceType
	}
	return Type_TYPECOMPATIBLEPROTO2
}

func (m *Header) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *Header) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Header) GetEventLength() int64 {
	if m != nil {
		return m.EventLength
	}
	return 0
}

func (m *Header) GetEventType() EventType {
	if x, ok := m.GetEventTypePresent().(*Header_EventType); ok {
		return x.EventType
	}
	return EventType_EVENTTYPECOMPATIBLEPROTO2
}

func (m *Header) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *Header) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Header) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Header_Version)(nil),
		(*Header_SourceType)(nil),
		(*Header_EventType)(nil),
	}
}

//*每个字段的数据结构*
type Column struct {
	//*字段下标*
	Index int32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	//*字段java中类型*
	SqlType int32 `protobuf:"varint,2,opt,name=sqlType,proto3" json:"sqlType,omitempty"`
	//*字段名称(忽略大小写)，在mysql中是没有的*
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	//*是否是主键*
	IsKey bool `protobuf:"varint,4,opt,name=isKey,proto3" json:"isKey,omitempty"`
	//*如果EventType=UPDATE,用于标识这个字段值是否有修改*
	Updated bool `protobuf:"varint,5,opt,name=updated,proto3" json:"updated,omitempty"`
	//[default = false]
	//
	// Types that are valid to be assigned to IsNullPresent:
	//	*Column_IsNull
	IsNullPresent isColumn_IsNullPresent `protobuf_oneof:"isNull_present"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,7,rep,name=props,proto3" json:"props,omitempty"`
	//* 字段值,timestamp,Datetime是一个时间格式的文本 *
	Value string `protobuf:"bytes,8,opt,name=value,proto3" json:"value,omitempty"`
	//* 对应数据对象原始长度 *
	Length int32 `protobuf:"varint,9,opt,name=length,proto3" json:"length,omitempty"`
	//*字段mysql类型*
	MysqlType string `protobuf:"bytes,10,opt,name=mysqlType,proto3" json:"mysqlType,omitempty"`
}

func (m *Column) Reset()         { *m = Column{} }
func (m *Column) String() string { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()    {}
func (*Column) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{2}
}
func (m *Column) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Column) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Column.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Column) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Column.Merge(m, src)
}
func (m *Column) XXX_Size() int {
	return m.Size()
}
func (m *Column) XXX_DiscardUnknown() {
	xxx_messageInfo_Column.DiscardUnknown(m)
}

var xxx_messageInfo_Column proto.InternalMessageInfo

type isColumn_IsNullPresent interface {
	isColumn_IsNullPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Column_IsNull struct {
	IsNull bool `protobuf:"varint,6,opt,name=isNull,proto3,oneof" json:"isNull,omitempty"`
}

func (*Column_IsNull) isColumn_IsNullPresent() {}

func (m *Column) GetIsNullPresent() isColumn_IsNullPresent {
	if m != nil {
		return m.IsNullPresent
	}
	return nil
}

func (m *Column) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Column) GetSqlType() int32 {
	if m != nil {
		return m.SqlType
	}
	return 0
}

func (m *Column) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Column) GetIsKey() bool {
	if m != nil {
		return m.IsKey
	}
	return false
}

func (m *Column) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

func (m *Column) GetIsNull() bool {
	if x, ok := m.GetIsNullPresent().(*Column_IsNull); ok {
		return x.IsNull
	}
	return false
}

func (m *Column) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *Column) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Column) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Column) GetMysqlType() string {
	if m != nil {
		return m.MysqlType
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Column) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Column_IsNull)(nil),
	}
}

type RowData struct {
	//* 字段信息，增量数据(修改前,删除前) *
	BeforeColumns []*Column `protobuf:"bytes,1,rep,name=beforeColumns,proto3" json:"beforeColumns,omitempty"`
	//* 字段信息，增量数据(修改后,新增后)  *
	AfterColumns []*Column `protobuf:"bytes,2,rep,name=afterColumns,proto3" json:"afterColumns,omitempty"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,3,rep,name=props,proto3" json:"props,omitempty"`
}

func (m *RowData) Reset()         { *m = RowData{} }
func (m *RowData) String() string { return proto.CompactTextString(m) }
func (*RowData) ProtoMessage()    {}
func (*RowData) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{3}
}
func (m *RowData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowData.Merge(m, src)
}
func (m *RowData) XXX_Size() int {
	return m.Size()
}
func (m *RowData) XXX_DiscardUnknown() {
	xxx_messageInfo_RowData.DiscardUnknown(m)
}

var xxx_messageInfo_RowData proto.InternalMessageInfo

func (m *RowData) GetBeforeColumns() []*Column {
	if m != nil {
		return m.BeforeColumns
	}
	return nil
}

func (m *RowData) GetAfterColumns() []*Column {
	if m != nil {
		return m.AfterColumns
	}
	return nil
}

func (m *RowData) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

//*message row 每行变更数据的数据结构*
type RowChange struct {
	//*tableId,由数据库产生*
	TableId int64 `protobuf:"varint,1,opt,name=tableId,proto3" json:"tableId,omitempty"`
	//[default = UPDATE]
	//
	// Types that are valid to be assigned to EventTypePresent:
	//	*RowChange_EventType
	EventTypePresent isRowChange_EventTypePresent `protobuf_oneof:"eventType_present"`
	// [default = false]
	//
	// Types that are valid to be assigned to IsDdlPresent:
	//	*RowChange_IsDdl
	IsDdlPresent isRowChange_IsDdlPresent `protobuf_oneof:"isDdl_present"`
	//* ddl/query的sql语句  *
	Sql string `protobuf:"bytes,11,opt,name=sql,proto3" json:"sql,omitempty"`
	//* 一次数据库变更可能存在多行  *
	RowDatas []*RowData `protobuf:"bytes,12,rep,name=rowDatas,proto3" json:"rowDatas,omitempty"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,13,rep,name=props,proto3" json:"props,omitempty"`
	//* ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
	DdlSchemaName string `protobuf:"bytes,14,opt,name=ddlSchemaName,proto3" json:"ddlSchemaName,omitempty"`
}

func (m *RowChange) Reset()         { *m = RowChange{} }
func (m *RowChange) String() string { return proto.CompactTextString(m) }
func (*RowChange) ProtoMessage()    {}
func (*RowChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{4}
}
func (m *RowChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowChange.Merge(m, src)
}
func (m *RowChange) XXX_Size() int {
	return m.Size()
}
func (m *RowChange) XXX_DiscardUnknown() {
	xxx_messageInfo_RowChange.DiscardUnknown(m)
}

var xxx_messageInfo_RowChange proto.InternalMessageInfo

type isRowChange_EventTypePresent interface {
	isRowChange_EventTypePresent()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRowChange_IsDdlPresent interface {
	isRowChange_IsDdlPresent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RowChange_EventType struct {
	EventType EventType `protobuf:"varint,2,opt,name=eventType,proto3,enum=com.alibaba.otter.canal.protocol.EventType,oneof" json:"eventType,omitempty"`
}
type RowChange_IsDdl struct {
	IsDdl bool `protobuf:"varint,10,opt,name=isDdl,proto3,oneof" json:"isDdl,omitempty"`
}

func (*RowChange_EventType) isRowChange_EventTypePresent() {}
func (*RowChange_IsDdl) isRowChange_IsDdlPresent()         {}

func (m *RowChange) GetEventTypePresent() isRowChange_EventTypePresent {
	if m != nil {
		return m.EventTypePresent
	}
	return nil
}
func (m *RowChange) GetIsDdlPresent() isRowChange_IsDdlPresent {
	if m != nil {
		return m.IsDdlPresent
	}
	return nil
}

func (m *RowChange) GetTableId() int64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *RowChange) GetEventType() EventType {
	if x, ok := m.GetEventTypePresent().(*RowChange_EventType); ok {
		return x.EventType
	}
	return EventType_EVENTTYPECOMPATIBLEPROTO2
}

func (m *RowChange) GetIsDdl() bool {
	if x, ok := m.GetIsDdlPresent().(*RowChange_IsDdl); ok {
		return x.IsDdl
	}
	return false
}

func (m *RowChange) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

func (m *RowChange) GetRowDatas() []*RowData {
	if m != nil {
		return m.RowDatas
	}
	return nil
}

func (m *RowChange) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *RowChange) GetDdlSchemaName() string {
	if m != nil {
		return m.DdlSchemaName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RowChange) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RowChange_EventType)(nil),
		(*RowChange_IsDdl)(nil),
	}
}

//*开始事务的一些信息*
type TransactionBegin struct {
	//*已废弃，请使用header里的executeTime*
	ExecuteTime int64 `protobuf:"varint,1,opt,name=executeTime,proto3" json:"executeTime,omitempty"`
	//*已废弃，Begin里不提供事务id*
	TransactionId string `protobuf:"bytes,2,opt,name=transactionId,proto3" json:"transactionId,omitempty"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,3,rep,name=props,proto3" json:"props,omitempty"`
	//*执行的thread Id*
	ThreadId int64 `protobuf:"varint,4,opt,name=threadId,proto3" json:"threadId,omitempty"`
}

func (m *TransactionBegin) Reset()         { *m = TransactionBegin{} }
func (m *TransactionBegin) String() string { return proto.CompactTextString(m) }
func (*TransactionBegin) ProtoMessage()    {}
func (*TransactionBegin) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{5}
}
func (m *TransactionBegin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionBegin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionBegin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionBegin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionBegin.Merge(m, src)
}
func (m *TransactionBegin) XXX_Size() int {
	return m.Size()
}
func (m *TransactionBegin) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionBegin.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionBegin proto.InternalMessageInfo

func (m *TransactionBegin) GetExecuteTime() int64 {
	if m != nil {
		return m.ExecuteTime
	}
	return 0
}

func (m *TransactionBegin) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *TransactionBegin) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

func (m *TransactionBegin) GetThreadId() int64 {
	if m != nil {
		return m.ThreadId
	}
	return 0
}

//*结束事务的一些信息*
type TransactionEnd struct {
	//*已废弃，请使用header里的executeTime*
	ExecuteTime int64 `protobuf:"varint,1,opt,name=executeTime,proto3" json:"executeTime,omitempty"`
	//*事务号*
	TransactionId string `protobuf:"bytes,2,opt,name=transactionId,proto3" json:"transactionId,omitempty"`
	//*预留扩展*
	Props []*Pair `protobuf:"bytes,3,rep,name=props,proto3" json:"props,omitempty"`
}

func (m *TransactionEnd) Reset()         { *m = TransactionEnd{} }
func (m *TransactionEnd) String() string { return proto.CompactTextString(m) }
func (*TransactionEnd) ProtoMessage()    {}
func (*TransactionEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{6}
}
func (m *TransactionEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionEnd.Merge(m, src)
}
func (m *TransactionEnd) XXX_Size() int {
	return m.Size()
}
func (m *TransactionEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionEnd.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionEnd proto.InternalMessageInfo

func (m *TransactionEnd) GetExecuteTime() int64 {
	if m != nil {
		return m.ExecuteTime
	}
	return 0
}

func (m *TransactionEnd) GetTransactionId() string {
	if m != nil {
		return m.TransactionId
	}
	return ""
}

func (m *TransactionEnd) GetProps() []*Pair {
	if m != nil {
		return m.Props
	}
	return nil
}

//*预留扩展*
type Pair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_237ce6ff565bd62b, []int{7}
}
func (m *Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(m, src)
}
func (m *Pair) XXX_Size() int {
	return m.Size()
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Pair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.EntryType", EntryType_name, EntryType_value)
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("com.alibaba.otter.canal.protocol.Type", Type_name, Type_value)
	proto.RegisterType((*Entry)(nil), "com.alibaba.otter.canal.protocol.Entry")
	proto.RegisterType((*Header)(nil), "com.alibaba.otter.canal.protocol.Header")
	proto.RegisterType((*Column)(nil), "com.alibaba.otter.canal.protocol.Column")
	proto.RegisterType((*RowData)(nil), "com.alibaba.otter.canal.protocol.RowData")
	proto.RegisterType((*RowChange)(nil), "com.alibaba.otter.canal.protocol.RowChange")
	proto.RegisterType((*TransactionBegin)(nil), "com.alibaba.otter.canal.protocol.TransactionBegin")
	proto.RegisterType((*TransactionEnd)(nil), "com.alibaba.otter.canal.protocol.TransactionEnd")
	proto.RegisterType((*Pair)(nil), "com.alibaba.otter.canal.protocol.Pair")
}

func init() { proto.RegisterFile("EntryProtocol.proto", fileDescriptor_237ce6ff565bd62b) }

var fileDescriptor_237ce6ff565bd62b = []byte{
	// 1081 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0xf5, 0xcf, 0xd1, 0x8f, 0x37, 0x1b, 0x23, 0x60, 0x83, 0x56, 0x10, 0x04, 0xa3, 0x70,
	0x5d, 0x40, 0x07, 0xf7, 0xda, 0x43, 0x49, 0x6a, 0x61, 0x09, 0x96, 0x28, 0x65, 0xbd, 0x4e, 0xed,
	0x53, 0x41, 0x8b, 0x6b, 0x5b, 0x28, 0x45, 0x2a, 0x24, 0xe5, 0xc4, 0xd7, 0x3e, 0x41, 0x4f, 0x7d,
	0x90, 0xa2, 0x0f, 0x51, 0xa0, 0x97, 0x5c, 0x0a, 0xf4, 0x58, 0xd8, 0xc8, 0xb1, 0xef, 0x50, 0xec,
	0x52, 0x24, 0xa5, 0xb6, 0x81, 0x1c, 0xf7, 0x92, 0xdb, 0xcc, 0x68, 0xbf, 0xe1, 0x37, 0x33, 0xdf,
	0xec, 0x0a, 0x9e, 0x12, 0x2f, 0x0a, 0x6e, 0x27, 0x81, 0x1f, 0xf9, 0x53, 0xdf, 0xed, 0x2e, 0x84,
	0x81, 0xdb, 0x53, 0x7f, 0xde, 0xb5, 0xdd, 0xd9, 0x85, 0x7d, 0x61, 0x77, 0xfd, 0x28, 0xe2, 0x41,
	0x77, 0x6a, 0x7b, 0xf6, 0xea, 0xe7, 0xa9, 0xef, 0x76, 0x7e, 0x53, 0xa0, 0x24, 0x91, 0xf8, 0x1b,
	0x28, 0x5f, 0x73, 0xdb, 0xe1, 0x81, 0xa6, 0xb4, 0x95, 0xfd, 0xda, 0xe1, 0x7e, 0x77, 0x1b, 0xb8,
	0xdb, 0x97, 0xe7, 0xe9, 0x0a, 0x87, 0x8f, 0x41, 0xe5, 0x22, 0x15, 0xbb, 0x5d, 0x70, 0x2d, 0xdf,
	0x56, 0xf6, 0x9b, 0x87, 0x5f, 0x6e, 0x4f, 0x42, 0x12, 0x48, 0x3f, 0x47, 0x33, 0x3c, 0x6e, 0x01,
	0x84, 0x91, 0x1f, 0xf0, 0x97, 0xb6, 0xbb, 0xe4, 0x5a, 0xa1, 0xad, 0xec, 0xd7, 0xe9, 0x5a, 0xc4,
	0x78, 0x0a, 0x4f, 0xd2, 0xc3, 0xdf, 0x2d, 0x02, 0x1e, 0x72, 0x2f, 0xea, 0xfc, 0x5e, 0x84, 0x72,
	0x4c, 0x0a, 0x3f, 0x87, 0xca, 0x0d, 0x0f, 0xc2, 0x99, 0xef, 0xc9, 0x7a, 0x4a, 0xfd, 0x1c, 0x4d,
	0x02, 0xb8, 0x0d, 0x35, 0xd7, 0xbf, 0xba, 0x9c, 0xb9, 0xdc, 0xb2, 0xe7, 0x31, 0x55, 0x95, 0xae,
	0x87, 0xf0, 0x1e, 0x34, 0x56, 0xee, 0xf8, 0xf2, 0x32, 0xe4, 0x91, 0x24, 0x50, 0xa0, 0x9b, 0x41,
	0xfc, 0x1c, 0xaa, 0x21, 0x0f, 0x6e, 0x78, 0x30, 0x70, 0xb4, 0xa2, 0x3c, 0x90, 0xfa, 0xb8, 0x03,
	0xf5, 0xd8, 0xe6, 0x9e, 0xe9, 0x3b, 0x5c, 0x2b, 0xc9, 0x8f, 0x6c, 0xc4, 0x04, 0x0f, 0xfe, 0x86,
	0x4f, 0x97, 0x11, 0x67, 0xb3, 0x39, 0xd7, 0xca, 0x32, 0xc5, 0x7a, 0x08, 0xf7, 0x01, 0x42, 0x7f,
	0x19, 0x4c, 0xb9, 0xec, 0x69, 0x45, 0xf6, 0xf4, 0xf3, 0xed, 0x3d, 0x95, 0xed, 0x54, 0xe8, 0x1a,
	0x56, 0xf6, 0x73, 0x7a, 0xcd, 0xe7, 0xb6, 0x2c, 0xb9, 0x2a, 0xd9, 0xac, 0x45, 0xf0, 0xa7, 0xa0,
	0x46, 0xf6, 0xc5, 0xaa, 0x23, 0xaa, 0xfc, 0x39, 0x0b, 0x48, 0xa6, 0x37, 0xdc, 0x8b, 0x86, 0xdc,
	0xbb, 0x8a, 0xae, 0x35, 0x58, 0x31, 0xcd, 0x42, 0x72, 0xf8, 0xc2, 0x95, 0x44, 0x6b, 0x0f, 0x1e,
	0x7e, 0x02, 0xe9, 0xe7, 0x69, 0x86, 0xc7, 0x5f, 0x43, 0x69, 0x11, 0xf8, 0x8b, 0x50, 0xab, 0xb7,
	0x0b, 0xfb, 0xb5, 0x87, 0x54, 0x3c, 0xb1, 0x67, 0x01, 0x8d, 0x41, 0x18, 0x43, 0xf1, 0x2a, 0x9a,
	0x39, 0x5a, 0x43, 0x56, 0x21, 0x6d, 0xe3, 0x09, 0xec, 0xac, 0xa6, 0x9f, 0x88, 0xc5, 0xd8, 0x05,
	0x9c, 0xf5, 0x27, 0x8d, 0x0a, 0x5d, 0x25, 0x3c, 0x52, 0x5d, 0xfd, 0x9c, 0x87, 0xb2, 0xe9, 0xbb,
	0xcb, 0xb9, 0x87, 0x77, 0xa1, 0x34, 0xf3, 0x1c, 0xfe, 0x26, 0x56, 0x15, 0x8d, 0x1d, 0xac, 0x41,
	0x25, 0x7c, 0xe5, 0xa6, 0xc2, 0x2f, 0xd1, 0xc4, 0x15, 0x64, 0x3c, 0xd1, 0xd2, 0x42, 0x4c, 0x46,
	0xd8, 0x32, 0x47, 0x78, 0xcc, 0x6f, 0xa5, 0x68, 0xaa, 0x34, 0x76, 0x44, 0x8e, 0xe5, 0xc2, 0xb1,
	0x23, 0xee, 0x48, 0xb1, 0x54, 0x69, 0xe2, 0x62, 0x0d, 0xca, 0xb3, 0xd0, 0x5a, 0xba, 0xae, 0x94,
	0x48, 0xb5, 0x9f, 0xa3, 0x2b, 0x3f, 0x6b, 0x54, 0xe5, 0x31, 0x8d, 0xda, 0x85, 0xd2, 0x8d, 0x5c,
	0xaf, 0x58, 0x0e, 0xb1, 0x83, 0x9f, 0x41, 0xd9, 0x8d, 0xc7, 0xac, 0xca, 0x52, 0x56, 0x9e, 0x50,
	0xc8, 0xfc, 0x36, 0xa9, 0x12, 0x62, 0x85, 0xa4, 0x01, 0x03, 0x41, 0x33, 0xe6, 0x94, 0x36, 0xed,
	0x9d, 0x02, 0x15, 0xea, 0xbf, 0xee, 0xd9, 0x91, 0x8d, 0x2d, 0x68, 0x5c, 0xf0, 0x4b, 0x3f, 0xe0,
	0x71, 0x17, 0x43, 0x4d, 0x91, 0x7c, 0x1f, 0x70, 0xc7, 0xc4, 0x00, 0xba, 0x09, 0xc7, 0x43, 0xa8,
	0xdb, 0x97, 0x11, 0x0f, 0x92, 0x74, 0xf9, 0x0f, 0x4c, 0xb7, 0x81, 0xce, 0xba, 0x58, 0x78, 0x44,
	0x17, 0x3b, 0x7f, 0xe5, 0x41, 0xa5, 0xfe, 0x6b, 0xf3, 0xda, 0xf6, 0xae, 0xb8, 0x98, 0xa2, 0x5c,
	0x9b, 0x81, 0x23, 0x15, 0x52, 0xa0, 0x89, 0xbb, 0xb9, 0x21, 0xf9, 0x0f, 0xdf, 0x90, 0xdc, 0xfa,
	0x86, 0x3c, 0x13, 0x12, 0xea, 0x39, 0xae, 0x1c, 0x44, 0xb5, 0xaf, 0xd0, 0xd8, 0xc5, 0x08, 0x0a,
	0xe1, 0x2b, 0x57, 0x2e, 0xa0, 0x4a, 0x85, 0x89, 0x09, 0x54, 0x83, 0x78, 0x0a, 0xc9, 0x3a, 0x7d,
	0xb1, 0xfd, 0xab, 0xab, 0xb9, 0xd1, 0x14, 0x9a, 0xf5, 0xa8, 0xf1, 0x18, 0xa5, 0xed, 0x41, 0xc3,
	0x71, 0xdc, 0x93, 0xec, 0x02, 0x6a, 0x4a, 0x82, 0x9b, 0xc1, 0xff, 0xdc, 0x3d, 0x63, 0x07, 0x1a,
	0xb2, 0xb4, 0x54, 0x57, 0xbf, 0x28, 0x80, 0x58, 0x60, 0x7b, 0xa1, 0x3d, 0x8d, 0x66, 0xbe, 0x67,
	0xf0, 0xab, 0x99, 0xf7, 0xcf, 0xab, 0x54, 0xf9, 0xf7, 0x55, 0xba, 0x07, 0x8d, 0x28, 0x43, 0x0d,
	0x9c, 0xd5, 0xb5, 0xbf, 0x19, 0xfc, 0x7f, 0x52, 0x10, 0x0f, 0x42, 0x74, 0x1d, 0x70, 0xdb, 0xc9,
	0x1e, 0x84, 0xc4, 0xef, 0xfc, 0xa4, 0x40, 0x73, 0x8d, 0x36, 0xf1, 0x9c, 0x8f, 0x83, 0x74, 0xa7,
	0x0b, 0x45, 0xe1, 0x0a, 0xe9, 0x7c, 0xcf, 0x6f, 0x25, 0x0b, 0x95, 0x0a, 0x33, 0xbb, 0x1f, 0xf2,
	0x6b, 0xf7, 0xc3, 0xc1, 0x0f, 0x0a, 0xa8, 0xe9, 0xa3, 0x8d, 0x3f, 0x83, 0x4f, 0x88, 0xc5, 0xe8,
	0x39, 0x3b, 0x9f, 0x10, 0x73, 0x3c, 0x9a, 0xe8, 0x6c, 0x60, 0x0c, 0xc9, 0x84, 0x8e, 0xd9, 0xf8,
	0x10, 0xe5, 0xf0, 0x2e, 0x20, 0x46, 0x75, 0xeb, 0x44, 0x37, 0xd9, 0x60, 0x6c, 0x19, 0xe4, 0x68,
	0x60, 0x21, 0x05, 0xd7, 0xa0, 0x42, 0xc7, 0xdf, 0xf6, 0x74, 0xa6, 0xa3, 0x3c, 0xc6, 0xd0, 0x5c,
	0x3b, 0x42, 0xac, 0x1e, 0x2a, 0x88, 0x98, 0xcc, 0xda, 0x27, 0x3a, 0x65, 0x06, 0xd1, 0x19, 0x2a,
	0x0a, 0xd0, 0x11, 0x1b, 0xf4, 0x86, 0xe3, 0x23, 0x54, 0x3a, 0x78, 0x27, 0x48, 0xa4, 0xdb, 0x20,
	0x48, 0xbc, 0x24, 0x16, 0x7b, 0x0f, 0x09, 0x80, 0xf2, 0xc0, 0x3a, 0x21, 0x94, 0x21, 0x45, 0xd8,
	0xa7, 0x93, 0x9e, 0xce, 0x08, 0xca, 0x0b, 0xbb, 0x47, 0x86, 0x84, 0x11, 0x54, 0x10, 0xb6, 0x49,
	0x89, 0x88, 0x17, 0xb1, 0x0a, 0x25, 0x7d, 0xc8, 0x08, 0x45, 0x25, 0x61, 0x12, 0xaa, 0x9f, 0x10,
	0x54, 0x16, 0xe6, 0x8b, 0x53, 0x42, 0xcf, 0x51, 0x05, 0xd7, 0xa1, 0xca, 0xe8, 0xa9, 0x65, 0x8a,
	0xe3, 0x55, 0x01, 0xa5, 0xc4, 0xd2, 0x47, 0x04, 0xa9, 0x32, 0xcd, 0xc0, 0xea, 0x91, 0x33, 0x04,
	0x32, 0x7d, 0x6c, 0xd7, 0x70, 0x15, 0x8a, 0x82, 0x3c, 0xaa, 0x0b, 0xec, 0x99, 0x6e, 0x8e, 0x47,
	0xa3, 0x01, 0x43, 0x0d, 0xdc, 0x04, 0x38, 0xd3, 0xe9, 0x78, 0x38, 0x34, 0x74, 0xf3, 0x18, 0x35,
	0x85, 0x3f, 0xca, 0x8a, 0xde, 0x39, 0x30, 0xa0, 0x28, 0x2b, 0xd4, 0x60, 0xf7, 0xfd, 0xc5, 0x8d,
	0xa9, 0x6e, 0x0e, 0x09, 0x52, 0x04, 0xc5, 0xd1, 0xf9, 0xc9, 0x8b, 0x21, 0xca, 0x0b, 0x73, 0x72,
	0x24, 0xcc, 0x82, 0xd1, 0xff, 0xf5, 0xae, 0xa5, 0xbc, 0xbd, 0x6b, 0x29, 0x7f, 0xde, 0xb5, 0x94,
	0x1f, 0xef, 0x5b, 0xb9, 0xb7, 0xf7, 0xad, 0xdc, 0x1f, 0xf7, 0xad, 0x1c, 0x6c, 0xfd, 0x7f, 0x68,
	0x80, 0x29, 0x7c, 0x39, 0xee, 0xbe, 0x72, 0x51, 0x96, 0xf1, 0xaf, 0xfe, 0x0e, 0x00, 0x00, 0xff,
	0xff, 0x89, 0x37, 0xf8, 0x04, 0x6d, 0x0a, 0x00, 0x00,
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StoreValue) > 0 {
		i -= len(m.StoreValue)
		copy(dAtA[i:], m.StoreValue)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.StoreValue)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EntryTypePresent != nil {
		{
			size := m.EntryTypePresent.Size()
			i -= size
			if _, err := m.EntryTypePresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Entry_EntryType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry_EntryType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEntryProtocol(dAtA, i, uint64(m.EntryType))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.EventTypePresent != nil {
		{
			size := m.EventTypePresent.Size()
			i -= size
			if _, err := m.EventTypePresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EventLength != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.EventLength))
		i--
		dAtA[i] = 0x50
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x42
	}
	if m.SourceTypePresent != nil {
		{
			size := m.SourceTypePresent.Size()
			i -= size
			if _, err := m.SourceTypePresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ExecuteTime != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.ExecuteTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ServerenCode) > 0 {
		i -= len(m.ServerenCode)
		copy(dAtA[i:], m.ServerenCode)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.ServerenCode)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ServerId != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.ServerId))
		i--
		dAtA[i] = 0x20
	}
	if m.LogfileOffset != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.LogfileOffset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LogfileName) > 0 {
		i -= len(m.LogfileName)
		copy(dAtA[i:], m.LogfileName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.LogfileName)))
		i--
		dAtA[i] = 0x12
	}
	if m.VersionPresent != nil {
		{
			size := m.VersionPresent.Size()
			i -= size
			if _, err := m.VersionPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Header_Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEntryProtocol(dAtA, i, uint64(m.Version))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Header_SourceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_SourceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEntryProtocol(dAtA, i, uint64(m.SourceType))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *Header_EventType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Header_EventType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEntryProtocol(dAtA, i, uint64(m.EventType))
	i--
	dAtA[i] = 0x58
	return len(dAtA) - i, nil
}
func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MysqlType) > 0 {
		i -= len(m.MysqlType)
		copy(dAtA[i:], m.MysqlType)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.MysqlType)))
		i--
		dAtA[i] = 0x52
	}
	if m.Length != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IsNullPresent != nil {
		{
			size := m.IsNullPresent.Size()
			i -= size
			if _, err := m.IsNullPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Updated {
		i--
		if m.Updated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.IsKey {
		i--
		if m.IsKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SqlType != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.SqlType))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Column_IsNull) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Column_IsNull) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.IsNull {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *RowData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AfterColumns) > 0 {
		for iNdEx := len(m.AfterColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AfterColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BeforeColumns) > 0 {
		for iNdEx := len(m.BeforeColumns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BeforeColumns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RowChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DdlSchemaName) > 0 {
		i -= len(m.DdlSchemaName)
		copy(dAtA[i:], m.DdlSchemaName)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.DdlSchemaName)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.RowDatas) > 0 {
		for iNdEx := len(m.RowDatas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RowDatas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Sql) > 0 {
		i -= len(m.Sql)
		copy(dAtA[i:], m.Sql)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.Sql)))
		i--
		dAtA[i] = 0x5a
	}
	if m.IsDdlPresent != nil {
		{
			size := m.IsDdlPresent.Size()
			i -= size
			if _, err := m.IsDdlPresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.EventTypePresent != nil {
		{
			size := m.EventTypePresent.Size()
			i -= size
			if _, err := m.EventTypePresent.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TableId != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.TableId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RowChange_EventType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowChange_EventType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEntryProtocol(dAtA, i, uint64(m.EventType))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *RowChange_IsDdl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RowChange_IsDdl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.IsDdl {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	return len(dAtA) - i, nil
}
func (m *TransactionBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionBegin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionBegin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ThreadId != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.ThreadId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExecuteTime != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.ExecuteTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransactionEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactionEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Props) > 0 {
		for iNdEx := len(m.Props) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Props[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEntryProtocol(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TransactionId) > 0 {
		i -= len(m.TransactionId)
		copy(dAtA[i:], m.TransactionId)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.TransactionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExecuteTime != 0 {
		i = encodeVarintEntryProtocol(dAtA, i, uint64(m.ExecuteTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintEntryProtocol(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEntryProtocol(dAtA []byte, offset int, v uint64) int {
	offset -= sovEntryProtocol(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.EntryTypePresent != nil {
		n += m.EntryTypePresent.Size()
	}
	l = len(m.StoreValue)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	return n
}

func (m *Entry_EntryType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEntryProtocol(uint64(m.EntryType))
	return n
}
func (m *Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VersionPresent != nil {
		n += m.VersionPresent.Size()
	}
	l = len(m.LogfileName)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.LogfileOffset != 0 {
		n += 1 + sovEntryProtocol(uint64(m.LogfileOffset))
	}
	if m.ServerId != 0 {
		n += 1 + sovEntryProtocol(uint64(m.ServerId))
	}
	l = len(m.ServerenCode)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.ExecuteTime != 0 {
		n += 1 + sovEntryProtocol(uint64(m.ExecuteTime))
	}
	if m.SourceTypePresent != nil {
		n += m.SourceTypePresent.Size()
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.EventLength != 0 {
		n += 1 + sovEntryProtocol(uint64(m.EventLength))
	}
	if m.EventTypePresent != nil {
		n += m.EventTypePresent.Size()
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	return n
}

func (m *Header_Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEntryProtocol(uint64(m.Version))
	return n
}
func (m *Header_SourceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEntryProtocol(uint64(m.SourceType))
	return n
}
func (m *Header_EventType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEntryProtocol(uint64(m.EventType))
	return n
}
func (m *Column) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovEntryProtocol(uint64(m.Index))
	}
	if m.SqlType != 0 {
		n += 1 + sovEntryProtocol(uint64(m.SqlType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.IsKey {
		n += 2
	}
	if m.Updated {
		n += 2
	}
	if m.IsNullPresent != nil {
		n += m.IsNullPresent.Size()
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovEntryProtocol(uint64(m.Length))
	}
	l = len(m.MysqlType)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	return n
}

func (m *Column_IsNull) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RowData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BeforeColumns) > 0 {
		for _, e := range m.BeforeColumns {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if len(m.AfterColumns) > 0 {
		for _, e := range m.AfterColumns {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	return n
}

func (m *RowChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableId != 0 {
		n += 1 + sovEntryProtocol(uint64(m.TableId))
	}
	if m.EventTypePresent != nil {
		n += m.EventTypePresent.Size()
	}
	if m.IsDdlPresent != nil {
		n += m.IsDdlPresent.Size()
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if len(m.RowDatas) > 0 {
		for _, e := range m.RowDatas {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	l = len(m.DdlSchemaName)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	return n
}

func (m *RowChange_EventType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEntryProtocol(uint64(m.EventType))
	return n
}
func (m *RowChange_IsDdl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *TransactionBegin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecuteTime != 0 {
		n += 1 + sovEntryProtocol(uint64(m.ExecuteTime))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	if m.ThreadId != 0 {
		n += 1 + sovEntryProtocol(uint64(m.ThreadId))
	}
	return n
}

func (m *TransactionEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecuteTime != 0 {
		n += 1 + sovEntryProtocol(uint64(m.ExecuteTime))
	}
	l = len(m.TransactionId)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	if len(m.Props) > 0 {
		for _, e := range m.Props {
			l = e.Size()
			n += 1 + l + sovEntryProtocol(uint64(l))
		}
	}
	return n
}

func (m *Pair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovEntryProtocol(uint64(l))
	}
	return n
}

func sovEntryProtocol(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEntryProtocol(x uint64) (n int) {
	return sovEntryProtocol(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryType", wireType)
			}
			var v EntryType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= EntryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntryTypePresent = &Entry_EntryType{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreValue = append(m.StoreValue[:0], dAtA[iNdEx:postIndex]...)
			if m.StoreValue == nil {
				m.StoreValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VersionPresent = &Header_Version{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogfileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogfileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogfileOffset", wireType)
			}
			m.LogfileOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogfileOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			m.ServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerenCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerenCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteTime", wireType)
			}
			m.ExecuteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			var v Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceTypePresent = &Header_SourceType{v}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventLength", wireType)
			}
			m.EventLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventLength |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var v EventType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EventTypePresent = &Header_EventType{v}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlType", wireType)
			}
			m.SqlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SqlType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsKey = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Updated = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsNullPresent = &Column_IsNull{b}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MysqlType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MysqlType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeforeColumns = append(m.BeforeColumns, &Column{})
			if err := m.BeforeColumns[len(m.BeforeColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterColumns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterColumns = append(m.AfterColumns, &Column{})
			if err := m.AfterColumns[len(m.AfterColumns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			var v EventType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EventTypePresent = &RowChange_EventType{v}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDdl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsDdlPresent = &RowChange_IsDdl{b}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowDatas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowDatas = append(m.RowDatas, &RowData{})
			if err := m.RowDatas[len(m.RowDatas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DdlSchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DdlSchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteTime", wireType)
			}
			m.ExecuteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadId", wireType)
			}
			m.ThreadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteTime", wireType)
			}
			m.ExecuteTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecuteTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Props = append(m.Props, &Pair{})
			if err := m.Props[len(m.Props)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEntryProtocol(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEntryProtocol
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEntryProtocol(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEntryProtocol
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEntryProtocol
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEntryProtocol
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEntryProtocol
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEntryProtocol
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEntryProtocol        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEntryProtocol          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEntryProtocol = fmt.Errorf("proto: unexpected end of group")
)
