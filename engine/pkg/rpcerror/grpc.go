// Copyright 2022 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package rpcerror

import (
	gerrors "errors"
	"fmt"
	"reflect"

	"github.com/gogo/status"
	"github.com/pingcap/errors"
	"google.golang.org/grpc/codes"

	pb "github.com/pingcap/tiflow/engine/enginepb"
)

func tryUnwrapNormalizedError(errIn error) (typeErasedNormalizedError, bool) {
	var errOut typeErasedNormalizedError
	if gerrors.As(errIn, &errOut) {
		return errOut, true
	}
	return nil, false
}

// ToGRPCError is called on the server side to produce
// an error containing status information recognizable
// by the grpc-go library.
func ToGRPCError(errIn error) error {
	if normalized, ok := tryUnwrapNormalizedError(errIn); ok {
		st, err := status.New(normalized.statusCode(), normalized.message()).
			WithDetails(normalized.toPB())
		if err != nil {
			return errIn
		}
		return st.Err()
	}

	return errIn
}

// FromGRPCError is called on the client side to recover
// the error from the error returned from the grpc-go library.
func FromGRPCError(errIn error) error {
	st, ok := status.FromError(errIn)
	if !ok {
		// Not a grpc error.
		return errors.Trace(errIn)
	}

	if len(st.Details()) < 1 {
		// If the error is generated by ToGRPCError,
		// we expect one Detail.
		return errors.Trace(errIn)
	}

	detail := st.Details()[0]
	errPB, ok := detail.(*pb.ErrorV2)
	if !ok {
		return errors.Trace(errIn)
	}

	// Tries to find the prototype from the registry
	val, exists := prototypeRegistry.Load(errPB.Name)
	if !exists {
		return errors.Trace(
			errors.Errorf("unrecognizable error type: %s, with details: %s", errPB.Name, errPB.Details))
	}

	deserializer, ok := val.(jsonDeserializer)
	if !ok {
		panicMsg := fmt.Sprintf("Unexpected object in registry that does not implement jsonDeserializer: %s",
			reflect.TypeOf(val).Name())
		panic(panicMsg)
	}

	errOut, err := deserializer.fromJSONBytes(errPB.Details)
	if err != nil {
		return errors.Annotatef(err, "decode error type %s", errPB.Name)
	}

	return errors.Trace(errOut)
}

// IsRetryable returns whether the error is retryable when encountered by a grpc client.
func IsRetryable(errIn error) bool {
	normalized, ok := tryUnwrapNormalizedError(errIn)
	if !ok {
		// By default, unknown errors are NOT retryable.
		return false
	}

	return normalized.isRetryable()
}

// GRPCStatusCode extracts the grpc status code from an error.
func GRPCStatusCode(errIn error) (codes.Code, bool) {
	if err, ok := tryUnwrapNormalizedError(errIn); ok {
		return err.statusCode(), true
	}
	return codes.Unknown, false
}
