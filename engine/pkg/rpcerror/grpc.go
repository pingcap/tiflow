// Copyright 2022 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package rpcerror

import (
	"context"
	gerrors "errors"
	"fmt"
	"reflect"

	"github.com/pingcap/errors"
	"github.com/pingcap/log"
	pb "github.com/pingcap/tiflow/engine/enginepb"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func tryUnwrapNormalizedError(errIn error) (typeErasedNormalizedError, bool) {
	var errOut typeErasedNormalizedError
	if gerrors.As(errIn, &errOut) {
		return errOut, true
	}
	return nil, false
}

// ToGRPCError is called on the server side to produce
// an error containing status information recognizable
// by the grpc-go library.
func ToGRPCError(errIn error) error {
	var stackTrace errors.StackTrace
	if tracer := errors.GetStackTracer(errIn); tracer != nil {
		stackTrace = tracer.StackTrace()
	}
	if normalized, ok := tryUnwrapNormalizedError(errIn); ok {
		st, err := status.New(normalized.statusCode(), normalized.message()).
			WithDetails(normalized.toPB(stackTrace))
		if err != nil {
			return errIn
		}
		return st.Err()
	}

	return errIn
}

// FromGRPCError is called on the client side to recover
// the error from the error returned from the grpc-go library.
func FromGRPCError(errIn error) error {
	st, ok := status.FromError(errIn)
	if !ok {
		// Not a grpc error.
		return errors.Trace(errIn)
	}

	if len(st.Details()) < 1 {
		// If the error is generated by ToGRPCError,
		// we expect one Detail.
		return errors.Trace(errIn)
	}

	detail := st.Details()[0]
	errPB, ok := detail.(*pb.ErrorV2)
	if !ok {
		return errors.Trace(errIn)
	}

	// Tries to find the prototype from the registry
	val, exists := prototypeRegistry.Load(errPB.Name)
	if !exists {
		return errors.Trace(
			errors.Errorf("unrecognizable error type: %s, with details: %s", errPB.Name, errPB.Details))
	}

	deserializer, ok := val.(jsonDeserializer)
	if !ok {
		panicMsg := fmt.Sprintf("Unexpected object in registry that does not implement jsonDeserializer: %s",
			reflect.TypeOf(val).Name())
		panic(panicMsg)
	}

	errOut, err := deserializer.fromJSONBytes(errPB.Details)
	if err != nil {
		return errors.Annotatef(err, "decode error type %s", errPB.Name)
	}

	if len(errPB.StackTrace) > 0 {
		errOut.setServerStackTrace(errPB.StackTrace)
	}
	return errors.Trace(errOut)
}

// IsRetryable returns whether the error is retryable when encountered by a grpc client.
func IsRetryable(errIn error) bool {
	normalized, ok := tryUnwrapNormalizedError(errIn)
	if !ok {
		// By default, unknown errors are NOT retryable.
		return false
	}

	return normalized.isRetryable()
}

// IsManagedError returns whether the error is managed by the rpcerror library.
func IsManagedError(errIn error) bool {
	_, ok := tryUnwrapNormalizedError(errIn)
	return ok
}

// GRPCStatusCode extracts the grpc status code from an error.
func GRPCStatusCode(errIn error) (codes.Code, bool) {
	if err, ok := tryUnwrapNormalizedError(errIn); ok {
		return err.statusCode(), true
	}

	if errors.HasStack(errIn) {
		errIn = errors.Unwrap(errIn)
	}
	if st, ok := status.FromError(errIn); ok {
		// errIn is a raw gRPC error
		return st.Code(), true
	}
	return codes.Unknown, false
}

// UnaryServerInterceptor is a gRPC server-side interceptor that tries to convert errors to the standard grpc error.
func UnaryServerInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
	resp, err := handler(ctx, req)
	if err != nil {
		errOut := ToGRPCError(err)
		logger := log.With(zap.String("method", info.FullMethod), zap.Error(errOut), zap.Any("request", req))
		s, ok := status.FromError(errOut)
		if !ok {
			s = status.FromContextError(err)
		}
		switch s.Code() {
		case codes.Unknown:
			logger.Warn("request handled with an unknown error")
		case codes.Internal:
			logger.Warn("request handled with an internal error")
		default:
			logger.Debug("request handled with an error")
		}
		return nil, errOut
	}

	log.With(
		zap.String("method", info.FullMethod),
		zap.Any("request", req),
		zap.Any("response", resp),
	).Debug("request handled successfully")

	return resp, nil
}
