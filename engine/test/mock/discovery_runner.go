// Copyright 2022 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/srvdiscovery/runner.go

// Package mock_srvdiscovery is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	srvdiscovery "github.com/pingcap/tiflow/engine/pkg/srvdiscovery"
)

// MockDiscoveryRunner is a mock of DiscoveryRunner interface.
type MockDiscoveryRunner struct {
	ctrl     *gomock.Controller
	recorder *MockDiscoveryRunnerMockRecorder
}

// MockDiscoveryRunnerMockRecorder is the mock recorder for MockDiscoveryRunner.
type MockDiscoveryRunnerMockRecorder struct {
	mock *MockDiscoveryRunner
}

// NewMockDiscoveryRunner creates a new mock instance.
func NewMockDiscoveryRunner(ctrl *gomock.Controller) *MockDiscoveryRunner {
	mock := &MockDiscoveryRunner{ctrl: ctrl}
	mock.recorder = &MockDiscoveryRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDiscoveryRunner) EXPECT() *MockDiscoveryRunnerMockRecorder {
	return m.recorder
}

// ApplyWatchResult mocks base method.
func (m *MockDiscoveryRunner) ApplyWatchResult(arg0 srvdiscovery.WatchResp) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ApplyWatchResult", arg0)
}

// ApplyWatchResult indicates an expected call of ApplyWatchResult.
func (mr *MockDiscoveryRunnerMockRecorder) ApplyWatchResult(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyWatchResult", reflect.TypeOf((*MockDiscoveryRunner)(nil).ApplyWatchResult), arg0)
}

// GetSnapshot mocks base method.
func (m *MockDiscoveryRunner) GetSnapshot() srvdiscovery.Snapshot {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSnapshot")
	ret0, _ := ret[0].(srvdiscovery.Snapshot)
	return ret0
}

// GetSnapshot indicates an expected call of GetSnapshot.
func (mr *MockDiscoveryRunnerMockRecorder) GetSnapshot() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSnapshot", reflect.TypeOf((*MockDiscoveryRunner)(nil).GetSnapshot))
}

// GetWatcher mocks base method.
func (m *MockDiscoveryRunner) GetWatcher() <-chan srvdiscovery.WatchResp {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWatcher")
	ret0, _ := ret[0].(<-chan srvdiscovery.WatchResp)
	return ret0
}

// GetWatcher indicates an expected call of GetWatcher.
func (mr *MockDiscoveryRunnerMockRecorder) GetWatcher() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWatcher", reflect.TypeOf((*MockDiscoveryRunner)(nil).GetWatcher))
}

// ResetDiscovery mocks base method.
func (m *MockDiscoveryRunner) ResetDiscovery(ctx context.Context, resetSession bool) (srvdiscovery.Session, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResetDiscovery", ctx, resetSession)
	ret0, _ := ret[0].(srvdiscovery.Session)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResetDiscovery indicates an expected call of ResetDiscovery.
func (mr *MockDiscoveryRunnerMockRecorder) ResetDiscovery(ctx, resetSession interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResetDiscovery", reflect.TypeOf((*MockDiscoveryRunner)(nil).ResetDiscovery), ctx, resetSession)
}

// MockSession is a mock of Session interface.
type MockSession struct {
	ctrl     *gomock.Controller
	recorder *MockSessionMockRecorder
}

// MockSessionMockRecorder is the mock recorder for MockSession.
type MockSessionMockRecorder struct {
	mock *MockSession
}

// NewMockSession creates a new mock instance.
func NewMockSession(ctrl *gomock.Controller) *MockSession {
	mock := &MockSession{ctrl: ctrl}
	mock.recorder = &MockSessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSession) EXPECT() *MockSessionMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockSession) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockSessionMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSession)(nil).Close))
}

// Done mocks base method.
func (m *MockSession) Done() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Done")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// Done indicates an expected call of Done.
func (mr *MockSessionMockRecorder) Done() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Done", reflect.TypeOf((*MockSession)(nil).Done))
}
