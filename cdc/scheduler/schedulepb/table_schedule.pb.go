// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scheduler/schedulepb/table_schedule.proto

package schedulepb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_pingcap_tiflow_cdc_model "github.com/pingcap/tiflow/cdc/model"
	tablepb "github.com/pingcap/tiflow/cdc/processor/tablepb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MessageType int32

const (
	MsgUnknown               MessageType = 0
	MsgDispatchTableRequest  MessageType = 1
	MsgDispatchTableResponse MessageType = 2
	MsgHeartbeat             MessageType = 3
	MsgHeartbeatResponse     MessageType = 4
)

var MessageType_name = map[int32]string{
	0: "MsgUnknown",
	1: "MsgDispatchTableRequest",
	2: "MsgDispatchTableResponse",
	3: "MsgHeartbeat",
	4: "MsgHeartbeatResponse",
}

var MessageType_value = map[string]int32{
	"MsgUnknown":               0,
	"MsgDispatchTableRequest":  1,
	"MsgDispatchTableResponse": 2,
	"MsgHeartbeat":             3,
	"MsgHeartbeatResponse":     4,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{0}
}

type AddTableRequest struct {
	TableID     github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	Span        tablepb.Span                                `protobuf:"bytes,4,opt,name=span,proto3" json:"span"`
	IsSecondary bool                                        `protobuf:"varint,2,opt,name=is_secondary,json=isSecondary,proto3" json:"is_secondary,omitempty"`
	Checkpoint  tablepb.Checkpoint                          `protobuf:"bytes,3,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *AddTableRequest) Reset()         { *m = AddTableRequest{} }
func (m *AddTableRequest) String() string { return proto.CompactTextString(m) }
func (*AddTableRequest) ProtoMessage()    {}
func (*AddTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{0}
}
func (m *AddTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableRequest.Merge(m, src)
}
func (m *AddTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableRequest proto.InternalMessageInfo

func (m *AddTableRequest) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *AddTableRequest) GetSpan() tablepb.Span {
	if m != nil {
		return m.Span
	}
	return tablepb.Span{}
}

func (m *AddTableRequest) GetIsSecondary() bool {
	if m != nil {
		return m.IsSecondary
	}
	return false
}

func (m *AddTableRequest) GetCheckpoint() tablepb.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return tablepb.Checkpoint{}
}

type RemoveTableRequest struct {
	TableID github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	Span    tablepb.Span                                `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
}

func (m *RemoveTableRequest) Reset()         { *m = RemoveTableRequest{} }
func (m *RemoveTableRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveTableRequest) ProtoMessage()    {}
func (*RemoveTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{1}
}
func (m *RemoveTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableRequest.Merge(m, src)
}
func (m *RemoveTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableRequest proto.InternalMessageInfo

func (m *RemoveTableRequest) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *RemoveTableRequest) GetSpan() tablepb.Span {
	if m != nil {
		return m.Span
	}
	return tablepb.Span{}
}

type DispatchTableRequest struct {
	// Types that are valid to be assigned to Request:
	//	*DispatchTableRequest_AddTable
	//	*DispatchTableRequest_RemoveTable
	Request isDispatchTableRequest_Request `protobuf_oneof:"request"`
}

func (m *DispatchTableRequest) Reset()         { *m = DispatchTableRequest{} }
func (m *DispatchTableRequest) String() string { return proto.CompactTextString(m) }
func (*DispatchTableRequest) ProtoMessage()    {}
func (*DispatchTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{2}
}
func (m *DispatchTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchTableRequest.Merge(m, src)
}
func (m *DispatchTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *DispatchTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchTableRequest proto.InternalMessageInfo

type isDispatchTableRequest_Request interface {
	isDispatchTableRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispatchTableRequest_AddTable struct {
	AddTable *AddTableRequest `protobuf:"bytes,1,opt,name=add_table,json=addTable,proto3,oneof" json:"add_table,omitempty"`
}
type DispatchTableRequest_RemoveTable struct {
	RemoveTable *RemoveTableRequest `protobuf:"bytes,2,opt,name=remove_table,json=removeTable,proto3,oneof" json:"remove_table,omitempty"`
}

func (*DispatchTableRequest_AddTable) isDispatchTableRequest_Request()    {}
func (*DispatchTableRequest_RemoveTable) isDispatchTableRequest_Request() {}

func (m *DispatchTableRequest) GetRequest() isDispatchTableRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DispatchTableRequest) GetAddTable() *AddTableRequest {
	if x, ok := m.GetRequest().(*DispatchTableRequest_AddTable); ok {
		return x.AddTable
	}
	return nil
}

func (m *DispatchTableRequest) GetRemoveTable() *RemoveTableRequest {
	if x, ok := m.GetRequest().(*DispatchTableRequest_RemoveTable); ok {
		return x.RemoveTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispatchTableRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispatchTableRequest_AddTable)(nil),
		(*DispatchTableRequest_RemoveTable)(nil),
	}
}

type AddTableResponse struct {
	Status     *tablepb.TableStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Checkpoint tablepb.Checkpoint   `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *AddTableResponse) Reset()         { *m = AddTableResponse{} }
func (m *AddTableResponse) String() string { return proto.CompactTextString(m) }
func (*AddTableResponse) ProtoMessage()    {}
func (*AddTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{3}
}
func (m *AddTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableResponse.Merge(m, src)
}
func (m *AddTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableResponse proto.InternalMessageInfo

func (m *AddTableResponse) GetStatus() *tablepb.TableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AddTableResponse) GetCheckpoint() tablepb.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return tablepb.Checkpoint{}
}

type RemoveTableResponse struct {
	Status     *tablepb.TableStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Checkpoint tablepb.Checkpoint   `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *RemoveTableResponse) Reset()         { *m = RemoveTableResponse{} }
func (m *RemoveTableResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveTableResponse) ProtoMessage()    {}
func (*RemoveTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{4}
}
func (m *RemoveTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableResponse.Merge(m, src)
}
func (m *RemoveTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableResponse proto.InternalMessageInfo

func (m *RemoveTableResponse) GetStatus() *tablepb.TableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *RemoveTableResponse) GetCheckpoint() tablepb.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return tablepb.Checkpoint{}
}

type DispatchTableResponse struct {
	// Types that are valid to be assigned to Response:
	//
	//	*DispatchTableResponse_AddTable
	//	*DispatchTableResponse_RemoveTable
	Response isDispatchTableResponse_Response `protobuf_oneof:"response"`
}

func (m *DispatchTableResponse) Reset()         { *m = DispatchTableResponse{} }
func (m *DispatchTableResponse) String() string { return proto.CompactTextString(m) }
func (*DispatchTableResponse) ProtoMessage()    {}
func (*DispatchTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{5}
}
func (m *DispatchTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchTableResponse.Merge(m, src)
}
func (m *DispatchTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *DispatchTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchTableResponse proto.InternalMessageInfo

type isDispatchTableResponse_Response interface {
	isDispatchTableResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispatchTableResponse_AddTable struct {
	AddTable *AddTableResponse `protobuf:"bytes,1,opt,name=add_table,json=addTable,proto3,oneof" json:"add_table,omitempty"`
}
type DispatchTableResponse_RemoveTable struct {
	RemoveTable *RemoveTableResponse `protobuf:"bytes,2,opt,name=remove_table,json=removeTable,proto3,oneof" json:"remove_table,omitempty"`
}

func (*DispatchTableResponse_AddTable) isDispatchTableResponse_Response()    {}
func (*DispatchTableResponse_RemoveTable) isDispatchTableResponse_Response() {}

func (m *DispatchTableResponse) GetResponse() isDispatchTableResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *DispatchTableResponse) GetAddTable() *AddTableResponse {
	if x, ok := m.GetResponse().(*DispatchTableResponse_AddTable); ok {
		return x.AddTable
	}
	return nil
}

func (m *DispatchTableResponse) GetRemoveTable() *RemoveTableResponse {
	if x, ok := m.GetResponse().(*DispatchTableResponse_RemoveTable); ok {
		return x.RemoveTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispatchTableResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispatchTableResponse_AddTable)(nil),
		(*DispatchTableResponse_RemoveTable)(nil),
	}
}

type Heartbeat struct {
	TableIDs     []github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,rep,packed,name=table_ids,json=tableIds,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_ids,omitempty"`
	IsStopping   bool                                          `protobuf:"varint,2,opt,name=is_stopping,json=isStopping,proto3" json:"is_stopping,omitempty"`
	Spans        []tablepb.Span                                `protobuf:"bytes,3,rep,name=spans,proto3" json:"spans"`
	CollectStats bool                                          `protobuf:"varint,4,opt,name=collect_stats,json=collectStats,proto3" json:"collect_stats,omitempty"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{6}
}
func (m *Heartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Heartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Heartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Heartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Heartbeat.Merge(m, src)
}
func (m *Heartbeat) XXX_Size() int {
	return m.Size()
}
func (m *Heartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_Heartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_Heartbeat proto.InternalMessageInfo

func (m *Heartbeat) GetTableIDs() []github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableIDs
	}
	return nil
}

func (m *Heartbeat) GetIsStopping() bool {
	if m != nil {
		return m.IsStopping
	}
	return false
}

func (m *Heartbeat) GetSpans() []tablepb.Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *Heartbeat) GetCollectStats() bool {
	if m != nil {
		return m.CollectStats
	}
	return false
}

type HeartbeatResponse struct {
	Tables   []tablepb.TableStatus                        `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables"`
	Liveness github_com_pingcap_tiflow_cdc_model.Liveness `protobuf:"varint,2,opt,name=liveness,proto3,casttype=github.com/pingcap/tiflow/cdc/model.Liveness" json:"liveness,omitempty"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{7}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

func (m *HeartbeatResponse) GetTables() []tablepb.TableStatus {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *HeartbeatResponse) GetLiveness() github_com_pingcap_tiflow_cdc_model.Liveness {
	if m != nil {
		return m.Liveness
	}
	return 0
}

type OwnerRevision struct {
	Revision int64 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
}

func (m *OwnerRevision) Reset()         { *m = OwnerRevision{} }
func (m *OwnerRevision) String() string { return proto.CompactTextString(m) }
func (*OwnerRevision) ProtoMessage()    {}
func (*OwnerRevision) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{8}
}
func (m *OwnerRevision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerRevision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerRevision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerRevision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerRevision.Merge(m, src)
}
func (m *OwnerRevision) XXX_Size() int {
	return m.Size()
}
func (m *OwnerRevision) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerRevision.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerRevision proto.InternalMessageInfo

func (m *OwnerRevision) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

type ProcessorEpoch struct {
	Epoch string `protobuf:"bytes,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *ProcessorEpoch) Reset()         { *m = ProcessorEpoch{} }
func (m *ProcessorEpoch) String() string { return proto.CompactTextString(m) }
func (*ProcessorEpoch) ProtoMessage()    {}
func (*ProcessorEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{9}
}
func (m *ProcessorEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessorEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessorEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorEpoch.Merge(m, src)
}
func (m *ProcessorEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorEpoch proto.InternalMessageInfo

func (m *ProcessorEpoch) GetEpoch() string {
	if m != nil {
		return m.Epoch
	}
	return ""
}

type Message struct {
	Header                *Message_Header                               `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	MsgType               MessageType                                   `protobuf:"varint,2,opt,name=msg_type,json=msgType,proto3,enum=pingcap.tiflow.cdc.scheduler.schedulepb.MessageType" json:"msg_type,omitempty"`
	From                  github_com_pingcap_tiflow_cdc_model.CaptureID `protobuf:"bytes,3,opt,name=from,proto3,casttype=github.com/pingcap/tiflow/cdc/model.CaptureID" json:"from,omitempty"`
	To                    github_com_pingcap_tiflow_cdc_model.CaptureID `protobuf:"bytes,4,opt,name=to,proto3,casttype=github.com/pingcap/tiflow/cdc/model.CaptureID" json:"to,omitempty"`
	DispatchTableRequest  *DispatchTableRequest                         `protobuf:"bytes,5,opt,name=dispatch_table_request,json=dispatchTableRequest,proto3" json:"dispatch_table_request,omitempty"`
	DispatchTableResponse *DispatchTableResponse                        `protobuf:"bytes,6,opt,name=dispatch_table_response,json=dispatchTableResponse,proto3" json:"dispatch_table_response,omitempty"`
	Heartbeat             *Heartbeat                                    `protobuf:"bytes,7,opt,name=heartbeat,proto3" json:"heartbeat,omitempty"`
	HeartbeatResponse     *HeartbeatResponse                            `protobuf:"bytes,8,opt,name=heartbeat_response,json=heartbeatResponse,proto3" json:"heartbeat_response,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{10}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetHeader() *Message_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Message) GetMsgType() MessageType {
	if m != nil {
		return m.MsgType
	}
	return MsgUnknown
}

func (m *Message) GetFrom() github_com_pingcap_tiflow_cdc_model.CaptureID {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Message) GetTo() github_com_pingcap_tiflow_cdc_model.CaptureID {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Message) GetDispatchTableRequest() *DispatchTableRequest {
	if m != nil {
		return m.DispatchTableRequest
	}
	return nil
}

func (m *Message) GetDispatchTableResponse() *DispatchTableResponse {
	if m != nil {
		return m.DispatchTableResponse
	}
	return nil
}

func (m *Message) GetHeartbeat() *Heartbeat {
	if m != nil {
		return m.Heartbeat
	}
	return nil
}

func (m *Message) GetHeartbeatResponse() *HeartbeatResponse {
	if m != nil {
		return m.HeartbeatResponse
	}
	return nil
}

type Message_Header struct {
	// The semantic version of the node that sent this message.
	Version        string         `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	OwnerRevision  OwnerRevision  `protobuf:"bytes,2,opt,name=owner_revision,json=ownerRevision,proto3" json:"owner_revision"`
	ProcessorEpoch ProcessorEpoch `protobuf:"bytes,3,opt,name=processor_epoch,json=processorEpoch,proto3" json:"processor_epoch"`
}

func (m *Message_Header) Reset()         { *m = Message_Header{} }
func (m *Message_Header) String() string { return proto.CompactTextString(m) }
func (*Message_Header) ProtoMessage()    {}
func (*Message_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{10, 0}
}
func (m *Message_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message_Header.Merge(m, src)
}
func (m *Message_Header) XXX_Size() int {
	return m.Size()
}
func (m *Message_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Message_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Message_Header proto.InternalMessageInfo

func (m *Message_Header) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Message_Header) GetOwnerRevision() OwnerRevision {
	if m != nil {
		return m.OwnerRevision
	}
	return OwnerRevision{}
}

func (m *Message_Header) GetProcessorEpoch() ProcessorEpoch {
	if m != nil {
		return m.ProcessorEpoch
	}
	return ProcessorEpoch{}
}

func init() {
	proto.RegisterEnum("pingcap.tiflow.cdc.scheduler.schedulepb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*AddTableRequest)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.AddTableRequest")
	proto.RegisterType((*RemoveTableRequest)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.RemoveTableRequest")
	proto.RegisterType((*DispatchTableRequest)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.DispatchTableRequest")
	proto.RegisterType((*AddTableResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.AddTableResponse")
	proto.RegisterType((*RemoveTableResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.RemoveTableResponse")
	proto.RegisterType((*DispatchTableResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.DispatchTableResponse")
	proto.RegisterType((*Heartbeat)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Heartbeat")
	proto.RegisterType((*HeartbeatResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.HeartbeatResponse")
	proto.RegisterType((*OwnerRevision)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.OwnerRevision")
	proto.RegisterType((*ProcessorEpoch)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.ProcessorEpoch")
	proto.RegisterType((*Message)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Message")
	proto.RegisterType((*Message_Header)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Message.Header")
}

func init() {
	proto.RegisterFile("scheduler/schedulepb/table_schedule.proto", fileDescriptor_86eeacbf6ca5b996)
}

var fileDescriptor_86eeacbf6ca5b996 = []byte{
	// 1034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x5f, 0x6f, 0xdb, 0x54,
	0x14, 0x8f, 0x93, 0x34, 0x71, 0x4e, 0xda, 0x2c, 0xbb, 0x64, 0xcc, 0x0a, 0x90, 0x04, 0x23, 0x41,
	0xd9, 0xc0, 0xd9, 0x02, 0x82, 0xd1, 0x01, 0xd2, 0xb2, 0x0e, 0xb5, 0xd2, 0xaa, 0x56, 0xee, 0x06,
	0x88, 0x97, 0xe0, 0xd8, 0xb7, 0x8e, 0xb5, 0xc4, 0xd7, 0xf8, 0x3a, 0xa9, 0xfa, 0x15, 0xf2, 0xc4,
	0x17, 0xc8, 0x07, 0xe0, 0x11, 0x24, 0x24, 0x3e, 0xc2, 0x1e, 0xcb, 0x1b, 0x0f, 0x28, 0x1a, 0xe9,
	0x07, 0xe0, 0x81, 0xb7, 0xf2, 0x82, 0x7c, 0xef, 0x8d, 0xd3, 0xb4, 0x29, 0x72, 0x03, 0x42, 0xe2,
	0xed, 0xde, 0x73, 0x7c, 0x7e, 0xe7, 0x8f, 0x7f, 0xbf, 0x63, 0x19, 0xde, 0xa6, 0x66, 0x07, 0x5b,
	0xfd, 0x2e, 0xf6, 0xeb, 0xd3, 0x93, 0xd7, 0xae, 0x07, 0x46, 0xbb, 0x8b, 0x5b, 0x53, 0x83, 0xe6,
	0xf9, 0x24, 0x20, 0xe8, 0x2d, 0xcf, 0x71, 0x6d, 0xd3, 0xf0, 0xb4, 0xc0, 0x39, 0xe8, 0x92, 0x43,
	0xcd, 0xb4, 0x4c, 0x2d, 0x8a, 0xd6, 0x66, 0xd1, 0xe5, 0x92, 0x4d, 0x6c, 0xc2, 0x62, 0xea, 0xe1,
	0x89, 0x87, 0x97, 0x5f, 0xf3, 0x7c, 0x62, 0x62, 0x4a, 0x89, 0xcf, 0xe1, 0xa7, 0x69, 0xb8, 0x5b,
	0xfd, 0x2e, 0x09, 0xd7, 0x1e, 0x58, 0xd6, 0x93, 0xd0, 0xa4, 0xe3, 0x6f, 0xfa, 0x98, 0x06, 0xe8,
	0x29, 0xc8, 0xbc, 0x12, 0xc7, 0x52, 0xa4, 0x9a, 0xb4, 0x9e, 0x6a, 0x6e, 0x4c, 0xc6, 0xd5, 0x2c,
	0x7b, 0x66, 0x7b, 0xf3, 0x74, 0x5c, 0xbd, 0x6d, 0x3b, 0x41, 0xa7, 0xdf, 0xd6, 0x4c, 0xd2, 0xab,
	0x8b, 0xea, 0xea, 0xbc, 0xba, 0xba, 0x69, 0x99, 0xf5, 0x1e, 0xb1, 0x70, 0x57, 0x13, 0x8f, 0xeb,
	0x59, 0x86, 0xb5, 0x6d, 0xa1, 0x4d, 0x48, 0x53, 0xcf, 0x70, 0x95, 0x74, 0x4d, 0x5a, 0xcf, 0x37,
	0x6e, 0x69, 0x0b, 0xfa, 0x8a, 0x6a, 0xd5, 0x44, 0xad, 0xda, 0xbe, 0x67, 0xb8, 0xcd, 0xf4, 0xf3,
	0x71, 0x35, 0xa1, 0xb3, 0x68, 0xf4, 0x3a, 0xac, 0x3a, 0xb4, 0x45, 0xb1, 0x49, 0x5c, 0xcb, 0xf0,
	0x8f, 0x94, 0x64, 0x4d, 0x5a, 0x97, 0xf5, 0xbc, 0x43, 0xf7, 0xa7, 0x26, 0xf4, 0x39, 0x80, 0xd9,
	0xc1, 0xe6, 0x33, 0x8f, 0x38, 0x6e, 0xa0, 0xa4, 0x58, 0xba, 0x3b, 0xf1, 0xd2, 0x3d, 0x8c, 0xe2,
	0x44, 0xd2, 0x33, 0x48, 0xea, 0xf7, 0x12, 0x20, 0x1d, 0xf7, 0xc8, 0x00, 0xff, 0x97, 0xe3, 0x4a,
	0xfe, 0x93, 0x71, 0xa9, 0xbf, 0x4a, 0x50, 0xda, 0x74, 0xa8, 0x67, 0x04, 0x66, 0x67, 0xae, 0xea,
	0x2f, 0x20, 0x67, 0x58, 0x56, 0x8b, 0x05, 0xb2, 0xb2, 0xf3, 0x8d, 0x7b, 0x5a, 0x4c, 0xaa, 0x69,
	0xe7, 0x18, 0xb3, 0x95, 0xd0, 0x65, 0x43, 0x98, 0xd0, 0xd7, 0xb0, 0xea, 0xb3, 0x21, 0x09, 0x6c,
	0x5e, 0xff, 0xfd, 0xd8, 0xd8, 0x17, 0x27, 0xbc, 0x95, 0xd0, 0xf3, 0xfe, 0xcc, 0xda, 0xcc, 0x41,
	0xd6, 0xe7, 0x1e, 0xf5, 0x47, 0x09, 0x8a, 0xb3, 0x62, 0xa8, 0x47, 0x5c, 0x8a, 0xd1, 0x36, 0x64,
	0x68, 0x60, 0x04, 0x7d, 0x2a, 0xfa, 0xba, 0x1b, 0x6f, 0x76, 0x0c, 0x64, 0x9f, 0x05, 0xea, 0x02,
	0xe0, 0x1c, 0x95, 0x92, 0xff, 0x1a, 0x95, 0x7e, 0x92, 0xe0, 0xa5, 0xb9, 0x46, 0xff, 0x3f, 0xa5,
	0xbf, 0x90, 0xe0, 0xc6, 0x39, 0x46, 0x89, 0xe2, 0xbf, 0xbc, 0x48, 0xa9, 0x8f, 0x96, 0xa0, 0x14,
	0x47, 0x9b, 0xe3, 0x94, 0xb1, 0x90, 0x53, 0x1f, 0x2f, 0xc7, 0xa9, 0x08, 0x7f, 0x8e, 0x54, 0x00,
	0xb2, 0x2f, 0x5c, 0xea, 0x1f, 0x12, 0xe4, 0xb6, 0xb0, 0xe1, 0x07, 0x6d, 0x6c, 0x04, 0x61, 0x5b,
	0x53, 0x7d, 0x87, 0xaf, 0x25, 0xb5, 0x9e, 0x6a, 0xde, 0x9f, 0x8c, 0xab, 0xb2, 0x50, 0x2c, 0xbd,
	0xaa, 0xc2, 0x65, 0xa1, 0x70, 0x8a, 0xaa, 0x90, 0x0f, 0x77, 0x59, 0x40, 0xbc, 0x30, 0x48, 0xac,
	0x32, 0x70, 0xe8, 0xbe, 0xb0, 0xa0, 0xcf, 0x60, 0x25, 0x54, 0x31, 0x55, 0x52, 0xb5, 0xd4, 0x52,
	0x4b, 0x80, 0x87, 0xa3, 0x37, 0x60, 0xcd, 0x24, 0xdd, 0x2e, 0x36, 0x83, 0x56, 0xc8, 0x0e, 0xca,
	0x76, 0xb0, 0xac, 0xaf, 0x0a, 0x63, 0xc8, 0x1c, 0xaa, 0xfe, 0x20, 0xc1, 0xf5, 0xa8, 0xeb, 0xe8,
	0xa5, 0xee, 0x42, 0x86, 0xe1, 0xf2, 0xd6, 0x97, 0x61, 0xa4, 0x28, 0x45, 0xc0, 0xa0, 0xc7, 0x20,
	0x77, 0x9d, 0x01, 0x76, 0x31, 0xa5, 0xac, 0xe3, 0x95, 0xe6, 0x9d, 0xd3, 0x71, 0xf5, 0x9d, 0x38,
	0x13, 0x7c, 0x2c, 0xe2, 0xf4, 0x08, 0x41, 0xbd, 0x0d, 0x6b, 0xbb, 0x87, 0x2e, 0xf6, 0x75, 0x3c,
	0x70, 0xa8, 0x43, 0x5c, 0x54, 0x0e, 0xdf, 0x23, 0x3f, 0xf3, 0x6d, 0xac, 0x47, 0x77, 0xf5, 0x4d,
	0x28, 0xec, 0x4d, 0x2b, 0x7d, 0xe4, 0x11, 0xb3, 0x83, 0x4a, 0xb0, 0x82, 0xc3, 0x03, 0x7b, 0x34,
	0xa7, 0xf3, 0x8b, 0xfa, 0x73, 0x16, 0xb2, 0x3b, 0x98, 0x52, 0xc3, 0x66, 0xfd, 0x77, 0xb0, 0x61,
	0x61, 0x5f, 0x30, 0xfa, 0xc3, 0xd8, 0xa4, 0x13, 0x08, 0xda, 0x16, 0x0b, 0xd7, 0x05, 0x0c, 0xda,
	0x05, 0xb9, 0x47, 0xed, 0x56, 0x70, 0xe4, 0x71, 0x1e, 0x17, 0x1a, 0xef, 0x5f, 0x15, 0xf2, 0xc9,
	0x91, 0x87, 0xf5, 0x6c, 0x8f, 0xda, 0xe1, 0x01, 0x3d, 0x82, 0xf4, 0x81, 0x4f, 0x7a, 0xec, 0x43,
	0x97, 0x6b, 0xde, 0x3d, 0x1d, 0x57, 0xdf, 0x8d, 0x33, 0xcc, 0x87, 0x86, 0x17, 0xf4, 0xfd, 0x90,
	0x90, 0x2c, 0x1c, 0x3d, 0x80, 0x64, 0x40, 0x18, 0x31, 0x96, 0x02, 0x49, 0x06, 0x04, 0x51, 0x78,
	0xd9, 0x12, 0x9b, 0x81, 0x0b, 0xb5, 0x25, 0xf6, 0xb4, 0xb2, 0xc2, 0x66, 0xf7, 0x49, 0xec, 0x46,
	0x17, 0x7d, 0xb2, 0xf4, 0x92, 0xb5, 0xe8, 0x43, 0x36, 0x80, 0x9b, 0x17, 0x92, 0x72, 0xee, 0x2a,
	0x19, 0x96, 0xf5, 0xd3, 0x65, 0xb3, 0x72, 0x14, 0xfd, 0x86, 0xb5, 0x70, 0xdb, 0xed, 0x41, 0xae,
	0x33, 0x55, 0x8b, 0x92, 0x65, 0x99, 0x1a, 0xb1, 0x33, 0xcd, 0x74, 0x36, 0x03, 0x41, 0x0e, 0xa0,
	0xe8, 0x32, 0x6b, 0x42, 0x66, 0xd0, 0x1b, 0x4b, 0x40, 0x4f, 0x1b, 0xb8, 0xde, 0x39, 0x6f, 0x2a,
	0xff, 0x2e, 0x41, 0x86, 0xf3, 0x12, 0x29, 0x90, 0x1d, 0x60, 0x3f, 0xd2, 0x4b, 0x4e, 0x9f, 0x5e,
	0x91, 0x09, 0x05, 0x12, 0x6a, 0xab, 0x15, 0x09, 0x8a, 0xef, 0xdd, 0x0f, 0x62, 0xd7, 0x32, 0x27,
	0x4d, 0xb1, 0x07, 0xd6, 0xc8, 0x9c, 0x5e, 0x0f, 0xe0, 0x5a, 0xb4, 0x3d, 0x5a, 0x5c, 0x8b, 0xa9,
	0x2b, 0x0a, 0x6d, 0x5e, 0xd3, 0x22, 0x4d, 0xc1, 0x9b, 0xb3, 0xde, 0xfa, 0x53, 0x82, 0xfc, 0x19,
	0xf9, 0xa0, 0x0a, 0xc0, 0x0e, 0xb5, 0x9f, 0xba, 0xcf, 0x5c, 0x72, 0xe8, 0x16, 0x13, 0xe5, 0xc2,
	0x70, 0x54, 0x3b, 0x63, 0x41, 0xf7, 0xe0, 0xe6, 0x0e, 0xb5, 0x17, 0xf1, 0xb0, 0x28, 0x95, 0x5f,
	0x19, 0x8e, 0x6a, 0x97, 0xb9, 0xd1, 0x06, 0x28, 0x17, 0x5d, 0x7c, 0xee, 0xc5, 0x64, 0xf9, 0xd5,
	0xe1, 0xa8, 0x76, 0xa9, 0x1f, 0xa9, 0xb0, 0xba, 0x43, 0xed, 0xe8, 0x15, 0x16, 0x53, 0xe5, 0xe2,
	0x70, 0x54, 0x9b, 0xb3, 0xa1, 0x06, 0x94, 0xce, 0xde, 0x23, 0xec, 0x74, 0x59, 0x19, 0x8e, 0x6a,
	0x0b, 0x7d, 0xcd, 0xbd, 0xe3, 0xdf, 0x2a, 0x89, 0xe7, 0x93, 0x8a, 0x74, 0x3c, 0xa9, 0x48, 0x2f,
	0x26, 0x15, 0xe9, 0xdb, 0x93, 0x4a, 0xe2, 0xf8, 0xa4, 0x92, 0xf8, 0xe5, 0xa4, 0x92, 0xf8, 0xaa,
	0xf1, 0xf7, 0x52, 0x5f, 0xf4, 0xaf, 0xd2, 0xce, 0xb0, 0xff, 0x87, 0xf7, 0xfe, 0x0a, 0x00, 0x00,
	0xff, 0xff, 0xd4, 0x49, 0x41, 0x82, 0xca, 0x0c, 0x00, 0x00,
}

func (m *AddTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IsSecondary {
		i--
		if m.IsSecondary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableRequest_AddTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_AddTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTable != nil {
		{
			size, err := m.AddTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableRequest_RemoveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_RemoveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveTable != nil {
		{
			size, err := m.RemoveTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AddTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableResponse_AddTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse_AddTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTable != nil {
		{
			size, err := m.AddTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableResponse_RemoveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse_RemoveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveTable != nil {
		{
			size, err := m.RemoveTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CollectStats {
		i--
		if m.CollectStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsStopping {
		i--
		if m.IsStopping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TableIDs) > 0 {
		dAtA13 := make([]byte, len(m.TableIDs)*10)
		var j12 int
		for _, num1 := range m.TableIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintTableSchedule(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Liveness != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.Liveness))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OwnerRevision) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerRevision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerRevision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessorEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessorEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Epoch) > 0 {
		i -= len(m.Epoch)
		copy(dAtA[i:], m.Epoch)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.Epoch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeartbeatResponse != nil {
		{
			size, err := m.HeartbeatResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Heartbeat != nil {
		{
			size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DispatchTableResponse != nil {
		{
			size, err := m.DispatchTableResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DispatchTableRequest != nil {
		{
			size, err := m.DispatchTableRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgType != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ProcessorEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.OwnerRevision.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTableSchedule(dAtA []byte, offset int, v uint64) int {
	offset -= sovTableSchedule(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	if m.IsSecondary {
		n += 2
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	l = m.Span.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *RemoveTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	l = m.Span.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *DispatchTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *DispatchTableRequest_AddTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTable != nil {
		l = m.AddTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableRequest_RemoveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveTable != nil {
		l = m.RemoveTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *AddTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *RemoveTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *DispatchTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *DispatchTableResponse_AddTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTable != nil {
		l = m.AddTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableResponse_RemoveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveTable != nil {
		l = m.RemoveTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableIDs) > 0 {
		l = 0
		for _, e := range m.TableIDs {
			l += sovTableSchedule(uint64(e))
		}
		n += 1 + sovTableSchedule(uint64(l)) + l
	}
	if m.IsStopping {
		n += 2
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	if m.CollectStats {
		n += 2
	}
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	if m.Liveness != 0 {
		n += 1 + sovTableSchedule(uint64(m.Liveness))
	}
	return n
}

func (m *OwnerRevision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovTableSchedule(uint64(m.Revision))
	}
	return n
}

func (m *ProcessorEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Epoch)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovTableSchedule(uint64(m.MsgType))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.DispatchTableRequest != nil {
		l = m.DispatchTableRequest.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.DispatchTableResponse != nil {
		l = m.DispatchTableResponse.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.Heartbeat != nil {
		l = m.Heartbeat.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.HeartbeatResponse != nil {
		l = m.HeartbeatResponse.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *Message_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.OwnerRevision.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	l = m.ProcessorEpoch.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func sovTableSchedule(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTableSchedule(x uint64) (n int) {
	return sovTableSchedule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSecondary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSecondary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_AddTable{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_RemoveTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &tablepb.TableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &tablepb.TableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DispatchTableResponse_AddTable{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DispatchTableResponse_RemoveTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_pingcap_tiflow_cdc_model.TableID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTableSchedule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableIDs = append(m.TableIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTableSchedule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTableSchedule
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTableSchedule
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableIDs) == 0 {
					m.TableIDs = make([]github_com_pingcap_tiflow_cdc_model.TableID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_pingcap_tiflow_cdc_model.TableID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTableSchedule
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableIDs = append(m.TableIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStopping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStopping = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, tablepb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectStats = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, tablepb.TableStatus{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= github_com_pingcap_tiflow_cdc_model.Liveness(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerRevision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerRevision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerRevision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Epoch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Message_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = github_com_pingcap_tiflow_cdc_model.CaptureID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = github_com_pingcap_tiflow_cdc_model.CaptureID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispatchTableRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DispatchTableRequest == nil {
				m.DispatchTableRequest = &DispatchTableRequest{}
			}
			if err := m.DispatchTableRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispatchTableResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DispatchTableResponse == nil {
				m.DispatchTableResponse = &DispatchTableResponse{}
			}
			if err := m.DispatchTableResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Heartbeat == nil {
				m.Heartbeat = &Heartbeat{}
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatResponse == nil {
				m.HeartbeatResponse = &HeartbeatResponse{}
			}
			if err := m.HeartbeatResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerRevision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OwnerRevision.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessorEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTableSchedule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTableSchedule
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTableSchedule
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTableSchedule
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTableSchedule        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTableSchedule          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTableSchedule = fmt.Errorf("proto: unexpected end of group")
)
