// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: scheduler/schedulepb/table_schedule.proto

package schedulepb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_pingcap_tiflow_cdc_model "github.com/pingcap/tiflow/cdc/model"
	github_com_pingcap_tiflow_cdc_processor_tablepb "github.com/pingcap/tiflow/cdc/processor/tablepb"
	tablepb "github.com/pingcap/tiflow/cdc/processor/tablepb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MessageType int32

const (
	MsgUnknown               MessageType = 0
	MsgDispatchTableRequest  MessageType = 1
	MsgDispatchTableResponse MessageType = 2
	MsgHeartbeat             MessageType = 3
	MsgHeartbeatResponse     MessageType = 4
)

var MessageType_name = map[int32]string{
	0: "MsgUnknown",
	1: "MsgDispatchTableRequest",
	2: "MsgDispatchTableResponse",
	3: "MsgHeartbeat",
	4: "MsgHeartbeatResponse",
}

var MessageType_value = map[string]int32{
	"MsgUnknown":               0,
	"MsgDispatchTableRequest":  1,
	"MsgDispatchTableResponse": 2,
	"MsgHeartbeat":             3,
	"MsgHeartbeatResponse":     4,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{0}
}

type AddTableRequest struct {
	TableID     github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	Span        tablepb.Span                                `protobuf:"bytes,4,opt,name=span,proto3" json:"span"`
	IsSecondary bool                                        `protobuf:"varint,2,opt,name=is_secondary,json=isSecondary,proto3" json:"is_secondary,omitempty"`
	Checkpoint  tablepb.Checkpoint                          `protobuf:"bytes,3,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *AddTableRequest) Reset()         { *m = AddTableRequest{} }
func (m *AddTableRequest) String() string { return proto.CompactTextString(m) }
func (*AddTableRequest) ProtoMessage()    {}
func (*AddTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{0}
}
func (m *AddTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableRequest.Merge(m, src)
}
func (m *AddTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableRequest proto.InternalMessageInfo

func (m *AddTableRequest) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *AddTableRequest) GetSpan() tablepb.Span {
	if m != nil {
		return m.Span
	}
	return tablepb.Span{}
}

func (m *AddTableRequest) GetIsSecondary() bool {
	if m != nil {
		return m.IsSecondary
	}
	return false
}

func (m *AddTableRequest) GetCheckpoint() tablepb.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return tablepb.Checkpoint{}
}

type RemoveTableRequest struct {
	TableID github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	Span    tablepb.Span                                `protobuf:"bytes,2,opt,name=span,proto3" json:"span"`
}

func (m *RemoveTableRequest) Reset()         { *m = RemoveTableRequest{} }
func (m *RemoveTableRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveTableRequest) ProtoMessage()    {}
func (*RemoveTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{1}
}
func (m *RemoveTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableRequest.Merge(m, src)
}
func (m *RemoveTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableRequest proto.InternalMessageInfo

func (m *RemoveTableRequest) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *RemoveTableRequest) GetSpan() tablepb.Span {
	if m != nil {
		return m.Span
	}
	return tablepb.Span{}
}

type AddTableRequests struct {
	Requests []*AddTableRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests,omitempty"`
}

func (m *AddTableRequests) Reset()         { *m = AddTableRequests{} }
func (m *AddTableRequests) String() string { return proto.CompactTextString(m) }
func (*AddTableRequests) ProtoMessage()    {}
func (*AddTableRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{2}
}
func (m *AddTableRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableRequests.Merge(m, src)
}
func (m *AddTableRequests) XXX_Size() int {
	return m.Size()
}
func (m *AddTableRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableRequests.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableRequests proto.InternalMessageInfo

func (m *AddTableRequests) GetRequests() []*AddTableRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

type RemoveTableRequests struct {
	Requests []*RemoveTableRequest `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty"`
}

func (m *RemoveTableRequests) Reset()         { *m = RemoveTableRequests{} }
func (m *RemoveTableRequests) String() string { return proto.CompactTextString(m) }
func (*RemoveTableRequests) ProtoMessage()    {}
func (*RemoveTableRequests) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{3}
}
func (m *RemoveTableRequests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableRequests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableRequests.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableRequests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableRequests.Merge(m, src)
}
func (m *RemoveTableRequests) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableRequests) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableRequests.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableRequests proto.InternalMessageInfo

func (m *RemoveTableRequests) GetRequests() []*RemoveTableRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

type DispatchTableRequest struct {
	// Types that are valid to be assigned to Request:
	//	*DispatchTableRequest_AddTable
	//	*DispatchTableRequest_RemoveTable
	//	*DispatchTableRequest_BatchAdd
	//	*DispatchTableRequest_BatchRemove
	Request isDispatchTableRequest_Request `protobuf_oneof:"request"`
}

func (m *DispatchTableRequest) Reset()         { *m = DispatchTableRequest{} }
func (m *DispatchTableRequest) String() string { return proto.CompactTextString(m) }
func (*DispatchTableRequest) ProtoMessage()    {}
func (*DispatchTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{4}
}
func (m *DispatchTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchTableRequest.Merge(m, src)
}
func (m *DispatchTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *DispatchTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchTableRequest proto.InternalMessageInfo

type isDispatchTableRequest_Request interface {
	isDispatchTableRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispatchTableRequest_AddTable struct {
	AddTable *AddTableRequest `protobuf:"bytes,1,opt,name=add_table,json=addTable,proto3,oneof" json:"add_table,omitempty"`
}
type DispatchTableRequest_RemoveTable struct {
	RemoveTable *RemoveTableRequest `protobuf:"bytes,2,opt,name=remove_table,json=removeTable,proto3,oneof" json:"remove_table,omitempty"`
}
type DispatchTableRequest_BatchAdd struct {
	BatchAdd *AddTableRequests `protobuf:"bytes,3,opt,name=batch_add,json=batchAdd,proto3,oneof" json:"batch_add,omitempty"`
}
type DispatchTableRequest_BatchRemove struct {
	BatchRemove *RemoveTableRequests `protobuf:"bytes,4,opt,name=batch_remove,json=batchRemove,proto3,oneof" json:"batch_remove,omitempty"`
}

func (*DispatchTableRequest_AddTable) isDispatchTableRequest_Request()    {}
func (*DispatchTableRequest_RemoveTable) isDispatchTableRequest_Request() {}
func (*DispatchTableRequest_BatchAdd) isDispatchTableRequest_Request()    {}
func (*DispatchTableRequest_BatchRemove) isDispatchTableRequest_Request() {}

func (m *DispatchTableRequest) GetRequest() isDispatchTableRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DispatchTableRequest) GetAddTable() *AddTableRequest {
	if x, ok := m.GetRequest().(*DispatchTableRequest_AddTable); ok {
		return x.AddTable
	}
	return nil
}

func (m *DispatchTableRequest) GetRemoveTable() *RemoveTableRequest {
	if x, ok := m.GetRequest().(*DispatchTableRequest_RemoveTable); ok {
		return x.RemoveTable
	}
	return nil
}

func (m *DispatchTableRequest) GetBatchAdd() *AddTableRequests {
	if x, ok := m.GetRequest().(*DispatchTableRequest_BatchAdd); ok {
		return x.BatchAdd
	}
	return nil
}

func (m *DispatchTableRequest) GetBatchRemove() *RemoveTableRequests {
	if x, ok := m.GetRequest().(*DispatchTableRequest_BatchRemove); ok {
		return x.BatchRemove
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispatchTableRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispatchTableRequest_AddTable)(nil),
		(*DispatchTableRequest_RemoveTable)(nil),
		(*DispatchTableRequest_BatchAdd)(nil),
		(*DispatchTableRequest_BatchRemove)(nil),
	}
}

type AddTableResponse struct {
	Status     *tablepb.TableStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Checkpoint tablepb.Checkpoint   `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *AddTableResponse) Reset()         { *m = AddTableResponse{} }
func (m *AddTableResponse) String() string { return proto.CompactTextString(m) }
func (*AddTableResponse) ProtoMessage()    {}
func (*AddTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{5}
}
func (m *AddTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableResponse.Merge(m, src)
}
func (m *AddTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableResponse proto.InternalMessageInfo

func (m *AddTableResponse) GetStatus() *tablepb.TableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AddTableResponse) GetCheckpoint() tablepb.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return tablepb.Checkpoint{}
}

type RemoveTableResponse struct {
	Status     *tablepb.TableStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Checkpoint tablepb.Checkpoint   `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *RemoveTableResponse) Reset()         { *m = RemoveTableResponse{} }
func (m *RemoveTableResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveTableResponse) ProtoMessage()    {}
func (*RemoveTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{6}
}
func (m *RemoveTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableResponse.Merge(m, src)
}
func (m *RemoveTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableResponse proto.InternalMessageInfo

func (m *RemoveTableResponse) GetStatus() *tablepb.TableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *RemoveTableResponse) GetCheckpoint() tablepb.Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return tablepb.Checkpoint{}
}

type DispatchTableResponse struct {
	// Types that are valid to be assigned to Response:
	//
	//	*DispatchTableResponse_AddTable
	//	*DispatchTableResponse_RemoveTable
	Response isDispatchTableResponse_Response `protobuf_oneof:"response"`
}

func (m *DispatchTableResponse) Reset()         { *m = DispatchTableResponse{} }
func (m *DispatchTableResponse) String() string { return proto.CompactTextString(m) }
func (*DispatchTableResponse) ProtoMessage()    {}
func (*DispatchTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{7}
}
func (m *DispatchTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchTableResponse.Merge(m, src)
}
func (m *DispatchTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *DispatchTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchTableResponse proto.InternalMessageInfo

type isDispatchTableResponse_Response interface {
	isDispatchTableResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispatchTableResponse_AddTable struct {
	AddTable *AddTableResponse `protobuf:"bytes,1,opt,name=add_table,json=addTable,proto3,oneof" json:"add_table,omitempty"`
}
type DispatchTableResponse_RemoveTable struct {
	RemoveTable *RemoveTableResponse `protobuf:"bytes,2,opt,name=remove_table,json=removeTable,proto3,oneof" json:"remove_table,omitempty"`
}

func (*DispatchTableResponse_AddTable) isDispatchTableResponse_Response()    {}
func (*DispatchTableResponse_RemoveTable) isDispatchTableResponse_Response() {}

func (m *DispatchTableResponse) GetResponse() isDispatchTableResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *DispatchTableResponse) GetAddTable() *AddTableResponse {
	if x, ok := m.GetResponse().(*DispatchTableResponse_AddTable); ok {
		return x.AddTable
	}
	return nil
}

func (m *DispatchTableResponse) GetRemoveTable() *RemoveTableResponse {
	if x, ok := m.GetResponse().(*DispatchTableResponse_RemoveTable); ok {
		return x.RemoveTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispatchTableResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispatchTableResponse_AddTable)(nil),
		(*DispatchTableResponse_RemoveTable)(nil),
	}
}

type TableBarrier struct {
	TableID github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	// The barrier timestamp of the table.
	BarrierTs github_com_pingcap_tiflow_cdc_processor_tablepb.Ts `protobuf:"varint,2,opt,name=barrier_ts,json=barrierTs,proto3,casttype=github.com/pingcap/tiflow/cdc/processor/tablepb.Ts" json:"barrier_ts,omitempty"`
}

func (m *TableBarrier) Reset()         { *m = TableBarrier{} }
func (m *TableBarrier) String() string { return proto.CompactTextString(m) }
func (*TableBarrier) ProtoMessage()    {}
func (*TableBarrier) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{8}
}
func (m *TableBarrier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableBarrier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableBarrier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableBarrier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableBarrier.Merge(m, src)
}
func (m *TableBarrier) XXX_Size() int {
	return m.Size()
}
func (m *TableBarrier) XXX_DiscardUnknown() {
	xxx_messageInfo_TableBarrier.DiscardUnknown(m)
}

var xxx_messageInfo_TableBarrier proto.InternalMessageInfo

func (m *TableBarrier) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *TableBarrier) GetBarrierTs() github_com_pingcap_tiflow_cdc_processor_tablepb.Ts {
	if m != nil {
		return m.BarrierTs
	}
	return 0
}

// Barrier contains the barrierTs of those tables that have
// ddl jobs that need to be replicated. The Scheduler will
// broadcast the barrierTs to all captures through the Heartbeat.
type Barrier struct {
	TableBarriers   []*TableBarrier                                    `protobuf:"bytes,1,rep,name=table_barriers,json=tableBarriers,proto3" json:"table_barriers,omitempty"`
	GlobalBarrierTs github_com_pingcap_tiflow_cdc_processor_tablepb.Ts `protobuf:"varint,2,opt,name=global_barrier_ts,json=globalBarrierTs,proto3,casttype=github.com/pingcap/tiflow/cdc/processor/tablepb.Ts" json:"global_barrier_ts,omitempty"`
}

func (m *Barrier) Reset()         { *m = Barrier{} }
func (m *Barrier) String() string { return proto.CompactTextString(m) }
func (*Barrier) ProtoMessage()    {}
func (*Barrier) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{9}
}
func (m *Barrier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Barrier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Barrier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Barrier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Barrier.Merge(m, src)
}
func (m *Barrier) XXX_Size() int {
	return m.Size()
}
func (m *Barrier) XXX_DiscardUnknown() {
	xxx_messageInfo_Barrier.DiscardUnknown(m)
}

var xxx_messageInfo_Barrier proto.InternalMessageInfo

func (m *Barrier) GetTableBarriers() []*TableBarrier {
	if m != nil {
		return m.TableBarriers
	}
	return nil
}

func (m *Barrier) GetGlobalBarrierTs() github_com_pingcap_tiflow_cdc_processor_tablepb.Ts {
	if m != nil {
		return m.GlobalBarrierTs
	}
	return 0
}

type Heartbeat struct {
	TableIDs     []github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,rep,packed,name=table_ids,json=tableIds,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_ids,omitempty"`
	IsStopping   bool                                          `protobuf:"varint,2,opt,name=is_stopping,json=isStopping,proto3" json:"is_stopping,omitempty"`
	Spans        []tablepb.Span                                `protobuf:"bytes,3,rep,name=spans,proto3" json:"spans"`
	CollectStats bool                                          `protobuf:"varint,4,opt,name=collect_stats,json=collectStats,proto3" json:"collect_stats,omitempty"`
	Barrier      *Barrier                                      `protobuf:"bytes,5,opt,name=barrier,proto3" json:"barrier,omitempty"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{10}
}
func (m *Heartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Heartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Heartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Heartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Heartbeat.Merge(m, src)
}
func (m *Heartbeat) XXX_Size() int {
	return m.Size()
}
func (m *Heartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_Heartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_Heartbeat proto.InternalMessageInfo

func (m *Heartbeat) GetTableIDs() []github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableIDs
	}
	return nil
}

func (m *Heartbeat) GetIsStopping() bool {
	if m != nil {
		return m.IsStopping
	}
	return false
}

func (m *Heartbeat) GetSpans() []tablepb.Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *Heartbeat) GetCollectStats() bool {
	if m != nil {
		return m.CollectStats
	}
	return false
}

func (m *Heartbeat) GetBarrier() *Barrier {
	if m != nil {
		return m.Barrier
	}
	return nil
}

type HeartbeatResponse struct {
	Tables   []tablepb.TableStatus                        `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables"`
	Liveness github_com_pingcap_tiflow_cdc_model.Liveness `protobuf:"varint,2,opt,name=liveness,proto3,casttype=github.com/pingcap/tiflow/cdc/model.Liveness" json:"liveness,omitempty"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{11}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

func (m *HeartbeatResponse) GetTables() []tablepb.TableStatus {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *HeartbeatResponse) GetLiveness() github_com_pingcap_tiflow_cdc_model.Liveness {
	if m != nil {
		return m.Liveness
	}
	return 0
}

type OwnerRevision struct {
	Revision int64 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
}

func (m *OwnerRevision) Reset()         { *m = OwnerRevision{} }
func (m *OwnerRevision) String() string { return proto.CompactTextString(m) }
func (*OwnerRevision) ProtoMessage()    {}
func (*OwnerRevision) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{12}
}
func (m *OwnerRevision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerRevision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerRevision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerRevision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerRevision.Merge(m, src)
}
func (m *OwnerRevision) XXX_Size() int {
	return m.Size()
}
func (m *OwnerRevision) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerRevision.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerRevision proto.InternalMessageInfo

func (m *OwnerRevision) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

type ProcessorEpoch struct {
	Epoch string `protobuf:"bytes,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *ProcessorEpoch) Reset()         { *m = ProcessorEpoch{} }
func (m *ProcessorEpoch) String() string { return proto.CompactTextString(m) }
func (*ProcessorEpoch) ProtoMessage()    {}
func (*ProcessorEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{13}
}
func (m *ProcessorEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessorEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessorEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorEpoch.Merge(m, src)
}
func (m *ProcessorEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorEpoch proto.InternalMessageInfo

func (m *ProcessorEpoch) GetEpoch() string {
	if m != nil {
		return m.Epoch
	}
	return ""
}

type ChangefeedEpoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *ChangefeedEpoch) Reset()         { *m = ChangefeedEpoch{} }
func (m *ChangefeedEpoch) String() string { return proto.CompactTextString(m) }
func (*ChangefeedEpoch) ProtoMessage()    {}
func (*ChangefeedEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{14}
}
func (m *ChangefeedEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangefeedEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangefeedEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangefeedEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangefeedEpoch.Merge(m, src)
}
func (m *ChangefeedEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ChangefeedEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangefeedEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ChangefeedEpoch proto.InternalMessageInfo

func (m *ChangefeedEpoch) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

type Message struct {
	Header                *Message_Header                               `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	MsgType               MessageType                                   `protobuf:"varint,2,opt,name=msg_type,json=msgType,proto3,enum=pingcap.tiflow.cdc.scheduler.schedulepb.MessageType" json:"msg_type,omitempty"`
	From                  github_com_pingcap_tiflow_cdc_model.CaptureID `protobuf:"bytes,3,opt,name=from,proto3,casttype=github.com/pingcap/tiflow/cdc/model.CaptureID" json:"from,omitempty"`
	To                    github_com_pingcap_tiflow_cdc_model.CaptureID `protobuf:"bytes,4,opt,name=to,proto3,casttype=github.com/pingcap/tiflow/cdc/model.CaptureID" json:"to,omitempty"`
	DispatchTableRequest  *DispatchTableRequest                         `protobuf:"bytes,5,opt,name=dispatch_table_request,json=dispatchTableRequest,proto3" json:"dispatch_table_request,omitempty"`
	DispatchTableResponse *DispatchTableResponse                        `protobuf:"bytes,6,opt,name=dispatch_table_response,json=dispatchTableResponse,proto3" json:"dispatch_table_response,omitempty"`
	Heartbeat             *Heartbeat                                    `protobuf:"bytes,7,opt,name=heartbeat,proto3" json:"heartbeat,omitempty"`
	HeartbeatResponse     *HeartbeatResponse                            `protobuf:"bytes,8,opt,name=heartbeat_response,json=heartbeatResponse,proto3" json:"heartbeat_response,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{15}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetHeader() *Message_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Message) GetMsgType() MessageType {
	if m != nil {
		return m.MsgType
	}
	return MsgUnknown
}

func (m *Message) GetFrom() github_com_pingcap_tiflow_cdc_model.CaptureID {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Message) GetTo() github_com_pingcap_tiflow_cdc_model.CaptureID {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Message) GetDispatchTableRequest() *DispatchTableRequest {
	if m != nil {
		return m.DispatchTableRequest
	}
	return nil
}

func (m *Message) GetDispatchTableResponse() *DispatchTableResponse {
	if m != nil {
		return m.DispatchTableResponse
	}
	return nil
}

func (m *Message) GetHeartbeat() *Heartbeat {
	if m != nil {
		return m.Heartbeat
	}
	return nil
}

func (m *Message) GetHeartbeatResponse() *HeartbeatResponse {
	if m != nil {
		return m.HeartbeatResponse
	}
	return nil
}

type Message_Header struct {
	// The semantic version of the node that sent this message.
	Version         string          `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	OwnerRevision   OwnerRevision   `protobuf:"bytes,2,opt,name=owner_revision,json=ownerRevision,proto3" json:"owner_revision"`
	ProcessorEpoch  ProcessorEpoch  `protobuf:"bytes,3,opt,name=processor_epoch,json=processorEpoch,proto3" json:"processor_epoch"`
	ChangefeedEpoch ChangefeedEpoch `protobuf:"bytes,4,opt,name=changefeed_epoch,json=changefeedEpoch,proto3" json:"changefeed_epoch"`
}

func (m *Message_Header) Reset()         { *m = Message_Header{} }
func (m *Message_Header) String() string { return proto.CompactTextString(m) }
func (*Message_Header) ProtoMessage()    {}
func (*Message_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_86eeacbf6ca5b996, []int{15, 0}
}
func (m *Message_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message_Header.Merge(m, src)
}
func (m *Message_Header) XXX_Size() int {
	return m.Size()
}
func (m *Message_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Message_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Message_Header proto.InternalMessageInfo

func (m *Message_Header) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Message_Header) GetOwnerRevision() OwnerRevision {
	if m != nil {
		return m.OwnerRevision
	}
	return OwnerRevision{}
}

func (m *Message_Header) GetProcessorEpoch() ProcessorEpoch {
	if m != nil {
		return m.ProcessorEpoch
	}
	return ProcessorEpoch{}
}

func (m *Message_Header) GetChangefeedEpoch() ChangefeedEpoch {
	if m != nil {
		return m.ChangefeedEpoch
	}
	return ChangefeedEpoch{}
}

func init() {
	proto.RegisterEnum("pingcap.tiflow.cdc.scheduler.schedulepb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*AddTableRequest)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.AddTableRequest")
	proto.RegisterType((*RemoveTableRequest)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.RemoveTableRequest")
	proto.RegisterType((*AddTableRequests)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.AddTableRequests")
	proto.RegisterType((*RemoveTableRequests)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.RemoveTableRequests")
	proto.RegisterType((*DispatchTableRequest)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.DispatchTableRequest")
	proto.RegisterType((*AddTableResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.AddTableResponse")
	proto.RegisterType((*RemoveTableResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.RemoveTableResponse")
	proto.RegisterType((*DispatchTableResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.DispatchTableResponse")
	proto.RegisterType((*TableBarrier)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.TableBarrier")
	proto.RegisterType((*Barrier)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Barrier")
	proto.RegisterType((*Heartbeat)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Heartbeat")
	proto.RegisterType((*HeartbeatResponse)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.HeartbeatResponse")
	proto.RegisterType((*OwnerRevision)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.OwnerRevision")
	proto.RegisterType((*ProcessorEpoch)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.ProcessorEpoch")
	proto.RegisterType((*ChangefeedEpoch)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.ChangefeedEpoch")
	proto.RegisterType((*Message)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Message")
	proto.RegisterType((*Message_Header)(nil), "pingcap.tiflow.cdc.scheduler.schedulepb.Message.Header")
}

func init() {
	proto.RegisterFile("scheduler/schedulepb/table_schedule.proto", fileDescriptor_86eeacbf6ca5b996)
}

var fileDescriptor_86eeacbf6ca5b996 = []byte{
	// 1247 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xf7, 0xda, 0x4e, 0x6c, 0x3f, 0x3b, 0x8e, 0x3b, 0xdf, 0xf4, 0xdb, 0x95, 0x01, 0xdb, 0x2c,
	0x12, 0x0d, 0x2d, 0xac, 0x5b, 0x03, 0xa5, 0xb4, 0x80, 0x54, 0x27, 0x45, 0x09, 0x6a, 0x94, 0x68,
	0x93, 0xd0, 0x0a, 0x21, 0x99, 0xf5, 0xee, 0x64, 0xbd, 0xaa, 0xbd, 0xb3, 0xec, 0x6c, 0x12, 0xe5,
	0x5f, 0xc8, 0x89, 0x2b, 0x87, 0xfc, 0x01, 0x1c, 0x41, 0x42, 0xe2, 0x50, 0x89, 0x6b, 0x25, 0x2e,
	0x39, 0x22, 0x0e, 0x56, 0x49, 0xfe, 0x8b, 0x70, 0x41, 0x3b, 0x33, 0xbb, 0xf1, 0xaf, 0x80, 0xed,
	0x14, 0x24, 0x6e, 0x33, 0x6f, 0xe6, 0x7d, 0xde, 0xcf, 0xcf, 0x9b, 0xd5, 0xc2, 0x5b, 0xd4, 0x68,
	0x61, 0x73, 0xb7, 0x8d, 0xbd, 0x6a, 0xb8, 0x72, 0x9b, 0x55, 0x5f, 0x6f, 0xb6, 0x71, 0x23, 0x14,
	0xa8, 0xae, 0x47, 0x7c, 0x82, 0xae, 0xbb, 0xb6, 0x63, 0x19, 0xba, 0xab, 0xfa, 0xf6, 0x4e, 0x9b,
	0xec, 0xab, 0x86, 0x69, 0xa8, 0x91, 0xb6, 0x7a, 0xae, 0x5d, 0x5c, 0xb0, 0x88, 0x45, 0x98, 0x4e,
	0x35, 0x58, 0x71, 0xf5, 0xe2, 0x6b, 0xae, 0x47, 0x0c, 0x4c, 0x29, 0xf1, 0x38, 0x7c, 0x68, 0x86,
	0x1f, 0x2b, 0xdf, 0xc5, 0x61, 0xfe, 0x81, 0x69, 0x6e, 0x05, 0x22, 0x0d, 0x7f, 0xbd, 0x8b, 0xa9,
	0x8f, 0xb6, 0x21, 0xcd, 0x3d, 0xb1, 0x4d, 0x59, 0xaa, 0x48, 0x8b, 0x89, 0xfa, 0xbd, 0x93, 0x6e,
	0x39, 0xc5, 0xee, 0xac, 0x2e, 0x9f, 0x75, 0xcb, 0x37, 0x2d, 0xdb, 0x6f, 0xed, 0x36, 0x55, 0x83,
	0x74, 0xaa, 0xc2, 0xbb, 0x2a, 0xf7, 0xae, 0x6a, 0x98, 0x46, 0xb5, 0x43, 0x4c, 0xdc, 0x56, 0xc5,
	0x75, 0x2d, 0xc5, 0xb0, 0x56, 0x4d, 0xb4, 0x0c, 0x49, 0xea, 0xea, 0x8e, 0x9c, 0xac, 0x48, 0x8b,
	0xd9, 0xda, 0x0d, 0x75, 0x44, 0x5c, 0x91, 0xaf, 0xaa, 0xf0, 0x55, 0xdd, 0x74, 0x75, 0xa7, 0x9e,
	0x7c, 0xde, 0x2d, 0xc7, 0x34, 0xa6, 0x8d, 0x5e, 0x87, 0x9c, 0x4d, 0x1b, 0x14, 0x1b, 0xc4, 0x31,
	0x75, 0xef, 0x40, 0x8e, 0x57, 0xa4, 0xc5, 0xb4, 0x96, 0xb5, 0xe9, 0x66, 0x28, 0x42, 0x9f, 0x03,
	0x18, 0x2d, 0x6c, 0x3c, 0x75, 0x89, 0xed, 0xf8, 0x72, 0x82, 0x99, 0xbb, 0x35, 0x9e, 0xb9, 0xa5,
	0x48, 0x4f, 0x18, 0xed, 0x41, 0x52, 0xbe, 0x97, 0x00, 0x69, 0xb8, 0x43, 0xf6, 0xf0, 0xbf, 0x99,
	0xae, 0xf8, 0x65, 0xd2, 0xa5, 0xb4, 0xa0, 0x30, 0x50, 0x5e, 0x8a, 0xb6, 0x20, 0xed, 0x89, 0xb5,
	0x2c, 0x55, 0x12, 0x8b, 0xd9, 0xda, 0x5d, 0x75, 0xcc, 0x26, 0x53, 0x07, 0xc0, 0xb4, 0x08, 0x49,
	0x71, 0xe0, 0x7f, 0xc3, 0xc9, 0xa1, 0xe8, 0x71, 0x8f, 0xb1, 0x38, 0x33, 0x76, 0x7f, 0x6c, 0x63,
	0xc3, 0x78, 0x3d, 0xf6, 0xbe, 0x4d, 0xc0, 0xc2, 0xb2, 0x4d, 0x5d, 0xdd, 0x37, 0x5a, 0x7d, 0xf5,
	0x78, 0x0c, 0x19, 0xdd, 0x34, 0x1b, 0x2c, 0x25, 0xac, 0x20, 0x97, 0x88, 0x6f, 0x25, 0xa6, 0xa5,
	0x75, 0x21, 0x42, 0x5f, 0x41, 0xce, 0x63, 0x1e, 0x09, 0x6c, 0x5e, 0x99, 0xcb, 0x84, 0xb3, 0x12,
	0xd3, 0xb2, 0xde, 0xb9, 0x14, 0x3d, 0x81, 0x4c, 0x33, 0x88, 0xa7, 0xa1, 0x9b, 0xa6, 0x68, 0xdc,
	0x0f, 0xa7, 0x75, 0x9d, 0x06, 0xbe, 0x33, 0xb4, 0x07, 0xa6, 0x89, 0x74, 0xc8, 0x71, 0x64, 0x6e,
	0x4e, 0x90, 0xf0, 0xa3, 0x4b, 0xf8, 0x1e, 0xe0, 0x67, 0x19, 0x26, 0x3f, 0xab, 0x67, 0x20, 0x25,
	0x8a, 0xa3, 0xfc, 0x28, 0xf5, 0xb6, 0x1d, 0x75, 0x89, 0x43, 0x31, 0x5a, 0x85, 0x59, 0xea, 0xeb,
	0xfe, 0x2e, 0x15, 0x45, 0xb9, 0x3d, 0x5e, 0x4b, 0x33, 0x90, 0x4d, 0xa6, 0xa8, 0x09, 0x80, 0x01,
	0x86, 0xc7, 0x5f, 0x1a, 0xc3, 0x7f, 0x92, 0x06, 0x9a, 0xf8, 0xbf, 0xe3, 0xfa, 0x0b, 0x09, 0xae,
	0x0e, 0xd0, 0x41, 0x38, 0xff, 0x64, 0x98, 0x0f, 0xd3, 0x34, 0x15, 0x47, 0xeb, 0x23, 0x84, 0x3e,
	0x92, 0x10, 0x53, 0x36, 0x55, 0x84, 0xdf, 0xcb, 0x88, 0x3a, 0x04, 0xe3, 0x83, 0x1f, 0x29, 0xcf,
	0x24, 0xc8, 0x71, 0xa9, 0xee, 0x79, 0x36, 0xf6, 0xfe, 0xa9, 0xc9, 0xbb, 0x0d, 0xd0, 0xe4, 0x16,
	0x1a, 0x6c, 0x68, 0x49, 0x8b, 0xc9, 0xfa, 0x9d, 0xb3, 0x6e, 0xb9, 0xf6, 0xd7, 0x68, 0x43, 0x0f,
	0xad, 0xba, 0x45, 0xb5, 0x8c, 0x40, 0xda, 0xa2, 0xca, 0x2f, 0x12, 0xa4, 0x42, 0xcf, 0xbf, 0x84,
	0x3c, 0xf7, 0x5c, 0x1c, 0x87, 0x83, 0xf8, 0xfd, 0xb1, 0x73, 0xd7, 0x9b, 0x08, 0x6d, 0xce, 0xef,
	0xd9, 0x51, 0xd4, 0x84, 0x2b, 0x56, 0x9b, 0x34, 0xf5, 0x76, 0xe3, 0xa5, 0xc5, 0x31, 0xcf, 0x01,
	0xeb, 0x51, 0x34, 0x3f, 0xc7, 0x21, 0xb3, 0x82, 0x75, 0xcf, 0x6f, 0x62, 0xdd, 0x0f, 0x7a, 0x2c,
	0xac, 0x04, 0x0f, 0x25, 0x51, 0xbf, 0x7f, 0xd2, 0x2d, 0xa7, 0x45, 0x6e, 0xe9, 0xa4, 0xb5, 0x48,
	0x8b, 0x5a, 0x50, 0x54, 0x86, 0x6c, 0xf0, 0xde, 0xfb, 0xc4, 0x0d, 0x94, 0xc4, 0x73, 0x0f, 0x36,
	0xdd, 0x14, 0x12, 0xf4, 0x29, 0xcc, 0x04, 0x2f, 0x1d, 0x95, 0x13, 0x2c, 0x83, 0x93, 0x3f, 0x94,
	0x5c, 0x1d, 0xbd, 0x01, 0x73, 0x06, 0x69, 0xb7, 0xb1, 0xe1, 0x37, 0x02, 0xaa, 0x52, 0x36, 0x22,
	0xd3, 0x5a, 0x4e, 0x08, 0x03, 0x1a, 0x53, 0xf4, 0x19, 0xa4, 0x44, 0x4a, 0xe5, 0x99, 0x8b, 0xa9,
	0x3b, 0xb2, 0x60, 0x61, 0xad, 0x42, 0x00, 0xe5, 0x07, 0x09, 0xae, 0x44, 0x19, 0x8c, 0xd8, 0xba,
	0x0e, 0xb3, 0xcc, 0xc7, 0xb0, 0x23, 0x26, 0x1f, 0x35, 0x22, 0x2c, 0x01, 0x83, 0x1e, 0x41, 0xba,
	0x6d, 0xef, 0x61, 0x07, 0x53, 0xde, 0x03, 0x33, 0xf5, 0x5b, 0x67, 0xdd, 0xf2, 0xdb, 0xe3, 0x54,
	0xe3, 0x91, 0xd0, 0xd3, 0x22, 0x04, 0xe5, 0x26, 0xcc, 0xad, 0xef, 0x3b, 0xd8, 0xd3, 0xf0, 0x9e,
	0x4d, 0x6d, 0xe2, 0xa0, 0x62, 0x40, 0x50, 0xbe, 0xe6, 0x1c, 0xd4, 0xa2, 0xbd, 0xf2, 0x26, 0xe4,
	0x37, 0x42, 0x4f, 0x1f, 0xba, 0xc4, 0x68, 0xa1, 0x05, 0x98, 0xc1, 0xc1, 0x82, 0x5d, 0xcd, 0x68,
	0x7c, 0xa3, 0x5c, 0x87, 0xf9, 0xa5, 0x96, 0xee, 0x58, 0x78, 0x07, 0x63, 0x73, 0xc4, 0xc5, 0x64,
	0x78, 0xf1, 0x59, 0x1a, 0x52, 0x6b, 0x98, 0x52, 0xdd, 0x62, 0x89, 0x6a, 0x61, 0xdd, 0xc4, 0x9e,
	0x98, 0x69, 0x1f, 0x8c, 0x5d, 0x09, 0x81, 0xa0, 0xae, 0x30, 0x75, 0x4d, 0xc0, 0xa0, 0x75, 0x48,
	0x77, 0xa8, 0xd5, 0xf0, 0x0f, 0x5c, 0x3e, 0xc9, 0xf2, 0xb5, 0xf7, 0x26, 0x85, 0xdc, 0x3a, 0x70,
	0xb1, 0x96, 0xea, 0x50, 0x2b, 0x58, 0xa0, 0x87, 0x90, 0xdc, 0xf1, 0x48, 0x87, 0x3d, 0xe4, 0x99,
	0xfa, 0xed, 0xb3, 0x6e, 0xf9, 0x9d, 0x71, 0xb2, 0xbe, 0xa4, 0xbb, 0xfe, 0xae, 0x17, 0xb0, 0x80,
	0xa9, 0xa3, 0x07, 0x10, 0xf7, 0x09, 0xeb, 0xc6, 0xa9, 0x40, 0xe2, 0x3e, 0x41, 0x14, 0xfe, 0x6f,
	0x8a, 0xb7, 0x81, 0x8f, 0xea, 0x86, 0x78, 0xa9, 0x45, 0x17, 0x7f, 0x3c, 0x76, 0xa0, 0xa3, 0xbe,
	0xb8, 0xb4, 0x05, 0x73, 0xd4, 0x77, 0xd8, 0x1e, 0x5c, 0x1b, 0x32, 0xca, 0x9b, 0x5c, 0x9e, 0x65,
	0x56, 0x3f, 0x99, 0xd6, 0x2a, 0x47, 0xd1, 0xae, 0x9a, 0x23, 0xdf, 0xbb, 0x0d, 0xc8, 0xb4, 0x42,
	0x5a, 0xc9, 0x29, 0x66, 0xa9, 0x36, 0xb6, 0xa5, 0x73, 0x42, 0x9e, 0x83, 0x20, 0x1b, 0x50, 0xb4,
	0x39, 0x0f, 0x22, 0xcd, 0xa0, 0xef, 0x4d, 0x01, 0x1d, 0x06, 0x70, 0xa5, 0x35, 0x28, 0x2a, 0xfe,
	0x16, 0x87, 0x59, 0xde, 0x97, 0x48, 0x86, 0xd4, 0x1e, 0xf6, 0x22, 0x62, 0x65, 0xb4, 0x70, 0x8b,
	0x0c, 0xc8, 0x93, 0x80, 0x84, 0x8d, 0x88, 0x79, 0xfc, 0xe5, 0xbd, 0x33, 0xb6, 0x2f, 0x7d, 0x1c,
	0x16, 0x03, 0x63, 0x8e, 0xf4, 0x11, 0x7b, 0x07, 0xe6, 0xa3, 0x31, 0xd3, 0xe0, 0x5c, 0x4c, 0x4c,
	0x48, 0xb4, 0x7e, 0xf2, 0x0b, 0x33, 0x79, 0xb7, 0x7f, 0x24, 0xd8, 0x50, 0x30, 0x22, 0xf2, 0x0b,
	0x43, 0xc9, 0x09, 0xbf, 0xda, 0x07, 0xa6, 0x87, 0xb0, 0x34, 0x6f, 0xf4, 0x8b, 0x6f, 0xfc, 0x21,
	0x41, 0xb6, 0x87, 0xa9, 0xa8, 0x04, 0xb0, 0x46, 0xad, 0x6d, 0xe7, 0xa9, 0x43, 0xf6, 0x9d, 0x42,
	0xac, 0x98, 0x3f, 0x3c, 0xaa, 0xf4, 0x48, 0xd0, 0x5d, 0xb8, 0xb6, 0x46, 0xad, 0x51, 0x2d, 0x5f,
	0x90, 0x8a, 0xaf, 0x1c, 0x1e, 0x55, 0x2e, 0x3a, 0x46, 0xf7, 0x40, 0x1e, 0x3e, 0xe2, 0x25, 0x2e,
	0xc4, 0x8b, 0xaf, 0x1e, 0x1e, 0x55, 0x2e, 0x3c, 0x47, 0x0a, 0xe4, 0xd6, 0xa8, 0x15, 0x75, 0x4b,
	0x21, 0x51, 0x2c, 0x1c, 0x1e, 0x55, 0xfa, 0x64, 0xa8, 0x06, 0x0b, 0xbd, 0xfb, 0x08, 0x3b, 0x59,
	0x94, 0x0f, 0x8f, 0x2a, 0x23, 0xcf, 0xea, 0x1b, 0xc7, 0xbf, 0x97, 0x62, 0xcf, 0x4f, 0x4a, 0xd2,
	0xf1, 0x49, 0x49, 0x7a, 0x71, 0x52, 0x92, 0xbe, 0x39, 0x2d, 0xc5, 0x8e, 0x4f, 0x4b, 0xb1, 0x5f,
	0x4f, 0x4b, 0xb1, 0x2f, 0xfe, 0xe6, 0xa3, 0x60, 0xd4, 0xff, 0x8a, 0xe6, 0x2c, 0xfb, 0x87, 0xf0,
	0xee, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe9, 0x0b, 0xc5, 0x70, 0xce, 0x10, 0x00, 0x00,
}

func (m *AddTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IsSecondary {
		i--
		if m.IsSecondary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddTableRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableRequests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableRequests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableRequests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableRequest_AddTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_AddTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTable != nil {
		{
			size, err := m.AddTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableRequest_RemoveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_RemoveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveTable != nil {
		{
			size, err := m.RemoveTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableRequest_BatchAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_BatchAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BatchAdd != nil {
		{
			size, err := m.BatchAdd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableRequest_BatchRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_BatchRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BatchRemove != nil {
		{
			size, err := m.BatchRemove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AddTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableResponse_AddTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse_AddTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTable != nil {
		{
			size, err := m.AddTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableResponse_RemoveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse_RemoveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveTable != nil {
		{
			size, err := m.RemoveTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TableBarrier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableBarrier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableBarrier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BarrierTs != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.BarrierTs))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Barrier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Barrier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Barrier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GlobalBarrierTs != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.GlobalBarrierTs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TableBarriers) > 0 {
		for iNdEx := len(m.TableBarriers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableBarriers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Barrier != nil {
		{
			size, err := m.Barrier.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CollectStats {
		i--
		if m.CollectStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Spans) > 0 {
		for iNdEx := len(m.Spans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Spans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IsStopping {
		i--
		if m.IsStopping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TableIDs) > 0 {
		dAtA16 := make([]byte, len(m.TableIDs)*10)
		var j15 int
		for _, num1 := range m.TableIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintTableSchedule(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Liveness != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.Liveness))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OwnerRevision) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerRevision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerRevision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessorEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessorEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Epoch) > 0 {
		i -= len(m.Epoch)
		copy(dAtA[i:], m.Epoch)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.Epoch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangefeedEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangefeedEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangefeedEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeartbeatResponse != nil {
		{
			size, err := m.HeartbeatResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Heartbeat != nil {
		{
			size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DispatchTableResponse != nil {
		{
			size, err := m.DispatchTableResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DispatchTableRequest != nil {
		{
			size, err := m.DispatchTableRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgType != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ChangefeedEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.ProcessorEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.OwnerRevision.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTableSchedule(dAtA []byte, offset int, v uint64) int {
	offset -= sovTableSchedule(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	if m.IsSecondary {
		n += 2
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	l = m.Span.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *RemoveTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	l = m.Span.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *AddTableRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	return n
}

func (m *RemoveTableRequests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	return n
}

func (m *DispatchTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *DispatchTableRequest_AddTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTable != nil {
		l = m.AddTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableRequest_RemoveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveTable != nil {
		l = m.RemoveTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableRequest_BatchAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchAdd != nil {
		l = m.BatchAdd.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableRequest_BatchRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BatchRemove != nil {
		l = m.BatchRemove.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *AddTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *RemoveTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *DispatchTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *DispatchTableResponse_AddTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTable != nil {
		l = m.AddTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableResponse_RemoveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveTable != nil {
		l = m.RemoveTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *TableBarrier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	if m.BarrierTs != 0 {
		n += 1 + sovTableSchedule(uint64(m.BarrierTs))
	}
	return n
}

func (m *Barrier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableBarriers) > 0 {
		for _, e := range m.TableBarriers {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	if m.GlobalBarrierTs != 0 {
		n += 1 + sovTableSchedule(uint64(m.GlobalBarrierTs))
	}
	return n
}

func (m *Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableIDs) > 0 {
		l = 0
		for _, e := range m.TableIDs {
			l += sovTableSchedule(uint64(e))
		}
		n += 1 + sovTableSchedule(uint64(l)) + l
	}
	if m.IsStopping {
		n += 2
	}
	if len(m.Spans) > 0 {
		for _, e := range m.Spans {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	if m.CollectStats {
		n += 2
	}
	if m.Barrier != nil {
		l = m.Barrier.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	if m.Liveness != 0 {
		n += 1 + sovTableSchedule(uint64(m.Liveness))
	}
	return n
}

func (m *OwnerRevision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovTableSchedule(uint64(m.Revision))
	}
	return n
}

func (m *ProcessorEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Epoch)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *ChangefeedEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovTableSchedule(uint64(m.Epoch))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovTableSchedule(uint64(m.MsgType))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.DispatchTableRequest != nil {
		l = m.DispatchTableRequest.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.DispatchTableResponse != nil {
		l = m.DispatchTableResponse.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.Heartbeat != nil {
		l = m.Heartbeat.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.HeartbeatResponse != nil {
		l = m.HeartbeatResponse.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *Message_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.OwnerRevision.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	l = m.ProcessorEpoch.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	l = m.ChangefeedEpoch.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func sovTableSchedule(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTableSchedule(x uint64) (n int) {
	return sovTableSchedule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSecondary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSecondary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTableRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableRequests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableRequests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &AddTableRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableRequests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableRequests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableRequests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &RemoveTableRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_AddTable{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_RemoveTable{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableRequests{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_BatchAdd{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableRequests{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_BatchRemove{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &tablepb.TableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &tablepb.TableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DispatchTableResponse_AddTable{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DispatchTableResponse_RemoveTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableBarrier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableBarrier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableBarrier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BarrierTs", wireType)
			}
			m.BarrierTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BarrierTs |= github_com_pingcap_tiflow_cdc_processor_tablepb.Ts(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Barrier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Barrier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Barrier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableBarriers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableBarriers = append(m.TableBarriers, &TableBarrier{})
			if err := m.TableBarriers[len(m.TableBarriers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalBarrierTs", wireType)
			}
			m.GlobalBarrierTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalBarrierTs |= github_com_pingcap_tiflow_cdc_processor_tablepb.Ts(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_pingcap_tiflow_cdc_model.TableID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTableSchedule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableIDs = append(m.TableIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTableSchedule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTableSchedule
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTableSchedule
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableIDs) == 0 {
					m.TableIDs = make([]github_com_pingcap_tiflow_cdc_model.TableID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_pingcap_tiflow_cdc_model.TableID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTableSchedule
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableIDs = append(m.TableIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStopping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStopping = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spans = append(m.Spans, tablepb.Span{})
			if err := m.Spans[len(m.Spans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CollectStats = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Barrier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Barrier == nil {
				m.Barrier = &Barrier{}
			}
			if err := m.Barrier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, tablepb.TableStatus{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= github_com_pingcap_tiflow_cdc_model.Liveness(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerRevision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerRevision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerRevision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Epoch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangefeedEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangefeedEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangefeedEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Message_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = github_com_pingcap_tiflow_cdc_model.CaptureID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = github_com_pingcap_tiflow_cdc_model.CaptureID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispatchTableRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DispatchTableRequest == nil {
				m.DispatchTableRequest = &DispatchTableRequest{}
			}
			if err := m.DispatchTableRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispatchTableResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DispatchTableResponse == nil {
				m.DispatchTableResponse = &DispatchTableResponse{}
			}
			if err := m.DispatchTableResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Heartbeat == nil {
				m.Heartbeat = &Heartbeat{}
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatResponse == nil {
				m.HeartbeatResponse = &HeartbeatResponse{}
			}
			if err := m.HeartbeatResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerRevision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OwnerRevision.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessorEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangefeedEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChangefeedEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTableSchedule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTableSchedule
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTableSchedule
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTableSchedule
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTableSchedule        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTableSchedule          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTableSchedule = fmt.Errorf("proto: unexpected end of group")
)
