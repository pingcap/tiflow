// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: table_schedule.proto

package schedulepb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_pingcap_tiflow_cdc_model "github.com/pingcap/tiflow/cdc/model"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TableState is the state of table replication in processor.
//
//  ┌────────┐   ┌───────────┐   ┌──────────┐
//  │ Absent ├─> │ Preparing ├─> │ Prepared │
//  └────────┘   └───────────┘   └─────┬────┘
//                                     v
//  ┌─────────┐   ┌──────────┐   ┌─────────────┐
//  │ Stopped │ <─┤ Stopping │ <─┤ Replicating │
//  └─────────┘   └──────────┘   └─────────────┘
type TableState int32

const (
	TableStateUnknown     TableState = 0
	TableStateAbsent      TableState = 1
	TableStatePreparing   TableState = 2
	TableStatePrepared    TableState = 3
	TableStateReplicating TableState = 4
	TableStateStopping    TableState = 5
	TableStateStopped     TableState = 6
)

var TableState_name = map[int32]string{
	0: "Unknown",
	1: "Absent",
	2: "Preparing",
	3: "Prepared",
	4: "Replicating",
	5: "Stopping",
	6: "Stopped",
}

var TableState_value = map[string]int32{
	"Unknown":     0,
	"Absent":      1,
	"Preparing":   2,
	"Prepared":    3,
	"Replicating": 4,
	"Stopping":    5,
	"Stopped":     6,
}

func (x TableState) String() string {
	return proto.EnumName(TableState_name, int32(x))
}

func (TableState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{0}
}

type MessageType int32

const (
	MsgUnknown               MessageType = 0
	MsgDispatchTableRequest  MessageType = 1
	MsgDispatchTableResponse MessageType = 2
	MsgHeartbeat             MessageType = 3
	MsgHeartbeatResponse     MessageType = 4
)

var MessageType_name = map[int32]string{
	0: "MsgUnknown",
	1: "MsgDispatchTableRequest",
	2: "MsgDispatchTableResponse",
	3: "MsgHeartbeat",
	4: "MsgHeartbeatResponse",
}

var MessageType_value = map[string]int32{
	"MsgUnknown":               0,
	"MsgDispatchTableRequest":  1,
	"MsgDispatchTableResponse": 2,
	"MsgHeartbeat":             3,
	"MsgHeartbeatResponse":     4,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{1}
}

type Checkpoint struct {
	CheckpointTs github_com_pingcap_tiflow_cdc_model.Ts `protobuf:"varint,1,opt,name=checkpoint_ts,json=checkpointTs,proto3,casttype=github.com/pingcap/tiflow/cdc/model.Ts" json:"checkpoint_ts,omitempty"`
	ResolvedTs   github_com_pingcap_tiflow_cdc_model.Ts `protobuf:"varint,2,opt,name=resolved_ts,json=resolvedTs,proto3,casttype=github.com/pingcap/tiflow/cdc/model.Ts" json:"resolved_ts,omitempty"`
}

func (m *Checkpoint) Reset()         { *m = Checkpoint{} }
func (m *Checkpoint) String() string { return proto.CompactTextString(m) }
func (*Checkpoint) ProtoMessage()    {}
func (*Checkpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{0}
}
func (m *Checkpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Checkpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Checkpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Checkpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Checkpoint.Merge(m, src)
}
func (m *Checkpoint) XXX_Size() int {
	return m.Size()
}
func (m *Checkpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Checkpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Checkpoint proto.InternalMessageInfo

func (m *Checkpoint) GetCheckpointTs() github_com_pingcap_tiflow_cdc_model.Ts {
	if m != nil {
		return m.CheckpointTs
	}
	return 0
}

func (m *Checkpoint) GetResolvedTs() github_com_pingcap_tiflow_cdc_model.Ts {
	if m != nil {
		return m.ResolvedTs
	}
	return 0
}

type AddTableRequest struct {
	TableID     github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	IsSecondary bool                                        `protobuf:"varint,2,opt,name=is_secondary,json=isSecondary,proto3" json:"is_secondary,omitempty"`
	Checkpoint  Checkpoint                                  `protobuf:"bytes,3,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *AddTableRequest) Reset()         { *m = AddTableRequest{} }
func (m *AddTableRequest) String() string { return proto.CompactTextString(m) }
func (*AddTableRequest) ProtoMessage()    {}
func (*AddTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{1}
}
func (m *AddTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableRequest.Merge(m, src)
}
func (m *AddTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableRequest proto.InternalMessageInfo

func (m *AddTableRequest) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *AddTableRequest) GetIsSecondary() bool {
	if m != nil {
		return m.IsSecondary
	}
	return false
}

func (m *AddTableRequest) GetCheckpoint() Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return Checkpoint{}
}

type RemoveTableRequest struct {
	TableID github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
}

func (m *RemoveTableRequest) Reset()         { *m = RemoveTableRequest{} }
func (m *RemoveTableRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveTableRequest) ProtoMessage()    {}
func (*RemoveTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{2}
}
func (m *RemoveTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableRequest.Merge(m, src)
}
func (m *RemoveTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableRequest proto.InternalMessageInfo

func (m *RemoveTableRequest) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

type DispatchTableRequest struct {
	// Types that are valid to be assigned to Request:
	//	*DispatchTableRequest_AddTable
	//	*DispatchTableRequest_RemoveTable
	Request isDispatchTableRequest_Request `protobuf_oneof:"request"`
}

func (m *DispatchTableRequest) Reset()         { *m = DispatchTableRequest{} }
func (m *DispatchTableRequest) String() string { return proto.CompactTextString(m) }
func (*DispatchTableRequest) ProtoMessage()    {}
func (*DispatchTableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{3}
}
func (m *DispatchTableRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchTableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchTableRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchTableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchTableRequest.Merge(m, src)
}
func (m *DispatchTableRequest) XXX_Size() int {
	return m.Size()
}
func (m *DispatchTableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchTableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchTableRequest proto.InternalMessageInfo

type isDispatchTableRequest_Request interface {
	isDispatchTableRequest_Request()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispatchTableRequest_AddTable struct {
	AddTable *AddTableRequest `protobuf:"bytes,1,opt,name=add_table,json=addTable,proto3,oneof" json:"add_table,omitempty"`
}
type DispatchTableRequest_RemoveTable struct {
	RemoveTable *RemoveTableRequest `protobuf:"bytes,2,opt,name=remove_table,json=removeTable,proto3,oneof" json:"remove_table,omitempty"`
}

func (*DispatchTableRequest_AddTable) isDispatchTableRequest_Request()    {}
func (*DispatchTableRequest_RemoveTable) isDispatchTableRequest_Request() {}

func (m *DispatchTableRequest) GetRequest() isDispatchTableRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DispatchTableRequest) GetAddTable() *AddTableRequest {
	if x, ok := m.GetRequest().(*DispatchTableRequest_AddTable); ok {
		return x.AddTable
	}
	return nil
}

func (m *DispatchTableRequest) GetRemoveTable() *RemoveTableRequest {
	if x, ok := m.GetRequest().(*DispatchTableRequest_RemoveTable); ok {
		return x.RemoveTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispatchTableRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispatchTableRequest_AddTable)(nil),
		(*DispatchTableRequest_RemoveTable)(nil),
	}
}

type AddTableResponse struct {
	Status     *TableStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Checkpoint Checkpoint   `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint"`
	Reject     bool         `protobuf:"varint,3,opt,name=reject,proto3" json:"reject,omitempty"`
}

func (m *AddTableResponse) Reset()         { *m = AddTableResponse{} }
func (m *AddTableResponse) String() string { return proto.CompactTextString(m) }
func (*AddTableResponse) ProtoMessage()    {}
func (*AddTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{4}
}
func (m *AddTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTableResponse.Merge(m, src)
}
func (m *AddTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTableResponse proto.InternalMessageInfo

func (m *AddTableResponse) GetStatus() *TableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AddTableResponse) GetCheckpoint() Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return Checkpoint{}
}

func (m *AddTableResponse) GetReject() bool {
	if m != nil {
		return m.Reject
	}
	return false
}

type RemoveTableResponse struct {
	Status     *TableStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	Checkpoint Checkpoint   `protobuf:"bytes,2,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *RemoveTableResponse) Reset()         { *m = RemoveTableResponse{} }
func (m *RemoveTableResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveTableResponse) ProtoMessage()    {}
func (*RemoveTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{5}
}
func (m *RemoveTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveTableResponse.Merge(m, src)
}
func (m *RemoveTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoveTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveTableResponse proto.InternalMessageInfo

func (m *RemoveTableResponse) GetStatus() *TableStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *RemoveTableResponse) GetCheckpoint() Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return Checkpoint{}
}

type DispatchTableResponse struct {
	// Types that are valid to be assigned to Response:
	//	*DispatchTableResponse_AddTable
	//	*DispatchTableResponse_RemoveTable
	Response isDispatchTableResponse_Response `protobuf_oneof:"response"`
}

func (m *DispatchTableResponse) Reset()         { *m = DispatchTableResponse{} }
func (m *DispatchTableResponse) String() string { return proto.CompactTextString(m) }
func (*DispatchTableResponse) ProtoMessage()    {}
func (*DispatchTableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{6}
}
func (m *DispatchTableResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DispatchTableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DispatchTableResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DispatchTableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DispatchTableResponse.Merge(m, src)
}
func (m *DispatchTableResponse) XXX_Size() int {
	return m.Size()
}
func (m *DispatchTableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DispatchTableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DispatchTableResponse proto.InternalMessageInfo

type isDispatchTableResponse_Response interface {
	isDispatchTableResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DispatchTableResponse_AddTable struct {
	AddTable *AddTableResponse `protobuf:"bytes,1,opt,name=add_table,json=addTable,proto3,oneof" json:"add_table,omitempty"`
}
type DispatchTableResponse_RemoveTable struct {
	RemoveTable *RemoveTableResponse `protobuf:"bytes,2,opt,name=remove_table,json=removeTable,proto3,oneof" json:"remove_table,omitempty"`
}

func (*DispatchTableResponse_AddTable) isDispatchTableResponse_Response()    {}
func (*DispatchTableResponse_RemoveTable) isDispatchTableResponse_Response() {}

func (m *DispatchTableResponse) GetResponse() isDispatchTableResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *DispatchTableResponse) GetAddTable() *AddTableResponse {
	if x, ok := m.GetResponse().(*DispatchTableResponse_AddTable); ok {
		return x.AddTable
	}
	return nil
}

func (m *DispatchTableResponse) GetRemoveTable() *RemoveTableResponse {
	if x, ok := m.GetResponse().(*DispatchTableResponse_RemoveTable); ok {
		return x.RemoveTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DispatchTableResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DispatchTableResponse_AddTable)(nil),
		(*DispatchTableResponse_RemoveTable)(nil),
	}
}

type Heartbeat struct {
	TableIDs   []github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,rep,packed,name=table_ids,json=tableIds,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_ids,omitempty"`
	IsStopping bool                                          `protobuf:"varint,2,opt,name=is_stopping,json=isStopping,proto3" json:"is_stopping,omitempty"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{7}
}
func (m *Heartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Heartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Heartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Heartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Heartbeat.Merge(m, src)
}
func (m *Heartbeat) XXX_Size() int {
	return m.Size()
}
func (m *Heartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_Heartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_Heartbeat proto.InternalMessageInfo

func (m *Heartbeat) GetTableIDs() []github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableIDs
	}
	return nil
}

func (m *Heartbeat) GetIsStopping() bool {
	if m != nil {
		return m.IsStopping
	}
	return false
}

type TableStatus struct {
	TableID    github_com_pingcap_tiflow_cdc_model.TableID `protobuf:"varint,1,opt,name=table_id,json=tableId,proto3,casttype=github.com/pingcap/tiflow/cdc/model.TableID" json:"table_id,omitempty"`
	State      TableState                                  `protobuf:"varint,2,opt,name=state,proto3,enum=pingcap.tiflow.cdc.schedulepb.TableState" json:"state,omitempty"`
	Checkpoint Checkpoint                                  `protobuf:"bytes,3,opt,name=checkpoint,proto3" json:"checkpoint"`
}

func (m *TableStatus) Reset()         { *m = TableStatus{} }
func (m *TableStatus) String() string { return proto.CompactTextString(m) }
func (*TableStatus) ProtoMessage()    {}
func (*TableStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{8}
}
func (m *TableStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableStatus.Merge(m, src)
}
func (m *TableStatus) XXX_Size() int {
	return m.Size()
}
func (m *TableStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TableStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TableStatus proto.InternalMessageInfo

func (m *TableStatus) GetTableID() github_com_pingcap_tiflow_cdc_model.TableID {
	if m != nil {
		return m.TableID
	}
	return 0
}

func (m *TableStatus) GetState() TableState {
	if m != nil {
		return m.State
	}
	return TableStateUnknown
}

func (m *TableStatus) GetCheckpoint() Checkpoint {
	if m != nil {
		return m.Checkpoint
	}
	return Checkpoint{}
}

type HeartbeatResponse struct {
	Tables     []TableStatus `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables"`
	IsStopping bool          `protobuf:"varint,2,opt,name=is_stopping,json=isStopping,proto3" json:"is_stopping,omitempty"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{9}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

func (m *HeartbeatResponse) GetTables() []TableStatus {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *HeartbeatResponse) GetIsStopping() bool {
	if m != nil {
		return m.IsStopping
	}
	return false
}

type OwnerRevision struct {
	Revision int64 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
}

func (m *OwnerRevision) Reset()         { *m = OwnerRevision{} }
func (m *OwnerRevision) String() string { return proto.CompactTextString(m) }
func (*OwnerRevision) ProtoMessage()    {}
func (*OwnerRevision) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{10}
}
func (m *OwnerRevision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerRevision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerRevision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerRevision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerRevision.Merge(m, src)
}
func (m *OwnerRevision) XXX_Size() int {
	return m.Size()
}
func (m *OwnerRevision) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerRevision.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerRevision proto.InternalMessageInfo

func (m *OwnerRevision) GetRevision() int64 {
	if m != nil {
		return m.Revision
	}
	return 0
}

type ProcessorEpoch struct {
	Epoch string `protobuf:"bytes,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
}

func (m *ProcessorEpoch) Reset()         { *m = ProcessorEpoch{} }
func (m *ProcessorEpoch) String() string { return proto.CompactTextString(m) }
func (*ProcessorEpoch) ProtoMessage()    {}
func (*ProcessorEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{11}
}
func (m *ProcessorEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessorEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessorEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessorEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessorEpoch.Merge(m, src)
}
func (m *ProcessorEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ProcessorEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessorEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessorEpoch proto.InternalMessageInfo

func (m *ProcessorEpoch) GetEpoch() string {
	if m != nil {
		return m.Epoch
	}
	return ""
}

type Message struct {
	Header                *Message_Header                               `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	MsgType               MessageType                                   `protobuf:"varint,2,opt,name=msg_type,json=msgType,proto3,enum=pingcap.tiflow.cdc.schedulepb.MessageType" json:"msg_type,omitempty"`
	From                  github_com_pingcap_tiflow_cdc_model.CaptureID `protobuf:"bytes,3,opt,name=from,proto3,casttype=github.com/pingcap/tiflow/cdc/model.CaptureID" json:"from,omitempty"`
	To                    github_com_pingcap_tiflow_cdc_model.CaptureID `protobuf:"bytes,4,opt,name=to,proto3,casttype=github.com/pingcap/tiflow/cdc/model.CaptureID" json:"to,omitempty"`
	DispatchTableRequest  *DispatchTableRequest                         `protobuf:"bytes,5,opt,name=dispatch_table_request,json=dispatchTableRequest,proto3" json:"dispatch_table_request,omitempty"`
	DispatchTableResponse *DispatchTableResponse                        `protobuf:"bytes,6,opt,name=dispatch_table_response,json=dispatchTableResponse,proto3" json:"dispatch_table_response,omitempty"`
	Heartbeat             *Heartbeat                                    `protobuf:"bytes,7,opt,name=heartbeat,proto3" json:"heartbeat,omitempty"`
	HeartbeatResponse     *HeartbeatResponse                            `protobuf:"bytes,8,opt,name=heartbeat_response,json=heartbeatResponse,proto3" json:"heartbeat_response,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{12}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetHeader() *Message_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Message) GetMsgType() MessageType {
	if m != nil {
		return m.MsgType
	}
	return MsgUnknown
}

func (m *Message) GetFrom() github_com_pingcap_tiflow_cdc_model.CaptureID {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Message) GetTo() github_com_pingcap_tiflow_cdc_model.CaptureID {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Message) GetDispatchTableRequest() *DispatchTableRequest {
	if m != nil {
		return m.DispatchTableRequest
	}
	return nil
}

func (m *Message) GetDispatchTableResponse() *DispatchTableResponse {
	if m != nil {
		return m.DispatchTableResponse
	}
	return nil
}

func (m *Message) GetHeartbeat() *Heartbeat {
	if m != nil {
		return m.Heartbeat
	}
	return nil
}

func (m *Message) GetHeartbeatResponse() *HeartbeatResponse {
	if m != nil {
		return m.HeartbeatResponse
	}
	return nil
}

type Message_Header struct {
	// The semantic version of the node that sent this message.
	Version        string         `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	OwnerRevision  OwnerRevision  `protobuf:"bytes,2,opt,name=owner_revision,json=ownerRevision,proto3" json:"owner_revision"`
	ProcessorEpoch ProcessorEpoch `protobuf:"bytes,3,opt,name=processor_epoch,json=processorEpoch,proto3" json:"processor_epoch"`
}

func (m *Message_Header) Reset()         { *m = Message_Header{} }
func (m *Message_Header) String() string { return proto.CompactTextString(m) }
func (*Message_Header) ProtoMessage()    {}
func (*Message_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_ab4bb9c6b16cfa4d, []int{12, 0}
}
func (m *Message_Header) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message_Header.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message_Header.Merge(m, src)
}
func (m *Message_Header) XXX_Size() int {
	return m.Size()
}
func (m *Message_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Message_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Message_Header proto.InternalMessageInfo

func (m *Message_Header) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Message_Header) GetOwnerRevision() OwnerRevision {
	if m != nil {
		return m.OwnerRevision
	}
	return OwnerRevision{}
}

func (m *Message_Header) GetProcessorEpoch() ProcessorEpoch {
	if m != nil {
		return m.ProcessorEpoch
	}
	return ProcessorEpoch{}
}

func init() {
	proto.RegisterEnum("pingcap.tiflow.cdc.schedulepb.TableState", TableState_name, TableState_value)
	proto.RegisterEnum("pingcap.tiflow.cdc.schedulepb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*Checkpoint)(nil), "pingcap.tiflow.cdc.schedulepb.Checkpoint")
	proto.RegisterType((*AddTableRequest)(nil), "pingcap.tiflow.cdc.schedulepb.AddTableRequest")
	proto.RegisterType((*RemoveTableRequest)(nil), "pingcap.tiflow.cdc.schedulepb.RemoveTableRequest")
	proto.RegisterType((*DispatchTableRequest)(nil), "pingcap.tiflow.cdc.schedulepb.DispatchTableRequest")
	proto.RegisterType((*AddTableResponse)(nil), "pingcap.tiflow.cdc.schedulepb.AddTableResponse")
	proto.RegisterType((*RemoveTableResponse)(nil), "pingcap.tiflow.cdc.schedulepb.RemoveTableResponse")
	proto.RegisterType((*DispatchTableResponse)(nil), "pingcap.tiflow.cdc.schedulepb.DispatchTableResponse")
	proto.RegisterType((*Heartbeat)(nil), "pingcap.tiflow.cdc.schedulepb.Heartbeat")
	proto.RegisterType((*TableStatus)(nil), "pingcap.tiflow.cdc.schedulepb.TableStatus")
	proto.RegisterType((*HeartbeatResponse)(nil), "pingcap.tiflow.cdc.schedulepb.HeartbeatResponse")
	proto.RegisterType((*OwnerRevision)(nil), "pingcap.tiflow.cdc.schedulepb.OwnerRevision")
	proto.RegisterType((*ProcessorEpoch)(nil), "pingcap.tiflow.cdc.schedulepb.ProcessorEpoch")
	proto.RegisterType((*Message)(nil), "pingcap.tiflow.cdc.schedulepb.Message")
	proto.RegisterType((*Message_Header)(nil), "pingcap.tiflow.cdc.schedulepb.Message.Header")
}

func init() { proto.RegisterFile("table_schedule.proto", fileDescriptor_ab4bb9c6b16cfa4d) }

var fileDescriptor_ab4bb9c6b16cfa4d = []byte{
	// 1126 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4d, 0x6f, 0xe3, 0xc4,
	0x1b, 0x8f, 0x93, 0x34, 0x2f, 0x4f, 0xba, 0x5d, 0x77, 0x36, 0x6d, 0xf3, 0xf7, 0x1f, 0x12, 0x63,
	0xa1, 0xaa, 0x64, 0xd9, 0x84, 0xed, 0x72, 0x40, 0xcb, 0x01, 0x35, 0xbb, 0x45, 0x5d, 0xa1, 0xd2,
	0x95, 0xdb, 0xe5, 0x4d, 0x48, 0x91, 0x63, 0xcf, 0x26, 0xa6, 0x89, 0xc7, 0x78, 0xdc, 0x56, 0xbd,
	0x20, 0x71, 0xe1, 0x90, 0x13, 0x27, 0x6e, 0xf9, 0x02, 0x7c, 0x09, 0xae, 0x3d, 0x70, 0xe8, 0x11,
	0x09, 0x14, 0x41, 0xfb, 0x1d, 0x38, 0x94, 0x0b, 0xf2, 0xcc, 0xd8, 0x4e, 0xd2, 0x2c, 0x49, 0x79,
	0x13, 0x37, 0xcf, 0x3c, 0xf3, 0xfc, 0x9e, 0xb7, 0xdf, 0xef, 0x89, 0x02, 0x45, 0xdf, 0x68, 0x75,
	0x71, 0x93, 0x9a, 0x1d, 0x6c, 0x1d, 0x75, 0x71, 0xcd, 0xf5, 0x88, 0x4f, 0xd0, 0xcb, 0xae, 0xed,
	0xb4, 0x4d, 0xc3, 0xad, 0xf9, 0xf6, 0xf3, 0x2e, 0x39, 0xa9, 0x99, 0x96, 0x59, 0x0b, 0x9f, 0xb8,
	0x2d, 0xa5, 0xd8, 0x26, 0x6d, 0xc2, 0x5e, 0xd6, 0x83, 0x2f, 0xee, 0xa4, 0x7d, 0x2b, 0x01, 0x3c,
	0xea, 0x60, 0xf3, 0xd0, 0x25, 0xb6, 0xe3, 0xa3, 0x3d, 0xb8, 0x65, 0x46, 0xa7, 0xa6, 0x4f, 0x4b,
	0x92, 0x2a, 0x6d, 0xa4, 0x1b, 0xd5, 0xab, 0x61, 0x65, 0xbd, 0x6d, 0xfb, 0x9d, 0xa3, 0x56, 0xcd,
	0x24, 0xbd, 0xba, 0x88, 0x54, 0xe7, 0x91, 0xea, 0xa6, 0x65, 0xd6, 0x7b, 0xc4, 0xc2, 0xdd, 0xda,
	0x01, 0xd5, 0x17, 0x63, 0x80, 0x03, 0x8a, 0xde, 0x83, 0x82, 0x87, 0x29, 0xe9, 0x1e, 0x63, 0x2b,
	0x80, 0x4b, 0xde, 0x18, 0x0e, 0x42, 0xf7, 0x03, 0xaa, 0xfd, 0x24, 0xc1, 0xed, 0x2d, 0xcb, 0x3a,
	0x08, 0xaa, 0xd7, 0xf1, 0xe7, 0x47, 0x98, 0xfa, 0xe8, 0x19, 0xe4, 0x78, 0x37, 0x6c, 0x8b, 0x25,
	0x9b, 0x6a, 0x3c, 0xbc, 0x18, 0x56, 0xb2, 0xec, 0xcd, 0x93, 0xc7, 0x57, 0xc3, 0xca, 0xdd, 0xb9,
	0x02, 0xf1, 0xe7, 0x7a, 0x96, 0x61, 0x3d, 0xb1, 0xd0, 0x2b, 0xb0, 0x68, 0xd3, 0x26, 0xc5, 0x26,
	0x71, 0x2c, 0xc3, 0x3b, 0x65, 0x89, 0xe7, 0xf4, 0x82, 0x4d, 0xf7, 0xc3, 0x2b, 0xb4, 0x07, 0x10,
	0x97, 0x5a, 0x4a, 0xa9, 0xd2, 0x46, 0x61, 0xf3, 0xb5, 0xda, 0x1f, 0x0e, 0xa1, 0x16, 0xb7, 0xba,
	0x91, 0x3e, 0x1b, 0x56, 0x12, 0xfa, 0x08, 0x84, 0x76, 0x08, 0x48, 0xc7, 0x3d, 0x72, 0x8c, 0xff,
	0x85, 0x02, 0xb5, 0x33, 0x09, 0x8a, 0x8f, 0x6d, 0xea, 0x1a, 0xbe, 0xd9, 0x19, 0x8b, 0xb7, 0x0b,
	0x79, 0xc3, 0xb2, 0x9a, 0xec, 0x1d, 0x0b, 0x58, 0xd8, 0xac, 0xcd, 0xa8, 0x6a, 0x62, 0x26, 0x3b,
	0x09, 0x3d, 0x67, 0x88, 0x2b, 0xf4, 0x01, 0x2c, 0x7a, 0xac, 0x28, 0x81, 0x98, 0x64, 0x88, 0xf7,
	0x67, 0x20, 0x5e, 0xef, 0xc3, 0x4e, 0x42, 0x2f, 0x78, 0xf1, 0x6d, 0x23, 0x0f, 0x59, 0x8f, 0x5b,
	0xb4, 0xef, 0x24, 0x90, 0xe3, 0x14, 0xa8, 0x4b, 0x1c, 0x8a, 0x51, 0x03, 0x32, 0xd4, 0x37, 0xfc,
	0x23, 0x2a, 0x6a, 0xa8, 0xce, 0x88, 0xc8, 0xbc, 0xf7, 0x99, 0x87, 0x2e, 0x3c, 0x27, 0x26, 0x9c,
	0xfc, 0xcb, 0x13, 0x46, 0xab, 0x90, 0xf1, 0xf0, 0x67, 0xd8, 0xe4, 0x74, 0xc9, 0xe9, 0xe2, 0x14,
	0xa8, 0xf0, 0xce, 0x58, 0xc9, 0xff, 0xe1, 0x22, 0xb4, 0xef, 0x25, 0x58, 0x99, 0x60, 0x8e, 0x48,
	0xf7, 0xfd, 0xeb, 0xd4, 0xa9, 0xcf, 0x4d, 0x1d, 0x8e, 0x31, 0xc6, 0x9d, 0x0f, 0xa7, 0x72, 0x67,
	0xf3, 0x26, 0xdc, 0x89, 0x50, 0xc7, 0xc8, 0x03, 0x90, 0xf3, 0x84, 0x49, 0xfb, 0x4a, 0x82, 0xfc,
	0x0e, 0x36, 0x3c, 0xbf, 0x85, 0x0d, 0x1f, 0x7d, 0x04, 0xf9, 0x50, 0x6d, 0x41, 0xd3, 0x53, 0x1b,
	0xa9, 0xc6, 0xdb, 0x17, 0xc3, 0x4a, 0x4e, 0xe8, 0x87, 0xde, 0x54, 0x6f, 0x39, 0xa1, 0x37, 0x8a,
	0x2a, 0x50, 0x08, 0x36, 0x8a, 0x4f, 0xdc, 0xc0, 0x49, 0x2c, 0x14, 0xb0, 0xe9, 0xbe, 0xb8, 0xd1,
	0x7e, 0x95, 0xa0, 0x30, 0x32, 0xc0, 0x7f, 0x6a, 0xb3, 0xbd, 0x03, 0x0b, 0x01, 0x33, 0x78, 0x37,
	0x97, 0x66, 0x52, 0x21, 0xca, 0x08, 0xeb, 0xdc, 0xef, 0xef, 0xdf, 0x7b, 0x5f, 0xc0, 0x72, 0x34,
	0x80, 0x88, 0x4b, 0x3b, 0x90, 0x61, 0x19, 0xf3, 0x29, 0xdc, 0x88, 0xfa, 0x22, 0x84, 0xf0, 0x9f,
	0xdd, 0xf8, 0xbb, 0x70, 0x6b, 0xef, 0xc4, 0xc1, 0x9e, 0x8e, 0x8f, 0x6d, 0x6a, 0x13, 0x07, 0x29,
	0x01, 0x3d, 0xf8, 0x37, 0xef, 0xbc, 0x1e, 0x9d, 0xb5, 0x75, 0x58, 0x7a, 0xea, 0x11, 0x13, 0x53,
	0x4a, 0xbc, 0x6d, 0x97, 0x98, 0x1d, 0x54, 0x84, 0x05, 0x1c, 0x7c, 0xb0, 0xa7, 0x79, 0x9d, 0x1f,
	0xb4, 0x2f, 0xb3, 0x90, 0xdd, 0xc5, 0x94, 0x1a, 0x6d, 0x8c, 0xb6, 0x21, 0xd3, 0xc1, 0x86, 0x85,
	0x3d, 0x21, 0x8a, 0x7b, 0x33, 0x6a, 0x11, 0x7e, 0xb5, 0x1d, 0xe6, 0xa4, 0x0b, 0x67, 0xb4, 0x0d,
	0xb9, 0x1e, 0x6d, 0x37, 0xfd, 0x53, 0x37, 0x1c, 0x5e, 0x75, 0x3e, 0xa0, 0x83, 0x53, 0x17, 0xeb,
	0xd9, 0x1e, 0x6d, 0x07, 0x1f, 0x68, 0x1b, 0xd2, 0xcf, 0x3d, 0xd2, 0x63, 0x93, 0xcb, 0x37, 0xee,
	0x5f, 0x0d, 0x2b, 0xf7, 0xe6, 0x21, 0xd2, 0x23, 0xc3, 0xf5, 0x8f, 0xbc, 0x80, 0x4a, 0xcc, 0x1d,
	0x6d, 0x41, 0xd2, 0x27, 0xa5, 0xf4, 0x9f, 0x05, 0x49, 0xfa, 0x04, 0xd9, 0xb0, 0x6a, 0x89, 0x45,
	0xc2, 0x15, 0xde, 0x14, 0x2b, 0xbd, 0xb4, 0xc0, 0xfa, 0xf4, 0x60, 0x46, 0x79, 0xd3, 0x7e, 0xbf,
	0xf4, 0xa2, 0x35, 0xed, 0x57, 0xad, 0x0b, 0x6b, 0xd7, 0x42, 0x71, 0xa6, 0x95, 0x32, 0x2c, 0xd6,
	0x9b, 0x37, 0x8b, 0xc5, 0x7d, 0xf5, 0x15, 0x6b, 0xea, 0x22, 0x7c, 0x17, 0xf2, 0x9d, 0x90, 0xd1,
	0xa5, 0x2c, 0xc3, 0xdf, 0x98, 0x81, 0x1f, 0x2b, 0x20, 0x76, 0x45, 0x4d, 0x40, 0xd1, 0x21, 0x4e,
	0x38, 0xc7, 0x00, 0xdf, 0x98, 0x1b, 0x30, 0x4c, 0x76, 0xb9, 0x33, 0x79, 0xa5, 0xfc, 0x28, 0x41,
	0x86, 0xb3, 0x0c, 0x95, 0x20, 0x7b, 0x8c, 0xbd, 0x88, 0xf3, 0x79, 0x3d, 0x3c, 0xa2, 0x8f, 0x61,
	0x89, 0x04, 0xfa, 0x68, 0x46, 0xa2, 0xe0, 0x8b, 0xf8, 0xf5, 0x19, 0x19, 0x8c, 0x89, 0x4a, 0x88,
	0xf2, 0x16, 0x19, 0x53, 0xda, 0xa7, 0x70, 0xdb, 0x0d, 0xd5, 0xd4, 0xe4, 0x2a, 0x4a, 0xcd, 0x25,
	0x91, 0x71, 0x0d, 0x0a, 0xf0, 0x25, 0x77, 0xec, 0xb6, 0xfa, 0x4d, 0x12, 0x20, 0xde, 0x5f, 0x48,
	0x83, 0xec, 0x33, 0xe7, 0xd0, 0x21, 0x27, 0x8e, 0x9c, 0x50, 0x56, 0xfa, 0x03, 0x75, 0x39, 0x36,
	0x0a, 0x03, 0x52, 0x21, 0xb3, 0xd5, 0xa2, 0xd8, 0xf1, 0x65, 0x49, 0x29, 0xf6, 0x07, 0xaa, 0x1c,
	0x3f, 0xe1, 0xf7, 0x68, 0x1d, 0xf2, 0x4f, 0x3d, 0xec, 0x1a, 0x9e, 0xed, 0xb4, 0xe5, 0xa4, 0xb2,
	0xd6, 0x1f, 0xa8, 0x77, 0xe2, 0x47, 0x91, 0x09, 0xbd, 0x0a, 0x39, 0x7e, 0xc0, 0x96, 0x9c, 0x52,
	0x56, 0xfb, 0x03, 0x15, 0x4d, 0x3e, 0xc3, 0x16, 0xaa, 0x42, 0x41, 0xc7, 0x6e, 0xd7, 0x36, 0x0d,
	0x3f, 0xc0, 0x4b, 0x2b, 0xff, 0xeb, 0x0f, 0xd4, 0x95, 0x91, 0xa5, 0x1b, 0x1b, 0x03, 0xc4, 0x70,
	0x67, 0xc9, 0x0b, 0x93, 0x88, 0xa1, 0x25, 0xa8, 0x92, 0x7d, 0x63, 0x4b, 0xce, 0x4c, 0x56, 0x29,
	0x0c, 0xd5, 0xdf, 0x24, 0x28, 0x8c, 0xec, 0x06, 0x54, 0x06, 0xd8, 0xa5, 0xed, 0xb8, 0x39, 0x4b,
	0xfd, 0x81, 0x3a, 0x72, 0x83, 0xde, 0x82, 0xb5, 0x5d, 0xda, 0x9e, 0x26, 0x37, 0x59, 0x52, 0xfe,
	0xdf, 0x1f, 0xa8, 0x2f, 0x32, 0xa3, 0x87, 0x50, 0xba, 0x6e, 0xe2, 0xe4, 0x93, 0x93, 0xca, 0x4b,
	0xfd, 0x81, 0xfa, 0x42, 0x3b, 0xd2, 0x60, 0x71, 0x97, 0xb6, 0x23, 0x1e, 0xcb, 0x29, 0x45, 0xee,
	0x0f, 0xd4, 0xb1, 0x3b, 0xb4, 0x09, 0xc5, 0xd1, 0x73, 0x84, 0x9d, 0x56, 0x4a, 0xfd, 0x81, 0x3a,
	0xd5, 0xd6, 0xd8, 0x38, 0xff, 0xa5, 0x9c, 0x38, 0xbb, 0x28, 0x4b, 0xe7, 0x17, 0x65, 0xe9, 0xe7,
	0x8b, 0xb2, 0xf4, 0xf5, 0x65, 0x39, 0x71, 0x7e, 0x59, 0x4e, 0xfc, 0x70, 0x59, 0x4e, 0x7c, 0x02,
	0x31, 0xcb, 0x5a, 0x19, 0xf6, 0x27, 0xe9, 0xc1, 0xef, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc2, 0x49,
	0xf5, 0x12, 0x71, 0x0d, 0x00, 0x00,
}

func (m *Checkpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Checkpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Checkpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResolvedTs != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.ResolvedTs))
		i--
		dAtA[i] = 0x10
	}
	if m.CheckpointTs != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.CheckpointTs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IsSecondary {
		i--
		if m.IsSecondary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchTableRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		{
			size := m.Request.Size()
			i -= size
			if _, err := m.Request.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableRequest_AddTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_AddTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTable != nil {
		{
			size, err := m.AddTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableRequest_RemoveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableRequest_RemoveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveTable != nil {
		{
			size, err := m.RemoveTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AddTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reject {
		i--
		if m.Reject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DispatchTableResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		{
			size := m.Response.Size()
			i -= size
			if _, err := m.Response.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DispatchTableResponse_AddTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse_AddTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddTable != nil {
		{
			size, err := m.AddTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DispatchTableResponse_RemoveTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DispatchTableResponse_RemoveTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveTable != nil {
		{
			size, err := m.RemoveTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsStopping {
		i--
		if m.IsStopping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TableIDs) > 0 {
		dAtA11 := make([]byte, len(m.TableIDs)*10)
		var j10 int
		for _, num1 := range m.TableIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTableSchedule(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Checkpoint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.State != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.TableID != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.TableID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsStopping {
		i--
		if m.IsStopping {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTableSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OwnerRevision) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerRevision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerRevision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Revision != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessorEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessorEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessorEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Epoch) > 0 {
		i -= len(m.Epoch)
		copy(dAtA[i:], m.Epoch)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.Epoch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeartbeatResponse != nil {
		{
			size, err := m.HeartbeatResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Heartbeat != nil {
		{
			size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.DispatchTableResponse != nil {
		{
			size, err := m.DispatchTableResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.DispatchTableRequest != nil {
		{
			size, err := m.DispatchTableRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgType != 0 {
		i = encodeVarintTableSchedule(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTableSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message_Header) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ProcessorEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.OwnerRevision.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTableSchedule(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTableSchedule(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTableSchedule(dAtA []byte, offset int, v uint64) int {
	offset -= sovTableSchedule(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Checkpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckpointTs != 0 {
		n += 1 + sovTableSchedule(uint64(m.CheckpointTs))
	}
	if m.ResolvedTs != 0 {
		n += 1 + sovTableSchedule(uint64(m.ResolvedTs))
	}
	return n
}

func (m *AddTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	if m.IsSecondary {
		n += 2
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *RemoveTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	return n
}

func (m *DispatchTableRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		n += m.Request.Size()
	}
	return n
}

func (m *DispatchTableRequest_AddTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTable != nil {
		l = m.AddTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableRequest_RemoveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveTable != nil {
		l = m.RemoveTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *AddTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	if m.Reject {
		n += 2
	}
	return n
}

func (m *RemoveTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *DispatchTableResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *DispatchTableResponse_AddTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddTable != nil {
		l = m.AddTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *DispatchTableResponse_RemoveTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveTable != nil {
		l = m.RemoveTable.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}
func (m *Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TableIDs) > 0 {
		l = 0
		for _, e := range m.TableIDs {
			l += sovTableSchedule(uint64(e))
		}
		n += 1 + sovTableSchedule(uint64(l)) + l
	}
	if m.IsStopping {
		n += 2
	}
	return n
}

func (m *TableStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TableID != 0 {
		n += 1 + sovTableSchedule(uint64(m.TableID))
	}
	if m.State != 0 {
		n += 1 + sovTableSchedule(uint64(m.State))
	}
	l = m.Checkpoint.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovTableSchedule(uint64(l))
		}
	}
	if m.IsStopping {
		n += 2
	}
	return n
}

func (m *OwnerRevision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovTableSchedule(uint64(m.Revision))
	}
	return n
}

func (m *ProcessorEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Epoch)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovTableSchedule(uint64(m.MsgType))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.DispatchTableRequest != nil {
		l = m.DispatchTableRequest.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.DispatchTableResponse != nil {
		l = m.DispatchTableResponse.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.Heartbeat != nil {
		l = m.Heartbeat.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	if m.HeartbeatResponse != nil {
		l = m.HeartbeatResponse.Size()
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	return n
}

func (m *Message_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTableSchedule(uint64(l))
	}
	l = m.OwnerRevision.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	l = m.ProcessorEpoch.Size()
	n += 1 + l + sovTableSchedule(uint64(l))
	return n
}

func sovTableSchedule(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTableSchedule(x uint64) (n int) {
	return sovTableSchedule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Checkpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checkpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checkpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointTs", wireType)
			}
			m.CheckpointTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckpointTs |= github_com_pingcap_tiflow_cdc_model.Ts(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedTs", wireType)
			}
			m.ResolvedTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolvedTs |= github_com_pingcap_tiflow_cdc_model.Ts(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSecondary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSecondary = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_AddTable{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Request = &DispatchTableRequest_RemoveTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &TableStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DispatchTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DispatchTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DispatchTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DispatchTableResponse_AddTable{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoveTableResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &DispatchTableResponse_RemoveTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_pingcap_tiflow_cdc_model.TableID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTableSchedule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TableIDs = append(m.TableIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTableSchedule
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTableSchedule
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTableSchedule
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TableIDs) == 0 {
					m.TableIDs = make([]github_com_pingcap_tiflow_cdc_model.TableID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_pingcap_tiflow_cdc_model.TableID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTableSchedule
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TableIDs = append(m.TableIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TableIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStopping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStopping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableID", wireType)
			}
			m.TableID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableID |= github_com_pingcap_tiflow_cdc_model.TableID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TableState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Checkpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, TableStatus{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStopping", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStopping = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerRevision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerRevision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerRevision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessorEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessorEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessorEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Epoch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &Message_Header{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = github_com_pingcap_tiflow_cdc_model.CaptureID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = github_com_pingcap_tiflow_cdc_model.CaptureID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispatchTableRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DispatchTableRequest == nil {
				m.DispatchTableRequest = &DispatchTableRequest{}
			}
			if err := m.DispatchTableRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DispatchTableResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DispatchTableResponse == nil {
				m.DispatchTableResponse = &DispatchTableResponse{}
			}
			if err := m.DispatchTableResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Heartbeat == nil {
				m.Heartbeat = &Heartbeat{}
			}
			if err := m.Heartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatResponse == nil {
				m.HeartbeatResponse = &HeartbeatResponse{}
			}
			if err := m.HeartbeatResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message_Header) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerRevision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OwnerRevision.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessorEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTableSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProcessorEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTableSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTableSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTableSchedule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTableSchedule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTableSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTableSchedule
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTableSchedule
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTableSchedule
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTableSchedule        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTableSchedule          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTableSchedule = fmt.Errorf("proto: unexpected end of group")
)
