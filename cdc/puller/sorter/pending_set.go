// Copyright 2021 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package sorter

import (
	"container/heap"
	"context"
	"math"
	"sync"
	"sync/atomic"

	"github.com/pingcap/log"
	"go.uber.org/zap"

	"github.com/google/btree"
	"github.com/pingcap/errors"
)

const (
	maxCompactionFactor  = 512
	maxCompactedFileSize = 128 * 1024 * 1024 // 128M
)

type pendingSet struct {
	tree      *btree.BTree
	compacted map[*flushTask]struct{}

	insertMu sync.Mutex
	inserted []*flushTask

	nextTaskID int64 // used to generate unique IDs for tasks
}

var (
	pendingSetFreeListMu sync.Mutex
	pendingSetFreeList   *btree.FreeList
)

func newPendingSet() *pendingSet {
	pendingSetFreeListMu.Lock()
	defer pendingSetFreeListMu.Unlock()

	if pendingSetFreeList == nil {
		pendingSetFreeList = btree.NewFreeList(100000)
	}

	return &pendingSet{
		tree:      btree.NewWithFreeList(3, pendingSetFreeList),
		compacted: map[*flushTask]struct{}{},
	}
}

// Insert inserts a flushTask into the pendingSet.
// Note that duplicate inserts are NOT allowed here.
func (s *pendingSet) Insert(task *flushTask) {
	s.insertMu.Lock()
	defer s.insertMu.Unlock()

	s.inserted = append(s.inserted, task)
}

func (s *pendingSet) flushInserted() {
	s.insertMu.Lock()
	defer s.insertMu.Unlock()

	for _, task := range s.inserted {
		if s.tree.ReplaceOrInsert(task) != nil {
			panic("duplicate element")
		}
	}

	s.inserted = s.inserted[:0]
}

// Delete deletes `task` from the pendingSet.
// If `task` was not previously in the pendingSet,
// the function returns false.
func (s *pendingSet) Delete(task *flushTask) bool {
	s.flushInserted()

	if s.tree.Delete(task) != nil {
		return true
	}

	if _, ok := s.compacted[task]; ok {
		delete(s.compacted, task)
		return true
	}

	return false
}

// AscendLessThanOrEqualTo iterates through the pendingSet in ascending order of `tsLowerBound`,
// until `fn` returns false or the `tsLowerBound` of a task is larger than `ts`.
func (s *pendingSet) AscendLessThanOrEqualTo(ts uint64, fn func(task *flushTask) (bool, error)) (ret error) {
	s.flushInserted()

	var retErr error
	s.tree.Ascend(func(taskI btree.Item) bool {
		task := taskI.(*flushTask)
		if task.tsLowerBound > ts {
			return false
		}
		ok, err := fn(task)
		if err != nil {
			retErr = errors.Trace(err)
			return false
		}
		return ok
	})
	if retErr != nil {
		return retErr
	}

	for task := range s.compacted {
		if task.tsLowerBound > ts {
			continue
		}
		ok, err := fn(task)
		if err != nil {
			return errors.Trace(err)
		}
		if !ok {
			break
		}
	}
	return
}

// closedCh is a closed channel used as the placeholder for
// flushTasks generated by the compactor.
var closedCh = func() chan error {
	ret := make(chan error)
	close(ret)
	return ret
}()

// ForAll iterators through all the tasks in the pendingSet.
func (s *pendingSet) ForAll(fn func(task *flushTask) (bool, error)) (ret error) {
	s.flushInserted()

	var retErr error
	s.tree.Ascend(func(taskI btree.Item) bool {
		task := taskI.(*flushTask)
		ok, err := fn(task)
		if err != nil {
			retErr = errors.Trace(err)
			return false
		}
		return ok
	})
	if retErr != nil {
		return retErr
	}

	for task := range s.compacted {
		ok, err := fn(task)
		if err != nil {
			return errors.Trace(err)
		}
		if !ok {
			break
		}
	}
	return
}

// Clear clears the pendingSet
func (s *pendingSet) Clear() {
	s.flushInserted()

	s.tree.Clear(false)
	s.compacted = nil
}

func (s *pendingSet) Compact(ctx context.Context, resolvedTs uint64) (ret error) {
	s.flushInserted()

	candidates, err := s.findCompactCandidates(ctx, resolvedTs)
	if err != nil {
		return errors.Trace(err)
	}

	if len(candidates) == 0 {
		return nil
	}

	backEnd, err := pool.alloc(ctx)
	if err != nil {
		return errors.Trace(err)
	}

	sortHeap := new(sortHeap)
	newFlushTask := &flushTask{
		taskID:        int(atomic.AddInt64(&s.nextTaskID, 1)),
		heapSorterID:  -1, // the compactor is -1
		tsLowerBound:  uint64(math.MaxUint64),
		maxResolvedTs: 0, // no need in compactor
		finished:      closedCh,
		isEmpty:       false,
		backend:       backEnd,
		itemCache:     nil,
	}
	newFlushTask.dealloc = func() error {
		backEnd := newFlushTask.GetBackEnd()
		if backEnd != nil {
			defer newFlushTask.markDeallocated()
			return pool.dealloc(backEnd)
		}
		return nil
	}

	defer func() {
		if ret != nil {
			_ = newFlushTask.dealloc()
		}
	}()

	for _, task := range candidates {
		if task.tsLowerBound < newFlushTask.tsLowerBound {
			newFlushTask.tsLowerBound = task.tsLowerBound
		}

		var err error
		task.reader, err = task.GetBackEnd().reader()
		if err != nil {
			return errors.Trace(err)
		}

		nextEvent, err := task.reader.readNext()
		if err != nil {
			return errors.Trace(err)
		}
		if nextEvent == nil {
			panic("empty backEnd, bug?")
		}

		heap.Push(sortHeap, &sortItem{
			entry: nextEvent,
			data:  task,
		})
	}

	writer, err := backEnd.writer()
	if err != nil {
		return errors.Trace(err)
	}
	defer func() {
		if ret != nil && writer != nil {
			_ = writer.flushAndClose()
		}
	}()
	count := uint64(0)
	for sortHeap.Len() > 0 {
		item := heap.Pop(sortHeap).(*sortItem)
		if err := writer.writeNext(item.entry); err != nil {
			return errors.Trace(err)
		}
		count++

		task := item.data.(*flushTask)
		nextEvent, err := task.reader.readNext()
		if err != nil {
			_ = task.reader.resetAndClose() // prevents fd leak
			task.reader = nil
			return errors.Trace(err)
		}
		if nextEvent == nil {
			// EOF
			if err := task.reader.resetAndClose(); err != nil {
				return errors.Trace(err)
			}
			if s.tree.Delete(task) == nil {
				panic("unreachable")
			}
			_ = task.dealloc()
			continue
		}

		heap.Push(sortHeap, &sortItem{
			entry: nextEvent,
			data:  task,
		})
	}
	newFlushTask.dataSize = int64(writer.dataSize())

	writer1 := writer
	writer = nil
	if err := writer1.flushAndClose(); err != nil {
		return errors.Trace(err)
	}

	s.compacted[newFlushTask] = struct{}{}

	log.Info("files compacted",
		zap.Int("num-files", len(candidates)),
		zap.Int64("data-size", newFlushTask.dataSize))

	return nil
}

func (s *pendingSet) findCompactCandidates(ctx context.Context, resolvedTs uint64) (ret []*flushTask, err error) {
	totalSize := int64(0)

	var (
		candidates []*flushTask
		retErr     error
	)
	s.tree.Descend(func(taskI btree.Item) bool {
		task := taskI.(*flushTask)
		log.Info("findCompactCandidates",
			zap.Uint64("tsLowerBound", task.tsLowerBound),
			zap.Uint64("resolvedTs", resolvedTs))
		if task.tsLowerBound <= resolvedTs {
			return false
		}

		select {
		case <-ctx.Done():
			retErr = errors.Trace(ctx.Err())
			return false
		case <-task.finished:
		}

		candidates = append(candidates, task)
		totalSize += task.dataSize
		if len(ret) >= maxCompactionFactor || totalSize >= maxCompactedFileSize {
			return false
		}
		return true
	})
	if retErr != nil {
		return nil, errors.Trace(retErr)
	}

	return candidates, nil
}

// Less implements the btree.Item interface, used to perform comparison in the btree.
func (t *flushTask) Less(than btree.Item) bool {
	other := than.(*flushTask)
	if t.tsLowerBound != other.tsLowerBound {
		return t.tsLowerBound < other.tsLowerBound
	}

	// We cannot allow comparison between two distinct tasks to tie,
	// because the btree implementation assumes that equality implies identity.
	//
	// i.e, if !a.Less(b) && !b.Less(a), btree treats this to mean a == b (i.e. we can only
	// hold one of either a or b in the tree).

	if t.taskID != other.taskID {
		return t.taskID < other.taskID
	}
	if t.heapSorterID != other.heapSorterID {
		return t.heapSorterID < other.heapSorterID
	}

	if t != other {
		panic("unreachable")
	}

	// We are truly comparing the task with itself,
	// so by definition we return false, since one element
	// cannot be less than itself.
	return false
}
