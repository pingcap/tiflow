diff --git a/cdc/owner/changefeed.go b/cdc/owner/changefeed.go
index 37fbca1dc..f9f3e6fdd 100644
--- a/cdc/owner/changefeed.go
+++ b/cdc/owner/changefeed.go
@@ -15,15 +15,12 @@ package owner
 
 import (
 	"context"
-	"strings"
 	"sync"
 	"time"
 
 	"github.com/pingcap/errors"
 	"github.com/pingcap/failpoint"
 	"github.com/pingcap/log"
-	"github.com/pingcap/tidb/parser"
-	"github.com/pingcap/tidb/parser/format"
 	timodel "github.com/pingcap/tidb/parser/model"
 	"github.com/pingcap/tiflow/cdc/contextutil"
 	"github.com/pingcap/tiflow/cdc/model"
@@ -890,10 +887,6 @@ func (c *changefeed) asyncExecDDLJob(ctx cdcContext.Context,
 func (c *changefeed) asyncExecDDLEvent(ctx cdcContext.Context,
 	ddlEvent *model.DDLEvent,
 ) (done bool, err error) {
-	ddlEvent.Query, err = addSpecialComment(ddlEvent.Query)
-	if err != nil {
-		return false, err
-	}
 	if ddlEvent.TableInfo != nil &&
 		c.schema.IsIneligibleTableID(ddlEvent.TableInfo.TableName.TableID) {
 		log.Warn("ignore the DDL event of ineligible table",
@@ -987,29 +980,3 @@ func (c *changefeed) checkUpstream() (skip bool, err error) {
 	}
 	return
 }
-
-// addSpecialComment translate tidb feature to comment
-func addSpecialComment(ddlQuery string) (string, error) {
-	stms, _, err := parser.New().ParseSQL(ddlQuery)
-	if err != nil {
-		return "", errors.Trace(err)
-	}
-	if len(stms) != 1 {
-		log.Panic("invalid ddlQuery statement size", zap.String("ddlQuery", ddlQuery))
-	}
-	var sb strings.Builder
-	// translate TiDB feature to special comment
-	restoreFlags := format.RestoreTiDBSpecialComment
-	// escape the keyword
-	restoreFlags |= format.RestoreNameBackQuotes
-	// upper case keyword
-	restoreFlags |= format.RestoreKeyWordUppercase
-	// wrap string with single quote
-	restoreFlags |= format.RestoreStringSingleQuotes
-	// remove placement rule
-	restoreFlags |= format.SkipPlacementRuleForRestore
-	if err = stms[0].Restore(format.NewRestoreCtx(restoreFlags, &sb)); err != nil {
-		return "", errors.Trace(err)
-	}
-	return sb.String(), nil
-}
diff --git a/cdc/owner/ddl_sink.go b/cdc/owner/ddl_sink.go
index 96da6ca04..b851c9a4f 100644
--- a/cdc/owner/ddl_sink.go
+++ b/cdc/owner/ddl_sink.go
@@ -15,6 +15,7 @@ package owner
 
 import (
 	"context"
+	"strings"
 	"sync"
 	"sync/atomic"
 	"time"
@@ -22,6 +23,8 @@ import (
 	"github.com/pingcap/errors"
 	"github.com/pingcap/failpoint"
 	"github.com/pingcap/log"
+	"github.com/pingcap/tidb/parser"
+	"github.com/pingcap/tidb/parser/format"
 	"github.com/pingcap/tiflow/cdc/contextutil"
 	"github.com/pingcap/tiflow/cdc/model"
 	sinkv1 "github.com/pingcap/tiflow/cdc/sink"
@@ -224,11 +227,21 @@ func (s *ddlSinkImpl) run(ctx context.Context) {
 				}
 
 			case ddl := <-s.ddlCh:
+				var err error
+				ddl.Query, err = addSpecialComment(ddl.Query)
+				if err != nil {
+					log.Error("Add special comment failed",
+						zap.String("namespace", s.changefeedID.Namespace),
+						zap.String("changefeed", s.changefeedID.ID),
+						zap.Error(err),
+						zap.Any("ddl", ddl))
+					s.reportErr(err)
+					return
+				}
 				log.Info("begin emit ddl event",
 					zap.String("namespace", s.changefeedID.Namespace),
 					zap.String("changefeed", s.changefeedID.ID),
 					zap.Any("DDL", ddl))
-				var err error
 				if s.sinkV1 != nil {
 					err = s.sinkV1.EmitDDLEvent(ctx, ddl)
 				} else {
@@ -369,3 +382,29 @@ func (s *ddlSinkImpl) close(ctx context.Context) (err error) {
 func (s *ddlSinkImpl) isInitialized() bool {
 	return s.initialized.Load().(bool)
 }
+
+// addSpecialComment translate tidb feature to comment
+func addSpecialComment(ddlQuery string) (string, error) {
+	stms, _, err := parser.New().ParseSQL(ddlQuery)
+	if err != nil {
+		return "", errors.Trace(err)
+	}
+	if len(stms) != 1 {
+		log.Panic("invalid ddlQuery statement size", zap.String("ddlQuery", ddlQuery))
+	}
+	var sb strings.Builder
+	// translate TiDB feature to special comment
+	restoreFlags := format.RestoreTiDBSpecialComment
+	// escape the keyword
+	restoreFlags |= format.RestoreNameBackQuotes
+	// upper case keyword
+	restoreFlags |= format.RestoreKeyWordUppercase
+	// wrap string with single quote
+	restoreFlags |= format.RestoreStringSingleQuotes
+	// remove placement rule
+	restoreFlags |= format.SkipPlacementRuleForRestore
+	if err = stms[0].Restore(format.NewRestoreCtx(restoreFlags, &sb)); err != nil {
+		return "", errors.Trace(err)
+	}
+	return sb.String(), nil
+}
